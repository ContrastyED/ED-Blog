[{"title":"图的存储 - 链式前向星","path":"/2025/07/15/链式前向星/","content":"其实本质上就是用链表实现的邻接表 基本信息 链式前向星是图论中一种 牛逼 高效的存储结构 时间复杂度： 添加边：O(1)O(1)O(1) 和邻接矩阵的复杂度一样，但是我们要在 head 数组的末尾添加新边，并更新头指针 遍历节点的出边：O(k)O(k)O(k) 其中：kkk 为这个节点的出边数量。直接通过头指针开始遍历链表即可 断边：最坏情况 O(m)O(m)O(m) 需要遍历 edges 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星 删除节点：O(n)O(n)O(n) 需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里） 空间复杂度：O(n+m)O(n+m)O(n+m)，其中：nnn 为节点数，mmm 为边数 添加与遍历 #includebits/stdc++.h#define int long longusing namespace std;const int NODE_LEN=1e5+5;const int EDGE_LEN=2e5+5;//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边//定义边，存储指向的目标节点和下一条边的索引，以及边权struct Edge int to,nxt,weight;edges[EDGE_LEN];//图中的所有边int head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标int cnt_edge=0;//边的数量void add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w edges[cnt_edge].to=v; //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v edges[cnt_edge].nxt=head[u]; head[u]=cnt_edge; //下一条边 edges[cnt_edge].weight=w;//由出发节点伸出的边的权值 cnt_edge++;//存完一个啦！提前准备好下一个！ cout添加边：( u - v ) 成功！且权值为 wendl; return;void traverse_nodes(int u)//遍历出发节点 u 的所有目标节点 cout节点 u 的所有出边信息：endl; for(int i=head[u];i!=-1;i=edges[i].nxt) cout( u - edges[i].to )，权值为 edges[i].weightendl; /* 初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引 循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！ 处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居 循环终止操作：找下一条边 */ return;signed main() memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接 //由于下面就是示例了，所以就用局部变量了 int n;//共计 n 个节点 cinn; for(int i=1;i=n;i++)//读入节点 int u,v,w;//出发节点和目标节点 cinuvw; add_edge(u,v,w); //add_edge(v,u,w); //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！ for(int i=1;i=n;i++) traverse_nodes(i);//遍历节点 i exit(0); 提示：学到这里已经足够应对大部分算法了，链式前向星 非常不适合删除操作 断边 下面介绍如何在链式前向星数据结构上增加删除边的功能。 需要注意的是，链式前向星本质上是一种一边 只增不减 的“静态”存储方式 删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。 下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。 注意：如果你的图中 经常需要删除边 ，链式前向星可能不是最适合的选择；2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。 1. 增加删除边所需要的代码 假设我们在前面的加权图结构基础上（包括 to、weight 和 nxt 字段）进行扩展。我们给出一个 delete_edge 函数，函数参数为起点 u 和目标 v ，表示删除一条从 u 到 v 的边（如果存在多条，则只删除第一个碰到的）。 我们来逐步说明删除边的思路，再给出代码： 找到目标边所在的链表位置 对于某个起点 u ，其边链表保存在从 head[u] 开始的一条单链表中。我们用两个变量： cur 用于遍历链表，初始设为 head[u] 。 pre 记录前驱节点的索引，初始为 -1（表示当前边是链表的第一个）。 遍历链表，搜索符合条件的边 从 cur 开始，遍历链表：如果发现 edges[cur].to==v（满足目标条件），则说明找到了要删除的边。 更新指针实现删除 如果 pre 为 -1，说明要删除的边正好位于链表头部，此时更新 head[u]=edges[cur].nxt； 否则，将前驱边的 nxt 指针更新为 edges[cur].nxt，这样跳过了当前边。 结束遍历 找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。 下面是完整的删除边函数代码： // 删除从 u 指向 v 的边（仅删除第一次匹配的边）void delete_edge(int u,int v) int cur=head[u]; int pre=-1; while(cur!=-1) if(edges[cur].to==v)//找到目标边 if (pre==-1) head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u] else edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须） edges[cur].nxt=-1; cout删除边 (u - v) 成功。endl; return; pre=cur; cur=edges[cur].nxt; cout边 (u - v) 不存在，删除失败。endl; return; 2. 遍历节点，验证删除功能 为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。 （其实这已经在 添加与遍历 演示了） // 遍历并输出结点 u 的所有出边（包括边的终点和权值）void traverse_nodes(int u)//遍历出发节点 u 的所有目标节点 cout节点 u 的所有出边信息：endl; for(int i=head[u];i!=-1;i=edges[i].nxt) cout( u - edges[i].to )，权值为 edges[i].weightendl; /* 初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引 循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！ 处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居 循环终止操作：找下一条边 */ return; 3. 示例 下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出： /*省略，真的太长了...可以翻到上面看看 添加与遍历*/// 删除从 u 指向 v 的边（仅删除第一次匹配的边）void delete_edge(int u,int v) int cur=head[u]; int pre=-1; while(cur!=-1) if(edges[cur].to==v)//找到目标边 if (pre==-1) head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u] else edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须） edges[cur].nxt=-1; cout删除边 (u - v) 成功。endl; return; pre=cur; cur=edges[cur].nxt; cout边 (u - v) 不存在，删除失败。endl; return;signed main() memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接 //这是张 **无向图** add_edge(1,2,5);add_edge(2,1,5); add_edge(1,3,10);add_edge(3,1,10); add_edge(1,4,3);add_edge(4,1,3); add_edge(2,3,7);add_edge(3,2,7); cout建边后的图endl; for(int i=1;i=4;i++) traverse_nodes(i); delete_edge(1,3); cout现在的图endl; for(int i=1;i=4;i++) traverse_nodes(i); exit(0); 示例中的初始图长这样： 程序执行过程说明 添加边阶段： 对于结点 1，经过多次调用 add_edge(1, ...)，其边链表可能为（头插法的结果是最新添加的边在链表头）： 头部指向边：1 - 4 通过 nxt 链到边：1 - 3 再通过 nxt 链到边：1 - 2 结点 2 拥有边：2 - 3。 删除操作： 调用 delete_edge(1,3) 后，会遍历结点 1 的边链。 当遍历到边记录 edges[i].to==3 时，将其从链表中“删除”： 如果该边不是头部，就把前一个边的 nxt 指向当前边的 nxt。 此后，遍历结点 1 时，1 - 3 就不会再被输出。 遍历验证： 调用 traverse_node 验证删除后，结点 1 的链表中只剩下 1 - 4 和 1 - 2。 4. ASCII 图示辅助理解删除操作 假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）： head[1] -- [index 2: (1 - 4), nxt = index 1] [index 1: (1 - 3), nxt = index 0] [index 0: (1 - 2), nxt = -1] 删除 1-3 的过程： 遍历时，cur 先指向 index 2 (边 1-4)，不匹配； 然后 cur 指向 index 1 (边 1-3)，匹配目标。此时 pre 指向 index 2。 更新 edges[pre].nxt，即 edges[2].nxt = edges[1].nxt（即 index 0）。 结果链表变为： head[1] -- [index 2: (1 - 4), nxt = index 0] [index 0: (1 - 2), nxt = -1] 删除后的遍历顺序即输出 1-4 和 1-2。 5. 小结 删除边的思路： 在链表中找到目标边的位置。 通过修改上一节点的 nxt 指针或更新 head[u]，跳过目标边，令其不参与后续遍历。 局限性： 这种删除操作只更新了指针，并没有真正回收数组中的空间。 如果后续还需要添加边，可以继续使用 add_edge，但是删除的空间不会被重用（除非重新构造数据结构）。 扩展思考： 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。 通过以上代码和说明，你可以在链式前向星上实现边的删除功能。 删除节点 下面讨论如何在链式前向星中实现“删除节点”的功能。 需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分： 删除该节点的所有出边（从该节点出发的边）， 这部分比较简单； 删除其他节点中所有指向该节点的入边， 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。 因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法： 方法 1：物理删除（实际修改链表结构） 在物理删除时，我们需要同时删除： 节点 u 的出边（即把 head[u] 置为 -1 或清空整个链表）， 其他所有节点链表中指向 u 的边。 这种方法的基本思路如下： 删除 u 的出边 直接将 head[u] 设为 -1，相当于断开了 u 对外的所有边。 删除所有指向 u 的入边 遍历图中所有其他节点 v 的边链表，在每个链表中查找边： if (edges[cur].to == u) 找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 nxt 指针或更新 head[v]）。 由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）： // 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边void delete_node(int u,int n)//n 表示图中总的节点数 // 1. 删除 u 的所有出边：直接断开该链表 head[u]=-1; // 2. 删除其他节点中指向 u 的入边 for(int v=1;v=n;v++) if(v==u) continue;//已经处理了 u 的出边 int cur=head[v]; int pre=-1; while(cur!=-1) if(edges[cur].to==u)//找到边 v-u，需要删除 if(pre==-1) //被删除的边在链表头，更新 head[v] head[v]=edges[cur].nxt; //更新 cur 为新的头节点 cur=head[v]; else // 跳过当前边 edges[pre].nxt=edges[cur].nxt; cur=edges[cur].nxt; // 注意：如果存在多条边指向 u，此处可以继续遍历删除 else pre=cur; cur=edges[cur].nxt; cout节点 u 删除完成 (出边和入边均已移除）。endl; return; 注意事项 这种物理删除不会真正回收 edges[] 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。 方法 2：懒删除（逻辑删除） 在很多实际场景下，动态删除节点（或边）时，我们可以采用 懒删除 的策略，而不是立即修改链表结构。方法是： 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 nodeExist[N]。 当需要删除节点 u 时，只需将 nodeExist[u] 标记为 false 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。 这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。 示例代码（仅思路）： bool nodeExist[N];// 初始化时，将所有节点设为存在void init(int n) for(int i=1;i=n;i++) nodeExist[i]=true; return;// 懒删除节点 u，标记为不存在void lazy_delete_node(int u) nodeExist[u]=false; cout节点 u 已被标记为删除。endl; return;// 在遍历时，检查目标节点是否存在void process_edges(int u) if(!nodeExist[u]) return;//该节点已经被删除，则不处理 for(int i=head[u];i!=-1;i=edges[i].nxt) int v=edges[i].to; if(!nodeExist[v]) continue;//如果终点已删除，则跳过该边 // 此处对边 (u - v) 做处理 return; 小结 物理删除节点： 将该节点的所有出边置为空（如 head[u]=-1）， 遍历其他所有节点的边链表，删除所有指向该节点的入边。 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。 懒删除（逻辑删除）： 通过维护一个节点存在标志，在删除节点时仅做标记。 在遍历和处理时跳过被删除的节点及其相关边。 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。 根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","tags":["算法","图论","存储"],"categories":["学习","分享"]},{"title":"快读快写模板","path":"/2025/07/12/快读快写模板/","content":"本文整理了在 OI 中可以提升读写速度的模板，持续更新中… 整型快读快写模板 #includebits/stdc++.h#define int long longusing namespace std;inline void read(int a) int s=0,w=1; char ch=getchar(); while(ch0||ch9) if(ch==-) w=-1; ch=getchar(); while(ch=0ch=9) s=s*10+ch-0; ch=getchar(); a=s*w; return;inline void write(int x) static int sta[10]; int top=0; do sta[top++]=x%10; x/=10; while(x); while(top) putchar(sta[--top]+0); //putchar( ); //可选的行末空格 //putchar( ); //可选的行末换行 return;signed main() int a,b; read(a); read(b); write(a+b); return 0;","tags":["OI","模板"],"categories":["学习","分享"]},{"title":"搜索题目整理","path":"/2025/07/12/搜索题目整理/","content":"本文整理了 ED_Builder 在初学搜索算法时做的题目 DFS P1219 八皇后 #includebits/stdc++.husing namespace std;int n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案bool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问void print()//输出答案 if(ans3) return;//由题可得,只需要输出 3 种排列 for(int i=1;i=n;i++) couta[i] ; coutendl; return;void dfs(int x)//形参 x :当前是第 x 个皇后 if(xn)//一种可行的方案达成 ans++;//方案数++ print();//输出答案 return; for(int i=1;i=n;i++)//枚举所有答案 if(!vis_lie[i]!vis_l[x-i+n]!vis_r[x+i])//是否被访问过(规律见 L40 ) vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记 a[x]=i;//存答案 dfs(x+1);//继续递归 vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯 int main() cinn; dfs(1); coutans; return 0;/*对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等*/ P1706 全排列问题 P1 - DFS #includebits/stdc++.husing namespace std;int n,a[20];//枚举 n 个数字,可行的答案存放在 a 中bool vis[20];//已经被访问过的void print()//输出答案 for(int i=1;i=n;i++) coutsetw(5)a[i]; coutendl; return;void dfs(int x) if(xn)//已经有了一个方案 print(); return; for(int i=1;i=n;i++) if(!vis[i])//没被访问 a[x]=i;//记录答案 vis[i]=true;//标记 dfs(x+1);//继续递归 vis[i]=false;//回溯 int main() cinn; dfs(1);//从 1 开始 return 0; P2 - 枚举优化 #includebits/stdc++.husing namespace std;int main() int n; cinn; int num[n]; for(int i=1;i=n;i++) num[i]=i; do for(int i=1;i=n;i++) coutsetw(5)num[i]; coutendl; while(next_permutation(num+1,num+1+n)); return 0; P1605 迷宫 #includeiostream#includecstring//这里不用万能头是因为想用 map 当变量名using namespace std;int n,m,t,sx,sy,fx,fy,ans;//地图长宽,障碍数量,起点坐标,终点坐标,答案int dx[5]=1,0,-1,0,dy[5]=0,-1,0,1;//位移bool map[10][10];//地图void dfs(int x,int y) if(x==fxy==fy)//到达终点 ans++; return; for(int i=0;i4;i++)//枚举位移 int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动 if(tmp_x=1tmp_x=ntmp_y=1tmp_y=mmap[tmp_x][tmp_y]) //合法判断:坐标未越界,位置可用(没有障碍且没被访问) map[tmp_x][tmp_y]=false;//标记访问 dfs(tmp_x,tmp_y);//继续递归 map[tmp_x][tmp_y]=true;//回溯 int main() memset(map,true,sizeof(map));//初始化 cinnmtsxsyfxfy; for(int i=1;i=t;i++)//读入障碍 int x,y; cinxy; map[x][y]=false;//不能走 map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问! dfs(sx,sy); coutans; return 0; P1036 选数 #includebits/stdc++.husing namespace std;int n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案bool vis[25];//是否已经被选择bool check_prime(int n)//判断质数 if(n=1) return false; for(int i=2;i=sqrt(n);i++) if(n%i==0) return false; return true;void dfs(int pos,int cnt,int sum) if(cnt=k)//选完了 if(check_prime(sum)) ans++;//判断质数,然后答案自增 return; for(int i=pos;i=n;i++) if(vis[i])//没被选 vis[i]=false;//标记 dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数 vis[i]=true;//回溯 int main() memset(vis,true,sizeof(vis));//初始化 cinnk; for(int i=1;i=n;i++) cinx[i]; dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0 coutans; return 0; P1238 走迷宫 #includebits/stdc++.h#define int long longusing namespace std;int m,n;// m 行 n 列 int mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 int begin_x,begin_y,end_x,end_y;//起点和终点 int dx[5]=0,-1,0,1,dy[5]=-1,0,1,0;//偏移int ans[100000][3],k;//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 void print()//输出一种答案 if(have_solution==false) have_solution=true;//更新为有解 for(int i=0;ik;i++) cout(ans[i][1],ans[i][2])-; cout(end_x,end_y)endl; //因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 void dfs(int x,int y) if(x==end_xy==end_y)//到达终点 print();//输出答案 return; for(int i=0;i4;i++)//枚举偏移 int nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 if(mp[nxt_x][nxt_y]==1vis[nxt_x][nxt_y]==0) //下一步可以走并且没被访问 vis[x][y]=1;//标记上一步被访问 ans[k][1]=x,ans[k][2]=y;//记录可行的一步 k++;//增加指针 dfs(nxt_x,nxt_y);//继续找下一步 vis[x][y]=0;//回溯,设为未访问 k--;//倒回去 signed main() cinmn; for(int i=1;i=m;i++) for(int j=1;j=n;j++) cinmp[i][j];//读入地图 cinbegin_xbegin_yend_xend_y;//读入起点和终点 dfs(begin_x,begin_y); if(!have_solution) cout-1;//没有解 return 0;//结束 :) BFS 注意: BFS 不能用于加权图,因为 BFS 只会查找边数最少的路径 例如 100 - 100 和 1 - 1 - 1 - 1 BFS 会选择 100 - 100 当数据范围较小（ ≤20\\le20≤20 ）时，用 DFS 也不是不可以 P1746 离开中山路 #includeiostream#includequeueusing namespace std;struct Point//单个点的坐标 int x,y;;int n;char map[1005][1005];int dis[1005][1005];//到起点的距离int dx[]=1,0,-1,0;int dy[]=0,1,0,-1;//位移int start_x,start_y,final_x,final_y;//由题可得,起点和终点queuePoint q;//等待处理的点void bfs(int x,int y) q.push((Point)x,y);//压入当前点 dis[x][y]=0;//起点 while(!q.empty())//只要队列非空 Point t=q.front();//读取当前队头 q.pop();//弹出 for(int i=0;i4;i++)//枚举位移 int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点 if(nxt_x1||nxt_xn||nxt_y1||nxt_yn||map[nxt_x][nxt_y]==1||dis[nxt_x][nxt_y]0) continue; //判断:越界+有障碍+被访问 q.push((Point)nxt_x,nxt_y);//压入下一个点 dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离 return;int main() cinn; for(int i=1;i=n;i++) for(int j=1;j=n;j++) cinmap[i][j]; cinstart_xstart_yfinal_xfinal_y; bfs(start_x,start_y); coutdis[final_x][final_y]; return 0; P1443 马的遍历 #includebits/stdc++.husing namespace std;struct Point//当前马位于的坐标 int x,y;;int n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步int dx[]=2,1,-2,1,-1,2,-2,-1;int dy[]=1,2,1,-2,2,-1,-1,-2;//位移queuePoint q;//当前需要处理的点void bfs(int x,int y) q.push((Point)x,y);//入队处理起点 dis[x][y]=0;//起点已经有一个马了 while(!q.empty()) Point t=q.front();//取队头处理 q.pop();//弹出 for(int i=0;i8;i++)//枚举位移 int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标 if(nxt_x1||nxt_xn||nxt_y1||nxt_ym||dis[nxt_x][nxt_y]!=-1) continue; //检查:越界+被访问 dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1 q.push((Point)nxt_x,nxt_y);//继续压入新的点继续处理 return;int main() memset(dis,-1,sizeof(dis));//初始化 cinnmxy; bfs(x,y); for(int i=1;i=n;i++) for(int j=1;j=m;j++) coutsetw(5)dis[i][j]; coutendl; return 0; P2895 Meteor Shower S 耗时 2 个月的巅峰对决，但最终还是我赢了！ #includebits/stdc++.h#define int long longusing namespace std;const int LEN=305;struct Point//存储坐标的点 int x,y;;int m;int mp[LEN][LEN],dis[LEN][LEN];//地图,距离 int dx[]=-1,0,1,0,dy[]=0,1,0,-1;//偏移 queuePoint q;int bfs() q.push((Point)0,0);//第一个位置是 (0,0) dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 while(!q.empty()) Point now=q.front();//找到当前点 q.pop(); for(int d=0;d4;d++)//枚举偏移 int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置 if(nxt_x0||nxt_y0) continue;//越界 if(dis[nxt_x][nxt_y]) continue;//被访问 if(dis[now.x][now.y]+1=mp[nxt_x][nxt_y]) continue; //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较 dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 q.push((Point)nxt_x,nxt_y);//压入下一个点 if(mp[nxt_x][nxt_y]1e9) return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 return -1;signed main() memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 cinm; while(m--) int x,y,time;//坐标,流星砸下来的时间 cinxytime; mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 for(int d=0;d4;d++)//枚举偏移 int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 if(nxt_x0||nxt_x301||nxt_y0||nxt_y301) continue;//越界 mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 coutbfs(); exit(0);","tags":["搜索","算法"],"categories":["学习","分享"]},{"title":"图论 - 最小生成树","path":"/2025/07/10/最小生成树/","content":"本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal Prim（加点法） 基本信息 每次迭代选择边权最小的边对应的点，加入到最小生成树中。 算法从某个顶点 startstartstart 开始，逐渐延伸覆盖整个连通网的所有顶点 时间复杂度：O(n2)O(n^2)O(n2) 算法思想 蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。 每次循环都将一个蓝点 uuu 变为白点，并且这个蓝点 uuu 与白点相连的最小边权 min(weight[u]) 还是当前所有蓝点中最小的。 这样相当于向生成树中添加了 n−1n-1n−1 次最小的边，最后得到的一定是最小生成树 算法描述 以 111 为起点生成最小生成树，min[v] 表示蓝点 v 与白点相连的最小边权，mst 表示最小生成树的权值之和 初始化：min[v]=INF(v≠1)(v e 1)(v=1) min[1]=0 mst=0 for(int i=1;i=n;i++) 1. 寻找 min[u] 最小的蓝点 u 2. 将 u 标记为白点 3. mst+=min[u]; 4. for(与白点 u 相连的所有蓝点 v) if(weight[u][v]min[v]) min[v]=weight[u][v]; 算法结束，mst 即为最小生成树的权值之和 例题 - YBT 1349 #includebits/stdc++.husing namespace std;const int LEN=105,INF=0x3f;int graph[LEN][LEN];int minn[LEN];bool vis[LEN];int n,mst=0;void init() memset(minn,INF,sizeof(minn)); minn[1]=0; memset(vis,true,sizeof(vis));int main() cinn; init(); for(int i=1;i=n;i++) for(int j=1;j=n;j++) cingraph[i][j]; for(int i=1;i=n;i++) int k=0; for(int j=1;j=n;j++) if(vis[j](minn[j]minn[k])) k=j; vis[k]=false; for(int j=1;j=n;j++) if(vis[j](graph[k][j]minn[j])) minn[j]=graph[k][j]; for(int i=1;i=n;i++) mst+=minn[i]; coutmst; return 0; Kruskal 基本信息 Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。 Kruskal 算法将一个连通块当做一个集合。 时间复杂度为 O(E log(E))O(E\\ log(E))O(E log(E))，E为边数。 算法思想 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 nnn 个独立的集合。 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。 直到选取了 n−1n-1n−1 条边为止。 通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的 边，一张 nnn 个顶点的图总共选取 n−1n-1n−1 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 nnn 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 n−1n-1n−1 条边，连接着 nnn 个顶点的最小生成树。 算法描述 初始化并查集：fa[x]=x，初始化总权值和：mst=0 将所有边用快排 从小到大 排序 计数器 k=0 for(int i=1;i=m;i++) if(这是一条 u,v 不属于同一集合的边 u-v) 1. 合并 u,v 所在的集合，相当于把 u-v 加入最小生成树 2. mst+=weight[u][v] 3. k++; 4. if(k==n-1) break; 最小生成树已经生成，跳出循环 算法结束，mst 即为最小生成树的总权值之和 例题 - Luogu P3366 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=2e5+5;struct Edge int u,v,w;edge[LEN];int cnt;int fa[5005];int n,m,mst=0,edges_cnt=0;int find(int x) if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];void merge(int x,int y) int fx=find(x); int fy=find(y); if(fx!=fy) fa[fx]=fy; return;void addedge(int u,int v,int w) cnt+=1; edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; return;bool cmp(Edge a,Edge b)return a.wb.w;signed main() cinnm; for(int i=1;i=m;i++) int u,v,w; cinuvw; addedge(u,v,w); for(int i=1;i=n;i++) fa[i]=i; stable_sort(edge+1,edge+cnt+1,cmp); for(int i=1;i=cnt;i++) if(find(edge[i].u)!=find(edge[i].v)) merge(edge[i].u,edge[i].v); mst+=edge[i].w; edges_cnt++; if(edges_cnt==m) break; if(edges_cntn-1) coutorz; else coutmst; return 0;","tags":["算法","图论","最小生成树"],"categories":["学习","分享"]},{"title":"图论 - 最短路","path":"/2025/07/10/最短路/","content":"本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA Floyd 基本信息 定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 aaa 到顶点 bbb）之间的路程变短，只能引入第三个点（顶点 kkk），并通过这个顶点 kkk 中转，即 a-k-b，才可能缩短原来从顶点 aaa 到顶点 bbb 的路程。 原理：三重循环枚举中转点 k，状态转移方程：dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]) 时间复杂度：O(n3)O(n^3)O(n3) 算法步骤 由于在图中 没有负环 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。 例题 - Luogu B3647 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=105,INF=0x3f;int graph[LEN][LEN],n,m;signed main() cinnm; memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连 for(int i=1;i=n;i++) graph[i][i]=0;//自己到自己为 0 while(m--) int u,v,w; cinuvw; graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值 for(int k=1;k=n;k++) for(int i=1;i=n;i++) for(int j=1;j=n;j++) graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]); //暴力查找第三点 k，以及通过边权求最小值 for(int i=1;i=n;i++) for(int j=1;j=n;j++) if(graph[i][j]==INF) cout0 ;//没有边相连 else coutgraph[i][j] ; coutendl; return 0; 上面这玩意只有 80pts Dijkstra 基本信息 定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。 主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 所有的边权全部非负。 原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。 时间复杂度：O(n2)O(n^2)O(n2) 算法步骤 初始化 graph[v0]=0 ，出发点 到其他顶点的距离 graph[i]=INF 经过 nnn 次下面的操作，最后得到 v0v_0v0​ 到 nnn 个顶点的最短距离 1. 选择一个未被标记的、且 graph[k] 的值是最小的顶点 kkk 2. 标记顶点 kkk，即 vis[k]=true 3. 以 kkk 为中间点，修改出发点 v0v_0v0​ 到其他未被标记的顶点的 jjj 的距离值 graph[j] 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2 1. 在集合 2 中找一个到出发点距离最近的顶点 kkk： min{dis[k]}min\\{dis[k]\\}min{dis[k]} 2. 把顶点 kkk 加到集合 1 中，同时检查集合 2 中的剩余顶点 jjj 的 dis[j] 是否经过 kkk 后变短，如果变短修改 dis[j] if(dis[k]+wait[k][j]dis[j]) dis[j]=dis[k]+wait[k][j] 3. 重复步骤 3.1 ，直至集合 2 空为止 例题 - Luogu P3371（但是弱化版） #includebits/stdc++.h#define int long longusing namespace std;const int LEN=1e6+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[LEN];int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt;void init() for(int i=1;i=n;i++) ans[i]=INF; memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() cinmns; init(); ans[s]=0; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); int pos=s; while(vis[pos]==0) int minn=INF; vis[pos]=true; for(int i=head[pos];i!=0;i=edge[i].nxt) if(!vis[edge[i].to]ans[edge[i].to]ans[pos]+edge[i].weight) ans[edge[i].to]=ans[pos]+edge[i].weight; for(int i=1;i=m;i++) if(ans[i]minnvis[i]==0) minn=ans[i]; pos=i; for(int i=1;i=m;i++) coutans[i] ; return 0; 但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 dis[] 中的最小值，所以我们可以用…… 堆优化 堆是一种可以在 O(log(n))O(log(n))O(log(n)) 的时间插入数据，O(1)O(1)O(1) 的时间删除和查找当前极值（最大或最小值） 那么原来求最小值的 O(n)O(n)O(n) 的算法，可以改为使用堆来求最小值，时间复杂度降到 O(log(n))O(log(n))O(log(n)) ，整体复杂度降到 O(n log(n))O(n\\ log(n))O(n log(n)) 对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……） 对于 Dijkstra 的堆优化有两种方法: 重载运算符 两元组 例题 - Luogu P4779（但是标准版） 别想把 P3371 的代码交上去，全部 TLE Solution-1 重载运算符 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=1e6+5,INF=0x3f;struct Edge int to,nxt,weight;edge[LEN];struct Priority int ans,id; bool operator (const Priority x)constreturn x.ansans;;int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt; return;void init() memset(ans,INF,sizeof(ans)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() init(); cinmns; ans[s]=0; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); int u; priority_queuePriority q; q.push((Priority)0,s); while(!q.empty()) Priority tmp=q.top(); q.pop(); u=tmp.id; if(!vis[u]) vis[u]=true; for(int i=head[u];i;i=edge[i].nxt) int v=edge[i].to; if(ans[v]ans[u]+edge[i].weight) ans[v]=ans[u]+edge[i].weight; if(!vis[v]) q.push((Priority)ans[v],v); for(int i=1;i=m;i++) coutans[i] ; return 0; Solution-2 两元组 #includebits/stdc++.h#define pii pairint,int#define int long longusing namespace std;const int LEN=1e6+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[LEN];int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt;void init() for(int i=1;i=n;i++) ans[i]=INF; memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() cinmns; init(); priority_queuepii,vectorpii,greaterpii q; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); ans[s]=0; q.push(pii0,s); int u; while(!q.empty()) pii x=q.top(); q.pop(); if(vis[x.second]) continue; u=x.second; vis[u]=true; for(int i=head[u];i;i=edge[i].nxt) if(ans[edge[i].to]ans[u]+edge[i].weight) ans[edge[i].to]=ans[u]+edge[i].weight; q.push(pii(ans[edge[i].to],edge[i].to)); for(int i=1;i=m;i++) coutans[i] ; return 0; SPFA SPFA 是 Bellman-Ford 的一种 队列优化，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算 基本信息 定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 队列优化，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算 SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。 时间复杂度：O(kE)O(kE)O(kE)，EEE 是边数，kkk 是常数，平均值是 222 算法步骤 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改 若某个相邻的顶点修改成功，则将其入队 队列为空时，算法结束 实现方法 建立一个队列，并且将出发点入列，用 dis[i] 记录出发点到其他所有点的最短路径 执行松弛操作，一次用队列里有的点 uuu 去更新所有后继节点 viv_ivi​ 的最短路，如果 viv_ivi​ 被更新成功且不在队列中，则把 viv_ivi​ 加入队列，重复执行直到队列为空 节点可能多次被更新，可以多次进入队列 if(dis[u]+wdis[v]) d[v]=d[u]+w; 如果 VVV 被更新了且队列中不存在，再一次进入队列 例题 - Luogu P3371 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=5e5+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[2*LEN];int cnt=0,head[LEN],dis[LEN];bool vis[LEN];int n,m,start;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt; return;void SPFA() queueint q; dis[start]=0; q.push(start); vis[start]=true; while(!q.empty()) int now=q.front(); q.pop(); vis[now]=false; for(int i=head[now];i;i=edge[i].nxt) int to=edge[i].to; if(edge[i].weight+dis[now]=dis[to]) dis[to]=edge[i].weight+dis[now]; if(!vis[to]) q.push(to); vis[to]=true; return;void init() for(int i=1;i=n;i++) dis[i]=INF; memset(head,0,sizeof(head)); return;signed main() cinnmstart; init(); for(int i=1;i=m;i++) int u,v,w; cinuvw; addedge(u,v,w); SPFA(); for(int i=1;i=n;i++) coutdis[i] ; return 0; 有些考试会用数据卡掉 SPFA 导致 TLE，比如 Luogu P4779 会导致 SPFA 算法在 #1,2,3,5,6 TLE SPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别 总结 Floyd 最简单，多源最短路大暴力，O(n3)O(n^3)O(n3) 复杂度卡死你 Dijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 O(n log(n))O(n\\ log(n))O(n log(n)) SPFA 易理解，和 BFS 很类似，某些题目 会卡掉，慎重选择需技巧 被迫回去看链式前向星的笔记了 :(","tags":["算法","图论","最短路"],"categories":["学习","分享"]},{"title":"关于我","path":"/about/index.html","content":"我写的不好，大部分都是直接搬运 Luogu 主页 的。 关于我 一个 ISTJ-T 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02） 一个尽力学习的 OIer 一个用私人服务器的 Arcaea 玩家（PTT = 11.08） 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D） 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57） 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了） 我的参与 现任 量子诗笺 技术站长 生物死刑网站 主要开发者 欢迎来使用 ED-ImgHub 和 ED-Comment"},{"path":"/friends/index.html","content":"量子诗笺"},{"title":"Summer Camping Study Note","path":"/notebooks/scsn/index.html","content":"这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。"},{"title":"单调栈和单调队列","path":"/notebooks/scsn/单调栈和单调队列.html","content":"算法分析 数据结构 时间复杂度 空间复杂度 典型用途 单调栈 O(n)O(n)O(n) O(n)O(n)O(n) 找下一个更大 / 更小元素 单调队列 O(n)O(n)O(n) O(n)O(n)O(n) 滑动窗口最大 / 最小值 单调栈 单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。 单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。 思路 使用一个栈 sta，栈中存储的是“候选元素”的下标（下同）。 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。 遍历数组 A： 当 A[i] 大于栈顶元素 A[sta.top()] 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。 重复上述步骤直到栈空或 A[i] = A[sta.top()]。 将当前下标 i 入栈。 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。 代码示例 例题：Luogu P5788 - 【模板】单调栈 #includebits/stdc++.husing namespace std;const int LEN=3e6+5;int a[LEN],f[LEN];int n;int main() cinn; for(int i=1;i=n;i++) cina[i]; stackint sta;//存储下标 for(int i=1;i=n;i++) //找到一个更大的元素下标 while(!sta.empty()a[i]a[sta.top()]) f[sta.top()]=i; sta.pop();//维护单调性 sta.push(i); for(int i=1;i=n;i++) coutf[i] ; return 0; 单调队列 单调队列通常用来维护滑动窗口中的最大值或最小值，以 O(1) 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。 思路 使用 dequeint dq，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。 遍历数组 A，下标为 i： 如果队头 dq.front() 已经滑出窗口范围（i - dq.front() = k），则 dq.pop_front()。 将当前元素与队尾元素比较，若 A[i] 大于等于 A[dq.back()]，弹出队尾，直到队尾大于当前元素。 将 i 推入队尾。 当窗口形成（i = k-1）时，队头即为窗口最大值下标，记录 A[dq.front()]。 代码示例 例题：Luogu P1886 - 滑动窗口 /【模板】单调队列 #includebits/stdc++.husing namespace std;const int LEN=1e6+5;int a[LEN],n,k;//单调递增队列求最小值void getMin() dequeint dq; for(int i=1;i=n;i++) //队头元素是否滑出窗口 if(!dq.empty()dq.front()=i-k) dq.pop_front(); //维护递增性：弹出比当前值大的队尾元素 while(!dq.empty()a[dq.back()]a[i]) dq.pop_back(); dq.push_back(i); //输出窗口最小值 if(i=k) couta[dq.front()] ; //单调递减队列求最大值void getMax() dequeint dq; for(int i=1;i=n;i++) //队头元素是否滑出窗口 if(!dq.empty()dq.front()=i-k) dq.pop_front(); //维护递减性：弹出比当前值小的队尾元素 while(!dq.empty()a[dq.back()]a[i]) dq.pop_back(); dq.push_back(i); if(i=k) couta[dq.front()] ; int main() cinnk; for(int i=1;i=n;i++) cina[i]; getMin();//输出每个窗口的最小值 coutendl; getMax();//输出每个窗口的最大值 return 0; 小结 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。 单调队列主要用于“滑动窗口”相关最大/最小值。 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","tags":[null]}]