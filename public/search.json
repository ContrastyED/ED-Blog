[{"title":"备战 CSP-J","path":"/2025/08/13/备战CSP-J/","content":"很难很累，但还是必须去做 任务清单 一轮真题 2019 CSP-J1 2020 CSP-J1 2021 CSP-J1 2022 CSP-J1 2023 CSP-J1 2024 CSP-J1 二轮真题 2019 CSP-J2 2020 CSP-J2 2021 CSP-J2 2022 CSP-J2 2023 CSP-J2 2024 CSP-J2 题目选讲 2019 CSP-J1 1. 常识积累 T1：中国的国家顶级域名是 .cn T3：一个 32 位整形变量占用 4 个字节 T5：折半查找（二分）时，找到目标最多需要 log(n) 次 T6：链表在 插入和删除 中表现优异，在 查询 中表现较差，也不必事先估计存储空间 T9：100 以内的最大质数是 97 T15：计算机科学领域的最高奖是 图灵奖 2. 数论计算 T7（整数划分） 把 888 个同样的球放在 555 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？ 提示：如果 888 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。 A. 22 B. 24 C. 18 D. 20 解析：直接暴力枚举，然后去重就没了 T12（鸽巢原理） 一副纸牌除掉大小王有 52 张牌，四种花色，每种花色 13 张。 假设从这 52 张牌中随机抽取 13 张牌，则至少（）张牌的花色一致。 A. 4 B. 2 C. 3 D. 5 解析：设在 12 张牌中，每种花色 3 张（最坏情况），那么再多一张一定会有 4 张牌的花色一致 T13（乘法原理） —些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。 类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。 请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（） A. 60 B. 125 C. 75 D. 100 解析：在 0,1,8,6,9 中选择，然后判断回文数（因为顺序颠倒之后还要求是原来的车牌），那么我们只需要考虑第 1，2，3 位就好了 但是颠倒之后 6 和 9 会互换，所以第 3 位不能是 6 和 9 所以第一、二位有 5 种选择，第三位有 3 种选择，根据乘法原理可得最终方案数为 5×5×3=755\\times5\\times3=755×5×3=75 知识积累 与或非运算 这些操作都要在 二进制下 完成 按位与：：每一位都必须是 1 才会得到 1，否则是 0 按位或：|：每一位只要有一个是 1 就会得到 1 按位非：~：每一位取反 按位异或：^：每一位相同为 0，不同为 1 在数学上，∧\\land∧ 和 是一样的，∨\\lor∨ 和 | 是一样的，¬ eg¬ 和 ~ 是一样的 （重难点）进制转换 转换技巧：遇到 x 进制转 y 进制，可以先把 x 进制转为 10 进制，再转为 y 进制 x 进制转 10 进制 按位展开，乘权相加 例如 (2F)16(2F)_{16}(2F)16​ 转 10 进制： (2F)16=2×161+15×160=32+15=(47)10(2F)_{16}=2\\times16^1+15\\times16^0=32+15=(47)_{10} (2F)16​=2×161+15×160=32+15=(47)10​ 在上面的式子中，FFF 其实就是十进制里面的 151515，这不用多说 如果是带小数的部分，要 乘负权相加 例如 (A.F)16(A.F)_{16}(A.F)16​ 转 10 进制 (A.F)16=10×160+15×16−1=10+15161=(10.9375)10(A.F)_{16}=10\\times 16^0+15\\times 16^{-1}=10+\\frac{15}{16^1}=(10.9375)_{10} (A.F)16​=10×160+15×16−1=10+16115​=(10.9375)10​ 10 进制转 x 进制 不断除以 x，余数倒着写，商循环利用 例如 (47)10(47)_{10}(47)10​ 转 16 进制 47÷16=2…15(F)2÷16=0…2∴(47)10=(2F)1647\\div16=2\\dots 15({\\color{red}F})\\\\ 2\\div16=0\\dots {\\color{red}2}\\\\ \\therefore (47)_{10}=({\\color{red}2F})_{16} 47÷16=2…15(F)2÷16=0…2∴(47)10​=(2F)16​ 如果是带小数的转换，要 不断乘以 x，商取整，顺着写，余数循环利用 例如 (114.514)10(114.514)_{10}(114.514)10​ 转 8 进制 那么我们先算整数部分： 114÷8=14…214÷8=1…61÷8=0…1∴(114)10=(162)8114\\div 8=14\\dots {\\color{red}2}\\\\ 14\\div 8=1\\dots {\\color{red}6}\\\\ 1\\div 8=0\\dots {\\color{red}1}\\\\ \\therefore (114)_{10}=({\\color{red}162})_{8} 114÷8=14…214÷8=1…61÷8=0…1∴(114)10​=(162)8​ 然后算小数部分： 0.514×8=4.1120.112×8=0.9120.912×8=7.296∴(0.514)10=(0.407)80.514\\times 8={\\color{red}4}.112\\\\ 0.112\\times 8={\\color{red}0}.912\\\\ 0.912\\times 8={\\color{red}7}.296\\\\ \\therefore (0.514)_{10}=(0.{\\color{red}407})_{8} 0.514×8=4.1120.112×8=0.9120.912×8=7.296∴(0.514)10​=(0.407)8​ 最后让我们加起来，得到了 (114.514)10=(162.407)8(114.514)_{10}=(162.407)_{8}(114.514)10​=(162.407)8​ 如果题目中需要更高的精度，那就继续乘以 8，直到小数部分为 0 常用数字的进制转换 十进制 二进制 八进制 十六进制 0 0000 0 0 1 0001 1 1 2 0010 2 2 … … … … 7 0111 17 7 8 1000 10 8 … … … … 15 1111 17 F 16 10000 20 10 … … … … 二进制编码 原码：用 最高位 作为符号位，0是正数，1是负数，符号位之后是这个十进制数的绝对值的二进制，存在 -0 的问题，所以不用 反码：正数和原码相同；负数符号位不变，剩余的 在原码基础上按位取反 补码：正数和原码相同；负数就是反码+1（忽略符号位进位） GCD 和 LCM GCD：Greatest Common Divisor，最大公约数 LCM：Least Common Multiple，最小公倍数 GCD 和 LCM 之间的关系： GCD(a,b)×LCM(a,b)=a×bGCD(a,b)\\times LCM(a,b)=a\\times b GCD(a,b)×LCM(a,b)=a×b 在 C++14 标准之后（OI 可用），你可以通过 algorithm 库中的 std::__gcd(int,int) 和 std::__lcm(int,int) 来计算 GCD 和 LCM 在 CSP 一轮考场上，可以直接带入选项中的数值去尝试 （重难点）排列与组合 排列 概念：集合 SSS 由 nnn个不同的元素组成，取出其中的 rrr 个，与顺序有关 的情况数为 AnrA_n^rAnr​，计算公式为： Anr=n!(n−r)!A_n^r=\\frac{n!}{(n-r)!} Anr​=(n−r)!n!​ 例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同也算另一种） 那么一共有 A52=5!(5−2)!=5×4×3×2×13×2×1=1206=20A_5^2=\\frac{5!}{(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{3\\times2\\times1}=\\frac{120}{6}=20 A52​=(5−2)!5!​=3×2×15×4×3×2×1​=6120​=20 种方案 当 n=rn=rn=r 时，Anr=Ann=n!A_n^r=A_n^n=n!Anr​=Ann​=n! 组合 概念：集合 SSS 由 nnn个不同的元素组成，取出其中的 rrr 个，与顺序无关 的情况数为 CnrC_n^rCnr​，计算公式为： Cnr=Anrr!=n!(n−r)!r!=n!r!(n−r)!C_n^r=\\frac{A_n^r}{r!}=\\frac{\\frac{n!}{(n-r)!}}{r!}=\\frac{n!}{r!(n-r)!} Cnr​=r!Anr​​=r!(n−r)!n!​​=r!(n−r)!n!​ 例如从 5 个元素中选出 2 个，求有多少种方案（数字相同但顺序不同只算做同一种） 那么一共有 C52=5!2!(5−2)!=5×4×3×2×12×1×3×2×1=1202×6=10C_5^2=\\frac{5!}{2!(5-2)!}=\\frac{5\\times4\\times3\\times2\\times1}{2\\times1\\times3\\times2\\times1}=\\frac{120}{2\\times6}=10 C52​=2!(5−2)!5!​=2×1×3×2×15×4×3×2×1​=2×6120​=10 种方案 当 n=rn=rn=r 时，Cnr=Cnn=1C_n^r=C_n^n=1Cnr​=Cnn​=1 排列与组合的联系 Anr=Cnr×ArrCnr=Cnn−rCn+1r=Cnr+Cnr−1A_n^r=C_n^r\\times A_r^r\\\\ C_n^r=C_n^{n-r}\\\\ C_{n+1}^r=C_n^r+C_n^{r-1} Anr​=Cnr​×Arr​Cnr​=Cnn−r​Cn+1r​=Cnr​+Cnr−1​ 有重复的排列 给出具有 nnn 个对象的集合 SSS，选出 rrr 个，可以重复选择 从第 1 个位置到第 rrr 个位置，每个位置有 nnn 种选择，那么一共有 nrn^rnr 种方案 有重复的组合（插板法） 给出具有 nnn 个对象的集合 SSS，选出 rrr 个，可以重复选择，与顺序无关 最终方案数是 Cn+r−1rC_{n+r-1}^rCn+r−1r​ （重难点）小球与盒子 你有 nnn 个小球，要放到 mmm 个盒子里，每个盒子可以放多个小球， 可辩别的小球与可辩别的盒子 最终方案数是 Cn+m−1nC_{n+m-1}^nCn+m−1n​ 不可辩别的小球与可辩别的盒子 盒子可以是空的：Cn+m−1m−1C_{n+m-1}^{m-1}Cn+m−1m−1​ 盒子不能是空的：Cn−1m−1C_{n-1}^{m-1}Cn−1m−1​ 剩下两种严重超纲，不记（涉及到第二类斯特林数和很多的分类讨论） （易考）树的遍历 给出前序遍历和中序遍历，可以唯一确定一棵二叉树 给出后序遍历和中序遍历，可以唯一确定一棵二叉树 步骤 前序遍历的第一个元素是根节点，后序遍历的最后一个元素是根节点 在中序遍历中找到根节点，它的左边是左子树，右边是右子树 递归构建左子树和右子树 示例 前序：ABDECFG 中序：DBEAFCG 首先确定 A 为根节点 在中序遍历中找到 A，它的左边 DBE 是左子树，右边 FCG 是右子树 在前序 BDE 和 CFG 中得到后序遍历 DBE 和 CFG 接上根节点 A，得到后序遍历 DBECFGA 也可以去 2019 CSP-J1 T14 练习 （易考）单位换算 M = 1e6，K = 1e3 1B(yte) = 8bit 二进制存储空间换算 1TiB = 2e10GiB = 2e20MiB = 2e30KiB = 2e40B = 2e43bit 1TiB=210GiB=220MiB=230KiB=240B=243bit1 TiB = 2^{10} GiB = 2^{20} MiB = 2^{30} KiB = 2^{40} B = 2^{43} bit1TiB=210GiB=220MiB=230KiB=240B=243bit 十进制存储空间换算 1TB = 1e3GB = 1e6MB = 1e9KB = 1e12B = 8*1e12bit 1TB=103GB=106MB=109KB=1012B=8×1012bit1 TB = 10^3 GB = 10^6 MB = 10^9 KB = 10^{12} B = 8\\times10^{12} bit1TB=103GB=106MB=109KB=1012B=8×1012bit 文件存储空间 图片存储空间：分辨率×位深度(bit)分辨率\\times 位深度(bit)分辨率×位深度(bit) 视频存储空间：单张图大小×fps×时长(bit)单张图大小\\times fps\\times 时长(bit)单张图大小×fps×时长(bit) (视频bps+音频bps)×时长(视频 bps+音频 bps)\\times 时长(视频bps+音频bps)×时长（单位根据码率单位而定） 帧率缩写 fps，码率 bps NOI 历史 第一届 NOI：1984，今年（NOI2025）第 41 届 第一届 IOI：1989 我国 2000 举办第 12 届 IOI 第一届 NOIP：1995，2019 暂停一届 第一届 CSP：2019 网络 OSI 七层模型 物理层：光纤、中继器 数据链链路层：网卡、交换机、以太网 网络层：IP、ICMP 传输层：TCP、UDP 会话层：SSL、TLS 表示层：LPP 应用层：HTTP、FTP、SMTP、POP3 协议 HTTP：超文本传输协议 FTP：文件传输协议 SMTP：收发电子邮件 POP3：接收电子邮件 TCP：三次握手(A-B 质询在线，B-A 返回在线，A-B 返回确认收到) IP 地址 IPv4：x.x.x.x（0=x=255）32bit 4B A类地址：1.0.0.1 ~ 127.255.255.254 B类地址：128.0.0.1 ~ 191.255.255.254 C类地址：192.0.0.1 ~ 223.255.255.254 IPv6：X:X:X:X:X:X:X:X（0000=X=FFFF）64bit 8B 排序 算法信息 n=等待排序的个数，w=数据值域 算法名称 平均时间 最坏时间 是否稳定 冒泡排序 O(n2)O(n^2)O(n2) O(n2)O(n^2)O(n2) true 选择排序 O(n2)O(n^2)O(n2) O(n2)O(n^2)O(n2) false 插入排序 O(n2)O(n^2)O(n2) O(n2)O(n^2)O(n2) true 计数排序 O(n+w)O(n+w)O(n+w) O(n+w)O(n+w)O(n+w) true 归并排序 θ(nlogn)\\theta(n log n)θ(nlogn) θ(nlogn)\\theta(n log n)θ(nlogn) true 快速排序 O(nlogn)O(n log n)O(nlogn) O(n2)O(n^2)O(n2) false 快速排序原理 使用递归原理 在 a[l]~a[r] 中选择一个基准 x 使用双指针将所有 a[i] x 交换到 x 左侧，a[i] x 交换到 x 右侧 快速排序通过双指针交换后，将一个大的排序问题划分为了两个子区间排序的小问题 所以期望复杂度 O(nlogn)O(n log n)O(nlogn) 如果选择第一个数作为基准，序列有序，每次序列长度只减少 1 所以最坏复杂度 O(n2)O(n^2)O(n2) std::sort 由 algorithm 头文件提供，属于 STL 在数据范围较小的情况下，使用了堆排序等技术 数据结构 链表 优点：插入删除 O(1)O(1)O(1) 缺点：读取 O(n)O(n)O(n) n=链表元素个数 示例： [prev = NULL, id = 1, value = 114, next = 514] [prev = 1, id = 514, value = 1919, next = 1919] [prev = 514, id = 1919, value = 810, next = NULL] 图的存储 邻接矩阵 优点：查询边权 O(1)O(1)O(1) 缺点：对于稀疏图，浪费空间 邻接表 优点：空间复杂度 O(∣E∣)O(|E|)O(∣E∣) 缺点：查询边权 O(∣V∣)O(|V|)O(∣V∣) 树 有 nnn 个节点 n−1n-1n−1 条边的无向连通图 完整二叉树：每个节点的子节点数量都是 0 或 2 运算优先级 自增/自减 执行顺序 ++x 先增加 x 的值，然后送出使用 x++ 先送出使用，然后增加 x 的值 ans+=++x; = x=x+1;ans=ans+x;ans+=x++; = ans=ans+x;x=x+1; x++ + ++x 这属于 未定义行为（Undefined Behavior, UB），在不同的编译器上可以解释为任何值。 这可能导致本地通过，评测报错 可以通过 -Wall 参数找到所有的警告 计算原理 容斥原理/减法法则 如果一个任务可以通过 n1n_1n1​ 种方法执行，还可以通过 n2n_2n2​ 种另一类方法执行，那么执行这个任务的方法数量是 n1+n2−[两种方法中相同的方法]n_1+n_2-[两种方法中相同的方法]n1​+n2​−[两种方法中相同的方法] 也就是说，集合 A1,A2A_1,A_2A1​,A2​，与并集 A1∪A2A_1\\cup A_2A1​∪A2​，满足 ∣A1∪A2∣=∣A1∣+∣A2∣−∣A1∩A2∣|A_1\\cup A_2|=|A_1|+|A_2|-|A_1\\cap A_2|∣A1​∪A2​∣=∣A1​∣+∣A2​∣−∣A1​∩A2​∣ 鸽巢原理 如果 k+1k+1k+1 个或更多的物体放入 kkk 个盒子，那么至少有一个盒子包含了 2 个或更多的物体 广义鸽巢原理 如果 nnn 个物体放入 kkk 个盒子，那么至少有一个盒子至少包含了 ⌈nk⌉\\lceil \\frac{n}{k}\\rceil⌈kn​⌉ 个物体 高级语言分类 面向过程：以函数为基本程序结构：C，Pascal，Fortran 面向对象：以类为基本程序结构：C++，Java，Python 编译性：执行前用连接器生成可执行文件：C++ 解释性：一边用解释器翻译，一边运行代码：Python，JS，Ruby Java：编译 + 解释混合 计算机历史 第一台计算机 - ENIAC 有存储功能 - EDVAC 冯诺依曼 - 存储结构 图灵 - 测试 阿达罗福莱斯 - 计算机程序的创始人 马文·明斯基、约翰·麦卡西 - 对 AI 杰出贡献 香农 - 信息论","tags":["OI","CSP-J"],"categories":["学习","努力","备考"]},{"title":"图的存储 - 链式前向星","path":"/2025/07/15/链式前向星/","content":"其实本质上就是用链表实现的邻接表 基本信息 链式前向星是图论中一种 牛逼 高效的存储结构 时间复杂度： 添加边：O(1)O(1)O(1) 和邻接矩阵的复杂度一样，但是我们要在 head 数组的末尾添加新边，并更新头指针 遍历节点的出边：O(k)O(k)O(k) 其中：kkk 为这个节点的出边数量。直接通过头指针开始遍历链表即可 断边：最坏情况 O(m)O(m)O(m) 需要遍历 edges 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星 删除节点：O(n)O(n)O(n) 需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里） 空间复杂度：O(n+m)O(n+m)O(n+m)，其中：nnn 为节点数，mmm 为边数 添加与遍历 #includebits/stdc++.h#define int long longusing namespace std;const int NODE_LEN=1e5+5;const int EDGE_LEN=2e5+5;//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边//定义边，存储指向的目标节点和下一条边的索引，以及边权struct Edge int to,nxt,weight;edges[EDGE_LEN];//图中的所有边int head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标int cnt_edge=0;//边的数量void add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w edges[cnt_edge].to=v; //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v edges[cnt_edge].nxt=head[u]; head[u]=cnt_edge; //下一条边 edges[cnt_edge].weight=w;//由出发节点伸出的边的权值 cnt_edge++;//存完一个啦！提前准备好下一个！ cout添加边：( u - v ) 成功！且权值为 wendl; return;void traverse_nodes(int u)//遍历出发节点 u 的所有目标节点 cout节点 u 的所有出边信息：endl; for(int i=head[u];i!=-1;i=edges[i].nxt) cout( u - edges[i].to )，权值为 edges[i].weightendl; /* 初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引 循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！ 处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居 循环终止操作：找下一条边 */ return;signed main() memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接 //由于下面就是示例了，所以就用局部变量了 int n;//共计 n 个节点 cinn; for(int i=1;i=n;i++)//读入节点 int u,v,w;//出发节点和目标节点 cinuvw; add_edge(u,v,w); //add_edge(v,u,w); //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！ for(int i=1;i=n;i++) traverse_nodes(i);//遍历节点 i exit(0); 提示：学到这里已经足够应对大部分算法了，链式前向星 非常不适合删除操作 断边 下面介绍如何在链式前向星数据结构上增加删除边的功能。 需要注意的是，链式前向星本质上是一种一边 只增不减 的“静态”存储方式 删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。 下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。 注意：如果你的图中 经常需要删除边 ，链式前向星可能不是最适合的选择；2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。 1. 增加删除边所需要的代码 假设我们在前面的加权图结构基础上（包括 to、weight 和 nxt 字段）进行扩展。我们给出一个 delete_edge 函数，函数参数为起点 u 和目标 v ，表示删除一条从 u 到 v 的边（如果存在多条，则只删除第一个碰到的）。 我们来逐步说明删除边的思路，再给出代码： 找到目标边所在的链表位置 对于某个起点 u ，其边链表保存在从 head[u] 开始的一条单链表中。我们用两个变量： cur 用于遍历链表，初始设为 head[u] 。 pre 记录前驱节点的索引，初始为 -1（表示当前边是链表的第一个）。 遍历链表，搜索符合条件的边 从 cur 开始，遍历链表：如果发现 edges[cur].to==v（满足目标条件），则说明找到了要删除的边。 更新指针实现删除 如果 pre 为 -1，说明要删除的边正好位于链表头部，此时更新 head[u]=edges[cur].nxt； 否则，将前驱边的 nxt 指针更新为 edges[cur].nxt，这样跳过了当前边。 结束遍历 找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。 下面是完整的删除边函数代码： // 删除从 u 指向 v 的边（仅删除第一次匹配的边）void delete_edge(int u,int v) int cur=head[u]; int pre=-1; while(cur!=-1) if(edges[cur].to==v)//找到目标边 if (pre==-1) head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u] else edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须） edges[cur].nxt=-1; cout删除边 (u - v) 成功。endl; return; pre=cur; cur=edges[cur].nxt; cout边 (u - v) 不存在，删除失败。endl; return; 2. 遍历节点，验证删除功能 为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。 （其实这已经在 添加与遍历 演示了） // 遍历并输出结点 u 的所有出边（包括边的终点和权值）void traverse_nodes(int u)//遍历出发节点 u 的所有目标节点 cout节点 u 的所有出边信息：endl; for(int i=head[u];i!=-1;i=edges[i].nxt) cout( u - edges[i].to )，权值为 edges[i].weightendl; /* 初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引 循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！ 处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居 循环终止操作：找下一条边 */ return; 3. 示例 下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出： /*省略，真的太长了...可以翻到上面看看 添加与遍历*/// 删除从 u 指向 v 的边（仅删除第一次匹配的边）void delete_edge(int u,int v) int cur=head[u]; int pre=-1; while(cur!=-1) if(edges[cur].to==v)//找到目标边 if (pre==-1) head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u] else edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须） edges[cur].nxt=-1; cout删除边 (u - v) 成功。endl; return; pre=cur; cur=edges[cur].nxt; cout边 (u - v) 不存在，删除失败。endl; return;signed main() memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接 //这是张 **无向图** add_edge(1,2,5);add_edge(2,1,5); add_edge(1,3,10);add_edge(3,1,10); add_edge(1,4,3);add_edge(4,1,3); add_edge(2,3,7);add_edge(3,2,7); cout建边后的图endl; for(int i=1;i=4;i++) traverse_nodes(i); delete_edge(1,3); cout现在的图endl; for(int i=1;i=4;i++) traverse_nodes(i); exit(0); 示例中的初始图长这样： 程序执行过程说明 添加边阶段： 对于结点 1，经过多次调用 add_edge(1, ...)，其边链表可能为（头插法的结果是最新添加的边在链表头）： 头部指向边：1 - 4 通过 nxt 链到边：1 - 3 再通过 nxt 链到边：1 - 2 结点 2 拥有边：2 - 3。 删除操作： 调用 delete_edge(1,3) 后，会遍历结点 1 的边链。 当遍历到边记录 edges[i].to==3 时，将其从链表中“删除”： 如果该边不是头部，就把前一个边的 nxt 指向当前边的 nxt。 此后，遍历结点 1 时，1 - 3 就不会再被输出。 遍历验证： 调用 traverse_node 验证删除后，结点 1 的链表中只剩下 1 - 4 和 1 - 2。 4. ASCII 图示辅助理解删除操作 假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）： head[1] -- [index 2: (1 - 4), nxt = index 1] [index 1: (1 - 3), nxt = index 0] [index 0: (1 - 2), nxt = -1] 删除 1-3 的过程： 遍历时，cur 先指向 index 2 (边 1-4)，不匹配； 然后 cur 指向 index 1 (边 1-3)，匹配目标。此时 pre 指向 index 2。 更新 edges[pre].nxt，即 edges[2].nxt = edges[1].nxt（即 index 0）。 结果链表变为： head[1] -- [index 2: (1 - 4), nxt = index 0] [index 0: (1 - 2), nxt = -1] 删除后的遍历顺序即输出 1-4 和 1-2。 5. 小结 删除边的思路： 在链表中找到目标边的位置。 通过修改上一节点的 nxt 指针或更新 head[u]，跳过目标边，令其不参与后续遍历。 局限性： 这种删除操作只更新了指针，并没有真正回收数组中的空间。 如果后续还需要添加边，可以继续使用 add_edge，但是删除的空间不会被重用（除非重新构造数据结构）。 扩展思考： 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。 通过以上代码和说明，你可以在链式前向星上实现边的删除功能。 删除节点 下面讨论如何在链式前向星中实现“删除节点”的功能。 需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分： 删除该节点的所有出边（从该节点出发的边）， 这部分比较简单； 删除其他节点中所有指向该节点的入边， 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。 因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法： 方法 1：物理删除（实际修改链表结构） 在物理删除时，我们需要同时删除： 节点 u 的出边（即把 head[u] 置为 -1 或清空整个链表）， 其他所有节点链表中指向 u 的边。 这种方法的基本思路如下： 删除 u 的出边 直接将 head[u] 设为 -1，相当于断开了 u 对外的所有边。 删除所有指向 u 的入边 遍历图中所有其他节点 v 的边链表，在每个链表中查找边： if (edges[cur].to == u) 找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 nxt 指针或更新 head[v]）。 由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）： // 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边void delete_node(int u,int n)//n 表示图中总的节点数 // 1. 删除 u 的所有出边：直接断开该链表 head[u]=-1; // 2. 删除其他节点中指向 u 的入边 for(int v=1;v=n;v++) if(v==u) continue;//已经处理了 u 的出边 int cur=head[v]; int pre=-1; while(cur!=-1) if(edges[cur].to==u)//找到边 v-u，需要删除 if(pre==-1) //被删除的边在链表头，更新 head[v] head[v]=edges[cur].nxt; //更新 cur 为新的头节点 cur=head[v]; else // 跳过当前边 edges[pre].nxt=edges[cur].nxt; cur=edges[cur].nxt; // 注意：如果存在多条边指向 u，此处可以继续遍历删除 else pre=cur; cur=edges[cur].nxt; cout节点 u 删除完成 (出边和入边均已移除）。endl; return; 注意事项 这种物理删除不会真正回收 edges[] 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。 方法 2：懒删除（逻辑删除） 在很多实际场景下，动态删除节点（或边）时，我们可以采用 懒删除 的策略，而不是立即修改链表结构。方法是： 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 nodeExist[N]。 当需要删除节点 u 时，只需将 nodeExist[u] 标记为 false 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。 这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。 示例代码（仅思路）： bool nodeExist[N];// 初始化时，将所有节点设为存在void init(int n) for(int i=1;i=n;i++) nodeExist[i]=true; return;// 懒删除节点 u，标记为不存在void lazy_delete_node(int u) nodeExist[u]=false; cout节点 u 已被标记为删除。endl; return;// 在遍历时，检查目标节点是否存在void process_edges(int u) if(!nodeExist[u]) return;//该节点已经被删除，则不处理 for(int i=head[u];i!=-1;i=edges[i].nxt) int v=edges[i].to; if(!nodeExist[v]) continue;//如果终点已删除，则跳过该边 // 此处对边 (u - v) 做处理 return; 小结 物理删除节点： 将该节点的所有出边置为空（如 head[u]=-1）， 遍历其他所有节点的边链表，删除所有指向该节点的入边。 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。 懒删除（逻辑删除）： 通过维护一个节点存在标志，在删除节点时仅做标记。 在遍历和处理时跳过被删除的节点及其相关边。 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。 根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","tags":["算法","图论","存储"],"categories":["学习","分享"]},{"title":"快读快写模板","path":"/2025/07/12/快读快写模板/","content":"本文整理了在 OI 中可以提升读写速度的模板，持续更新中… 整型快读快写模板 #includebits/stdc++.h#define int long longusing namespace std;inline void read(int a) int s=0,w=1; char ch=getchar(); while(ch0||ch9) if(ch==-) w=-1; ch=getchar(); while(ch=0ch=9) s=s*10+ch-0; ch=getchar(); a=s*w; return;inline void write(int x) static int sta[10]; int top=0; do sta[top++]=x%10; x/=10; while(x); while(top) putchar(sta[--top]+0); //putchar( ); //可选的行末空格 //putchar( ); //可选的行末换行 return;signed main() int a,b; read(a); read(b); write(a+b); return 0;","tags":["OI","模板"],"categories":["学习","分享"]},{"title":"搜索题目整理","path":"/2025/07/12/搜索题目整理/","content":"本文整理了 ED_Builder 在初学搜索算法时做的题目 DFS P1219 八皇后 #includebits/stdc++.husing namespace std;int n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案bool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问void print()//输出答案 if(ans3) return;//由题可得,只需要输出 3 种排列 for(int i=1;i=n;i++) couta[i] ; coutendl; return;void dfs(int x)//形参 x :当前是第 x 个皇后 if(xn)//一种可行的方案达成 ans++;//方案数++ print();//输出答案 return; for(int i=1;i=n;i++)//枚举所有答案 if(!vis_lie[i]!vis_l[x-i+n]!vis_r[x+i])//是否被访问过(规律见 L40 ) vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记 a[x]=i;//存答案 dfs(x+1);//继续递归 vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯 int main() cinn; dfs(1); coutans; return 0;/*对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等*/ P1706 全排列问题 P1 - DFS #includebits/stdc++.husing namespace std;int n,a[20];//枚举 n 个数字,可行的答案存放在 a 中bool vis[20];//已经被访问过的void print()//输出答案 for(int i=1;i=n;i++) coutsetw(5)a[i]; coutendl; return;void dfs(int x) if(xn)//已经有了一个方案 print(); return; for(int i=1;i=n;i++) if(!vis[i])//没被访问 a[x]=i;//记录答案 vis[i]=true;//标记 dfs(x+1);//继续递归 vis[i]=false;//回溯 int main() cinn; dfs(1);//从 1 开始 return 0; P2 - 枚举优化 #includebits/stdc++.husing namespace std;int main() int n; cinn; int num[n]; for(int i=1;i=n;i++) num[i]=i; do for(int i=1;i=n;i++) coutsetw(5)num[i]; coutendl; while(next_permutation(num+1,num+1+n)); return 0; P1605 迷宫 #includeiostream#includecstring//这里不用万能头是因为想用 map 当变量名using namespace std;int n,m,t,sx,sy,fx,fy,ans;//地图长宽,障碍数量,起点坐标,终点坐标,答案int dx[5]=1,0,-1,0,dy[5]=0,-1,0,1;//位移bool map[10][10];//地图void dfs(int x,int y) if(x==fxy==fy)//到达终点 ans++; return; for(int i=0;i4;i++)//枚举位移 int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动 if(tmp_x=1tmp_x=ntmp_y=1tmp_y=mmap[tmp_x][tmp_y]) //合法判断:坐标未越界,位置可用(没有障碍且没被访问) map[tmp_x][tmp_y]=false;//标记访问 dfs(tmp_x,tmp_y);//继续递归 map[tmp_x][tmp_y]=true;//回溯 int main() memset(map,true,sizeof(map));//初始化 cinnmtsxsyfxfy; for(int i=1;i=t;i++)//读入障碍 int x,y; cinxy; map[x][y]=false;//不能走 map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问! dfs(sx,sy); coutans; return 0; P1036 选数 #includebits/stdc++.husing namespace std;int n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案bool vis[25];//是否已经被选择bool check_prime(int n)//判断质数 if(n=1) return false; for(int i=2;i=sqrt(n);i++) if(n%i==0) return false; return true;void dfs(int pos,int cnt,int sum) if(cnt=k)//选完了 if(check_prime(sum)) ans++;//判断质数,然后答案自增 return; for(int i=pos;i=n;i++) if(vis[i])//没被选 vis[i]=false;//标记 dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数 vis[i]=true;//回溯 int main() memset(vis,true,sizeof(vis));//初始化 cinnk; for(int i=1;i=n;i++) cinx[i]; dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0 coutans; return 0; P1238 走迷宫 #includebits/stdc++.h#define int long longusing namespace std;int m,n;// m 行 n 列 int mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 int begin_x,begin_y,end_x,end_y;//起点和终点 int dx[5]=0,-1,0,1,dy[5]=-1,0,1,0;//偏移int ans[100000][3],k;//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 void print()//输出一种答案 if(have_solution==false) have_solution=true;//更新为有解 for(int i=0;ik;i++) cout(ans[i][1],ans[i][2])-; cout(end_x,end_y)endl; //因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 void dfs(int x,int y) if(x==end_xy==end_y)//到达终点 print();//输出答案 return; for(int i=0;i4;i++)//枚举偏移 int nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 if(mp[nxt_x][nxt_y]==1vis[nxt_x][nxt_y]==0) //下一步可以走并且没被访问 vis[x][y]=1;//标记上一步被访问 ans[k][1]=x,ans[k][2]=y;//记录可行的一步 k++;//增加指针 dfs(nxt_x,nxt_y);//继续找下一步 vis[x][y]=0;//回溯,设为未访问 k--;//倒回去 signed main() cinmn; for(int i=1;i=m;i++) for(int j=1;j=n;j++) cinmp[i][j];//读入地图 cinbegin_xbegin_yend_xend_y;//读入起点和终点 dfs(begin_x,begin_y); if(!have_solution) cout-1;//没有解 return 0;//结束 :) BFS 注意: BFS 不能用于加权图,因为 BFS 只会查找边数最少的路径 例如 100 - 100 和 1 - 1 - 1 - 1 BFS 会选择 100 - 100 当数据范围较小（ ≤20\\le20≤20 ）时，用 DFS 也不是不可以 P1746 离开中山路 #includeiostream#includequeueusing namespace std;struct Point//单个点的坐标 int x,y;;int n;char map[1005][1005];int dis[1005][1005];//到起点的距离int dx[]=1,0,-1,0;int dy[]=0,1,0,-1;//位移int start_x,start_y,final_x,final_y;//由题可得,起点和终点queuePoint q;//等待处理的点void bfs(int x,int y) q.push((Point)x,y);//压入当前点 dis[x][y]=0;//起点 while(!q.empty())//只要队列非空 Point t=q.front();//读取当前队头 q.pop();//弹出 for(int i=0;i4;i++)//枚举位移 int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点 if(nxt_x1||nxt_xn||nxt_y1||nxt_yn||map[nxt_x][nxt_y]==1||dis[nxt_x][nxt_y]0) continue; //判断:越界+有障碍+被访问 q.push((Point)nxt_x,nxt_y);//压入下一个点 dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离 return;int main() cinn; for(int i=1;i=n;i++) for(int j=1;j=n;j++) cinmap[i][j]; cinstart_xstart_yfinal_xfinal_y; bfs(start_x,start_y); coutdis[final_x][final_y]; return 0; P1443 马的遍历 #includebits/stdc++.husing namespace std;struct Point//当前马位于的坐标 int x,y;;int n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步int dx[]=2,1,-2,1,-1,2,-2,-1;int dy[]=1,2,1,-2,2,-1,-1,-2;//位移queuePoint q;//当前需要处理的点void bfs(int x,int y) q.push((Point)x,y);//入队处理起点 dis[x][y]=0;//起点已经有一个马了 while(!q.empty()) Point t=q.front();//取队头处理 q.pop();//弹出 for(int i=0;i8;i++)//枚举位移 int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标 if(nxt_x1||nxt_xn||nxt_y1||nxt_ym||dis[nxt_x][nxt_y]!=-1) continue; //检查:越界+被访问 dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1 q.push((Point)nxt_x,nxt_y);//继续压入新的点继续处理 return;int main() memset(dis,-1,sizeof(dis));//初始化 cinnmxy; bfs(x,y); for(int i=1;i=n;i++) for(int j=1;j=m;j++) coutsetw(5)dis[i][j]; coutendl; return 0; P2895 Meteor Shower S 耗时 2 个月的巅峰对决，但最终还是我赢了！ #includebits/stdc++.h#define int long longusing namespace std;const int LEN=305;struct Point//存储坐标的点 int x,y;;int m;int mp[LEN][LEN],dis[LEN][LEN];//地图,距离 int dx[]=-1,0,1,0,dy[]=0,1,0,-1;//偏移 queuePoint q;int bfs() q.push((Point)0,0);//第一个位置是 (0,0) dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 while(!q.empty()) Point now=q.front();//找到当前点 q.pop(); for(int d=0;d4;d++)//枚举偏移 int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置 if(nxt_x0||nxt_y0) continue;//越界 if(dis[nxt_x][nxt_y]) continue;//被访问 if(dis[now.x][now.y]+1=mp[nxt_x][nxt_y]) continue; //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较 dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 q.push((Point)nxt_x,nxt_y);//压入下一个点 if(mp[nxt_x][nxt_y]1e9) return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 return -1;signed main() memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 cinm; while(m--) int x,y,time;//坐标,流星砸下来的时间 cinxytime; mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 for(int d=0;d4;d++)//枚举偏移 int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 if(nxt_x0||nxt_x301||nxt_y0||nxt_y301) continue;//越界 mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 coutbfs(); exit(0);","tags":["搜索","算法"],"categories":["学习","分享"]},{"title":"图论 - 最小生成树","path":"/2025/07/10/最小生成树/","content":"本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal Prim（加点法） 基本信息 每次迭代选择边权最小的边对应的点，加入到最小生成树中。 算法从某个顶点 startstartstart 开始，逐渐延伸覆盖整个连通网的所有顶点 时间复杂度：O(n2)O(n^2)O(n2) 算法思想 蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。 每次循环都将一个蓝点 uuu 变为白点，并且这个蓝点 uuu 与白点相连的最小边权 min(weight[u]) 还是当前所有蓝点中最小的。 这样相当于向生成树中添加了 n−1n-1n−1 次最小的边，最后得到的一定是最小生成树 算法描述 以 111 为起点生成最小生成树，min[v] 表示蓝点 v 与白点相连的最小边权，mst 表示最小生成树的权值之和 初始化：min[v]=INF(v≠1)(v e 1)(v=1) min[1]=0 mst=0 for(int i=1;i=n;i++) 1. 寻找 min[u] 最小的蓝点 u 2. 将 u 标记为白点 3. mst+=min[u]; 4. for(与白点 u 相连的所有蓝点 v) if(weight[u][v]min[v]) min[v]=weight[u][v]; 算法结束，mst 即为最小生成树的权值之和 例题 - YBT 1349 #includebits/stdc++.husing namespace std;const int LEN=105,INF=0x3f;int graph[LEN][LEN];int minn[LEN];bool vis[LEN];int n,mst=0;void init() memset(minn,INF,sizeof(minn)); minn[1]=0; memset(vis,true,sizeof(vis));int main() cinn; init(); for(int i=1;i=n;i++) for(int j=1;j=n;j++) cingraph[i][j]; for(int i=1;i=n;i++) int k=0; for(int j=1;j=n;j++) if(vis[j](minn[j]minn[k])) k=j; vis[k]=false; for(int j=1;j=n;j++) if(vis[j](graph[k][j]minn[j])) minn[j]=graph[k][j]; for(int i=1;i=n;i++) mst+=minn[i]; coutmst; return 0; Kruskal 基本信息 Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。 Kruskal 算法将一个连通块当做一个集合。 时间复杂度为 O(E log(E))O(E\\ log(E))O(E log(E))，E为边数。 算法思想 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 nnn 个独立的集合。 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。 直到选取了 n−1n-1n−1 条边为止。 通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的 边，一张 nnn 个顶点的图总共选取 n−1n-1n−1 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 nnn 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 n−1n-1n−1 条边，连接着 nnn 个顶点的最小生成树。 算法描述 初始化并查集：fa[x]=x，初始化总权值和：mst=0 将所有边用快排 从小到大 排序 计数器 k=0 for(int i=1;i=m;i++) if(这是一条 u,v 不属于同一集合的边 u-v) 1. 合并 u,v 所在的集合，相当于把 u-v 加入最小生成树 2. mst+=weight[u][v] 3. k++; 4. if(k==n-1) break; 最小生成树已经生成，跳出循环 算法结束，mst 即为最小生成树的总权值之和 例题 - Luogu P3366 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=2e5+5;struct Edge int u,v,w;edge[LEN];int cnt;int fa[5005];int n,m,mst=0,edges_cnt=0;int find(int x) if(fa[x]!=x) fa[x]=find(fa[x]); return fa[x];void merge(int x,int y) int fx=find(x); int fy=find(y); if(fx!=fy) fa[fx]=fy; return;void addedge(int u,int v,int w) cnt+=1; edge[cnt].u=u; edge[cnt].v=v; edge[cnt].w=w; return;bool cmp(Edge a,Edge b)return a.wb.w;signed main() cinnm; for(int i=1;i=m;i++) int u,v,w; cinuvw; addedge(u,v,w); for(int i=1;i=n;i++) fa[i]=i; stable_sort(edge+1,edge+cnt+1,cmp); for(int i=1;i=cnt;i++) if(find(edge[i].u)!=find(edge[i].v)) merge(edge[i].u,edge[i].v); mst+=edge[i].w; edges_cnt++; if(edges_cnt==m) break; if(edges_cntn-1) coutorz; else coutmst; return 0;","tags":["算法","图论","最小生成树"],"categories":["学习","分享"]},{"title":"图论 - 最短路","path":"/2025/07/10/最短路/","content":"本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA Floyd 基本信息 定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 aaa 到顶点 bbb）之间的路程变短，只能引入第三个点（顶点 kkk），并通过这个顶点 kkk 中转，即 a-k-b，才可能缩短原来从顶点 aaa 到顶点 bbb 的路程。 原理：三重循环枚举中转点 k，状态转移方程：dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]) 时间复杂度：O(n3)O(n^3)O(n3) 算法步骤 由于在图中 没有负环 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。 例题 - Luogu B3647 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=105,INF=0x3f;int graph[LEN][LEN],n,m;signed main() cinnm; memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连 for(int i=1;i=n;i++) graph[i][i]=0;//自己到自己为 0 while(m--) int u,v,w; cinuvw; graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值 for(int k=1;k=n;k++) for(int i=1;i=n;i++) for(int j=1;j=n;j++) graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]); //暴力查找第三点 k，以及通过边权求最小值 for(int i=1;i=n;i++) for(int j=1;j=n;j++) if(graph[i][j]==INF) cout0 ;//没有边相连 else coutgraph[i][j] ; coutendl; return 0; 上面这玩意只有 80pts Dijkstra 基本信息 定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。 主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 所有的边权全部非负。 原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。 时间复杂度：O(n2)O(n^2)O(n2) 算法步骤 初始化 graph[v0]=0 ，出发点 到其他顶点的距离 graph[i]=INF 经过 nnn 次下面的操作，最后得到 v0v_0v0​ 到 nnn 个顶点的最短距离 1. 选择一个未被标记的、且 graph[k] 的值是最小的顶点 kkk 2. 标记顶点 kkk，即 vis[k]=true 3. 以 kkk 为中间点，修改出发点 v0v_0v0​ 到其他未被标记的顶点的 jjj 的距离值 graph[j] 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2 1. 在集合 2 中找一个到出发点距离最近的顶点 kkk： min{dis[k]}min\\{dis[k]\\}min{dis[k]} 2. 把顶点 kkk 加到集合 1 中，同时检查集合 2 中的剩余顶点 jjj 的 dis[j] 是否经过 kkk 后变短，如果变短修改 dis[j] if(dis[k]+wait[k][j]dis[j]) dis[j]=dis[k]+wait[k][j] 3. 重复步骤 3.1 ，直至集合 2 空为止 例题 - Luogu P3371（但是弱化版） #includebits/stdc++.h#define int long longusing namespace std;const int LEN=1e6+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[LEN];int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt;void init() for(int i=1;i=n;i++) ans[i]=INF; memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() cinmns; init(); ans[s]=0; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); int pos=s; while(vis[pos]==0) int minn=INF; vis[pos]=true; for(int i=head[pos];i!=0;i=edge[i].nxt) if(!vis[edge[i].to]ans[edge[i].to]ans[pos]+edge[i].weight) ans[edge[i].to]=ans[pos]+edge[i].weight; for(int i=1;i=m;i++) if(ans[i]minnvis[i]==0) minn=ans[i]; pos=i; for(int i=1;i=m;i++) coutans[i] ; return 0; 但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 dis[] 中的最小值，所以我们可以用…… 堆优化 堆是一种可以在 O(log(n))O(log(n))O(log(n)) 的时间插入数据，O(1)O(1)O(1) 的时间删除和查找当前极值（最大或最小值） 那么原来求最小值的 O(n)O(n)O(n) 的算法，可以改为使用堆来求最小值，时间复杂度降到 O(log(n))O(log(n))O(log(n)) ，整体复杂度降到 O(n log(n))O(n\\ log(n))O(n log(n)) 对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……） 对于 Dijkstra 的堆优化有两种方法: 重载运算符 两元组 例题 - Luogu P4779（但是标准版） 别想把 P3371 的代码交上去，全部 TLE Solution-1 重载运算符 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=1e6+5,INF=0x3f;struct Edge int to,nxt,weight;edge[LEN];struct Priority int ans,id; bool operator (const Priority x)constreturn x.ansans;;int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt; return;void init() memset(ans,INF,sizeof(ans)); memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() init(); cinmns; ans[s]=0; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); int u; priority_queuePriority q; q.push((Priority)0,s); while(!q.empty()) Priority tmp=q.top(); q.pop(); u=tmp.id; if(!vis[u]) vis[u]=true; for(int i=head[u];i;i=edge[i].nxt) int v=edge[i].to; if(ans[v]ans[u]+edge[i].weight) ans[v]=ans[u]+edge[i].weight; if(!vis[v]) q.push((Priority)ans[v],v); for(int i=1;i=m;i++) coutans[i] ; return 0; Solution-2 两元组 #includebits/stdc++.h#define pii pairint,int#define int long longusing namespace std;const int LEN=1e6+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[LEN];int head[LEN],cnt;int ans[LEN];bool vis[LEN];int m,n,s;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt;void init() for(int i=1;i=n;i++) ans[i]=INF; memset(vis,false,sizeof(vis)); memset(head,0,sizeof(head));signed main() cinmns; init(); priority_queuepii,vectorpii,greaterpii q; for(int i=1;i=n;i++) int u,v,w; cinuvw; addedge(u,v,w); ans[s]=0; q.push(pii0,s); int u; while(!q.empty()) pii x=q.top(); q.pop(); if(vis[x.second]) continue; u=x.second; vis[u]=true; for(int i=head[u];i;i=edge[i].nxt) if(ans[edge[i].to]ans[u]+edge[i].weight) ans[edge[i].to]=ans[u]+edge[i].weight; q.push(pii(ans[edge[i].to],edge[i].to)); for(int i=1;i=m;i++) coutans[i] ; return 0; SPFA SPFA 是 Bellman-Ford 的一种 队列优化，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算 基本信息 定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 队列优化，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算 SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。 时间复杂度：O(kE)O(kE)O(kE)，EEE 是边数，kkk 是常数，平均值是 222 算法步骤 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改 若某个相邻的顶点修改成功，则将其入队 队列为空时，算法结束 实现方法 建立一个队列，并且将出发点入列，用 dis[i] 记录出发点到其他所有点的最短路径 执行松弛操作，一次用队列里有的点 uuu 去更新所有后继节点 viv_ivi​ 的最短路，如果 viv_ivi​ 被更新成功且不在队列中，则把 viv_ivi​ 加入队列，重复执行直到队列为空 节点可能多次被更新，可以多次进入队列 if(dis[u]+wdis[v]) d[v]=d[u]+w; 如果 VVV 被更新了且队列中不存在，再一次进入队列 例题 - Luogu P3371 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=5e5+5,INF=pow(2,31)-1;struct Edge int to,nxt,weight;edge[2*LEN];int cnt=0,head[LEN],dis[LEN];bool vis[LEN];int n,m,start;void addedge(int u,int v,int w) cnt++; edge[cnt].to=v; edge[cnt].weight=w; edge[cnt].nxt=head[u]; head[u]=cnt; return;void SPFA() queueint q; dis[start]=0; q.push(start); vis[start]=true; while(!q.empty()) int now=q.front(); q.pop(); vis[now]=false; for(int i=head[now];i;i=edge[i].nxt) int to=edge[i].to; if(edge[i].weight+dis[now]=dis[to]) dis[to]=edge[i].weight+dis[now]; if(!vis[to]) q.push(to); vis[to]=true; return;void init() for(int i=1;i=n;i++) dis[i]=INF; memset(head,0,sizeof(head)); return;signed main() cinnmstart; init(); for(int i=1;i=m;i++) int u,v,w; cinuvw; addedge(u,v,w); SPFA(); for(int i=1;i=n;i++) coutdis[i] ; return 0; 有些考试会用数据卡掉 SPFA 导致 TLE，比如 Luogu P4779 会导致 SPFA 算法在 #1,2,3,5,6 TLE SPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别 总结 Floyd 最简单，多源最短路大暴力，O(n3)O(n^3)O(n3) 复杂度卡死你 Dijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 O(n log(n))O(n\\ log(n))O(n log(n)) SPFA 易理解，和 BFS 很类似，某些题目 会卡掉，慎重选择需技巧 被迫回去看链式前向星的笔记了 :(","tags":["算法","图论","最短路"],"categories":["学习","分享"]},{"title":"关于我","path":"/about/index.html","content":"我写的不好，大部分都是直接搬运 Luogu 主页 的。 关于我 一个 ISTJ-T 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02） 一个尽力学习的 OIer 一个用私人服务器的 Arcaea 玩家（PTT = 11.08） 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D） 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57） 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了） 我的参与 现任 量子诗笺 技术站长 生物死刑网站 主要开发者 欢迎来使用 ED-ImgHub 和 ED-Comment"},{"path":"/friends/index.html","content":"量子诗笺"},{"title":"Summer Camping Study Note","path":"/notebooks/scsn/index.html","content":"这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。"},{"title":"单调栈和单调队列","path":"/notebooks/scsn/单调栈和单调队列.html","content":"算法分析 数据结构 时间复杂度 空间复杂度 典型用途 单调栈 O(n)O(n)O(n) O(n)O(n)O(n) 找下一个更大 / 更小元素 单调队列 O(n)O(n)O(n) O(n)O(n)O(n) 滑动窗口最大 / 最小值 单调栈 单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。 单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。 思路 使用一个栈 sta，栈中存储的是“候选元素”的下标（下同）。 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。 遍历数组 A： 当 A[i] 大于栈顶元素 A[sta.top()] 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。 重复上述步骤直到栈空或 A[i] = A[sta.top()]。 将当前下标 i 入栈。 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。 代码示例 例题：Luogu P5788 - 【模板】单调栈 #includebits/stdc++.husing namespace std;const int LEN=3e6+5;int a[LEN],f[LEN];int n;int main() cinn; for(int i=1;i=n;i++) cina[i]; stackint sta;//存储下标 for(int i=1;i=n;i++) //找到一个更大的元素下标 while(!sta.empty()a[i]a[sta.top()]) f[sta.top()]=i; sta.pop();//维护单调性 sta.push(i); for(int i=1;i=n;i++) coutf[i] ; return 0; 单调队列 单调队列通常用来维护滑动窗口中的最大值或最小值，以 O(1) 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。 思路 使用 dequeint dq，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。 遍历数组 A，下标为 i： 如果队头 dq.front() 已经滑出窗口范围（i - dq.front() = k），则 dq.pop_front()。 将当前元素与队尾元素比较，若 A[i] 大于等于 A[dq.back()]，弹出队尾，直到队尾大于当前元素。 将 i 推入队尾。 当窗口形成（i = k-1）时，队头即为窗口最大值下标，记录 A[dq.front()]。 代码示例 例题：Luogu P1886 - 滑动窗口 /【模板】单调队列 #includebits/stdc++.husing namespace std;const int LEN=1e6+5;int a[LEN],n,k;//单调递增队列求最小值void getMin() dequeint dq; for(int i=1;i=n;i++) //队头元素是否滑出窗口 if(!dq.empty()dq.front()=i-k) dq.pop_front(); //维护递增性：弹出比当前值大的队尾元素 while(!dq.empty()a[dq.back()]a[i]) dq.pop_back(); dq.push_back(i); //输出窗口最小值 if(i=k) couta[dq.front()] ; //单调递减队列求最大值void getMax() dequeint dq; for(int i=1;i=n;i++) //队头元素是否滑出窗口 if(!dq.empty()dq.front()=i-k) dq.pop_front(); //维护递减性：弹出比当前值小的队尾元素 while(!dq.empty()a[dq.back()]a[i]) dq.pop_back(); dq.push_back(i); if(i=k) couta[dq.front()] ; int main() cinnk; for(int i=1;i=n;i++) cina[i]; getMin();//输出每个窗口的最小值 coutendl; getMax();//输出每个窗口的最大值 return 0; 小结 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。 单调队列主要用于“滑动窗口”相关最大/最小值。 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","tags":[null]},{"title":"线段树和树状数组","path":"/notebooks/scsn/线段树和树状数组.html","content":"线段树 基本概念 线段树是一棵 完全二叉树，用于在 静态数组 上快速完成区间查询（如区间和、区间最大值等）和单点更新。 每个节点维护一个区间的信息，根节点代表整个区间，左右子节点分别代表区间的前后半部分。 构建流程 准备大小为 4×LEN4\\times LEN4×LEN 的数组 tree 来存储节点值。 从根节点开始，递归构建： 如果区间左端点 = 右端点，直接把原始数组的值写入该节点。 否则，计算中点 midmidmid，分别构建左右子区间，并将左右子区间结果合并到父节点。 void build(int idx,int l,int r) if(l==r)//叶子节点 tree[idx]=arr[l]; return; int mid=(l+r)1; build(idx1,l,mid);//左子树 build(idx1|1,mid+1,r);//右子树 tree[idx]=tree[idx1]+tree[idx1|1];//求区间和 区间查询 从根节点开始，看当前节点区间 [l,r][l, r][l,r] 是否与查询区间 [L,R][L, R][L,R] 完全重合。 如果完全重合，直接返回该节点值。 否则，根据中点 midmidmid 决定向左或右子树深入，或者分成两部分递归查询，再把结果相加。 int query(int idx,int l,int r,int L,int R) if(L=lr=R) return tree[idx];//区间重合 int mid=(l+r)1,sum=0; if(L=mid) sum+=query(idx1,l,mid,L,R);//左子树 if(midR) sum+=query(idx1|1,mid+1,r,L,R);//右子树 return sum; 单点更新 定位到要更新的叶子节点，修改其值。 递归返回时，依次在父节点更新合并后的值，保持整棵树信息正确。 void update(int idx,int l,int r,int pos,int val) if(l==r)//叶子节点 tree[idx]=val; return; int mid=(l+r)1; if(pos=mid) update(idx1,l,mid,pos,val);//左子树 else update(idx1|1,mid+1,r,pos,val);//右子树 tree[idx]=tree[idx1]+tree[idx1|1]; 代码示例 例题：Luogu P3372 - 【模板】线段树 1 题意 维护长度为 n 的序列，支持两种操作： 区间 [l, r] 每个数加上同一个值 查询区间 [l, r] 的所有数之和 输入格式 第一行 n，m 第二行 nnn 个初始值 接下来 mmm 行，每行三种格式： 1 x y k 表示给区间 [x, y] 的每个数加上 k 2 x y 表示询问区间 [x, y] 的和 数据范围 1≤n,m≤1051\\le n,m\\le 10^51≤n,m≤105 代码 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=1e5+5;struct Node int sum,tag; //sum:区间和，tag:懒惰标记tr[LEN*4];int n,m;int a[LEN];void pushup(int u)//更新父节点 tr[u].sum=tr[u1].sum+tr[u1|1].sum; return;void apply(int u,int l,int r,int v)//更新子节点 tr[u].sum+=v*(r-l+1); tr[u].tag+=v; return;void pushdown(int u,int l,int r)//下传懒惰标记 if(tr[u].tag) int mid=(l+r)1; apply(u1,l,mid,tr[u].tag); apply(u1|1,mid+1,r,tr[u].tag); tr[u].tag=0; return;void build(int u,int l,int r)//构建线段树 tr[u].tag=0; if(l==r) tr[u].sum=a[l]; return; int mid=(l+r)1; build(u1,l,mid); build(u1|1,mid+1,r); pushup(u); return;void update(int u,int l,int r,int L,int R,int v)//区间更新 if(L=lr=R) apply(u,l,r,v); return; pushdown(u,l,r); int mid=(l+r)1; if(L=mid) update(u1,l,mid,L,R,v); if(midR) update(u1|1,mid+1,r,L,R,v); pushup(u); return;int query(int u,int l,int r,int L,int R)//区间查询 if(L=lr=R) return tr[u].sum; pushdown(u,l,r); int mid=(l+r)1; int ans=0; if(L=mid) ans+=query(u1,l,mid,L,R); if(midR) ans+=query(u1|1,mid+1,r,L,R); return ans;signed main() cinnm; for(int i=1;i=n;i++) cina[i]; build(1,1,n); while(m--) int op,x,y; cinopxy; if(op==1) int k; cink; update(1,1,n,x,y,k); else coutquery(1,1,n,x,y)endl; return 0; 树状数组（Fenwick Tree） 基本概念 树状数组又称 二叉索引树，用于在 动态数组 上快速完成前缀和查询和单点更新。 利用 低位优先 的思想，把数组分成若干层次，实现 O(log n)O(log\\ n)O(log n) 的更新与查询。 初始化 定义大小为 n+1n+1n+1 的数组 bit，下标从 1 开始。 遍历原始数组，每次调用一次单点更新，把值累加到 bit 中。 vectorint bit(n+1,0);for(int i=1;i=n;i++) add(i,arr[i]);//单点更新 单点更新 从更新位置 i 开始，依次向后跳到 i+=lowbit(i)，把增量 delta 累加到所有相关节点上。 lowbit(i) = i -i，表示 i 的最低位权重。 void add(int i,int delta) while(i=n) bit[i]+=delta; i+=i-i; 前缀和查询 从查询位置 i 开始，依次向前跳到 i-=lowbit(i)，把所有经过节点的 bit[i] 累加到结果中。 最终得到前缀和 sum(arr[1..i])。 int sum(int i) int res=0; while(i0) res+=bit[i]; i-=i-i; return res; 代码示例 例题：Luogu P3374 - 【模板】树状数组 1 题意 给定长度为 n 的整数序列，初始值 a1,a2,…,ana_1, a_2, \\ldots, a_na1​,a2​,…,an​。需要执行 m 次操作，每次操作有两种类型： 1 x k：将第 x 个数加上 k 2 x y：询问区间 [x,y][x, y][x,y] 内所有数之和 输入格式 第一行包含两个整数 n 和 m，分别表示序列长度和操作次数。 第二行包含 n 个整数，为序列的初始值。 接下来 m 行，每行一个操作指令。 数据范围 1≤n,m≤5×1051\\le n,m\\le 5\\times 10^51≤n,m≤5×105； 所有加数和初始值的绝对值均不超过 2312^{31}231。 解题思路 我们使用 树状数组（Fenwick Tree） 来维护前缀和，支持单点更新和区间查询均为 O(log n)O(log\\ n)O(log n)： 初始化时，将每个 a[i] 插入到树状数组。 对于 “1 x k” 操作，在下标 x 处加上 k，即调用 update(x,k)。 对于 “2 x y” 操作，利用前缀和差值：query(y)-query(x-1)。 核心操作： update(i,v)：从 i 开始，不断 i+=lowbit(i)，将 tree[i] 累加 v。 query(i)：从 i 开始，不断 i-=lowbit(i)，累加 tree[i]，直到 i=0。 时间复杂度：O((n+m) log n)O((n+m)\\ log\\ n)O((n+m) log n)；空间复杂度：O(n)O(n)O(n)。 代码 #includebits/stdc++.h#define int long longusing namespace std;const int LEN=5e5+5;int n,m;int tree[LEN];//返回最低位 1 的值inline int lowbit(int x)return x-x;//单点更新：a[i]+=vvoid update(int i,int v) for(;i=n;i+=lowbit(i)) tree[i]+=v; return;//查询前缀和 a[1..i]int query(int i) int s=0; for(;i0;i-=lowbit(i)) s+=tree[i]; return s;int main() cinnm; for(int i=1;i=n;i++) int x; cinx; update(i,x); while(m--) int op,x,y; cinopxy; if(op==1) update(x,y); else coutquery(y)-query(x-1)endl; return 0; 对比总结 数据结构 区间查询 前缀/区间查询 单点更新 空间复杂度 线段树 支持任意区间查询 逻辑同区间查询，O(log n)O(log\\ n)O(log n) O(log n)O(log\\ n)O(log n) O(4n)O(4n)O(4n) 树状数组 不直接支持任意区间查询 前缀和 O(log n)O(log\\ n)O(log n)，区间和可转化 O(log n)O(log\\ n)O(log n) O(n)O(n)O(n) 若需支持区间加值、单点查询，可在树状数组中维护差分数组。 若需支持区间加值、区间查询，则需要 双树状数组 或 差分 + 前缀和 技巧。 对比线段树，树状数组代码更简洁，但不易扩展到区间修改和区间查询的混合场景。","tags":[null]}]