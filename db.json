{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","path":"js/plugins/copycode.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","path":"js/plugins/download-file.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","path":"js/plugins/video.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","path":"js/plugins/voice.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","path":"js/services/artalk_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/contributors.js","path":"js/services/contributors.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","path":"js/services/fcircle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends_and_posts.js","path":"js/services/friends_and_posts.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","path":"js/services/friends.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","path":"js/services/ghinfo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","path":"js/services/giscus_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","path":"js/services/mdrender.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","path":"js/services/memos.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/rating.js","path":"js/services/rating.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","path":"js/services/siteinfo.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","path":"js/services/sites.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","path":"js/services/timeline.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","path":"js/services/twikoo_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/vote.js","path":"js/services/vote.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","path":"js/services/waline_latest_comment.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","path":"js/services/weibo.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/快读快写模板.md","hash":"4df482823d252c5a8d344f200c4315532ad741d0","modified":1753789460061},{"_id":"source/_posts/搜索题目整理.md","hash":"d67407d1aa4c3969fd3e40cf290b0c43a76ad2d5","modified":1753792477455},{"_id":"source/_posts/最小生成树.md","hash":"6e6b31a6d6eb267f5f71e8e7470c8bf60f1eddd1","modified":1753789460062},{"_id":"source/_posts/最短路.md","hash":"7106b7826abb75243a8478e06e19e47082d3152a","modified":1753789460062},{"_id":"source/_posts/链式前向星.md","hash":"cbb4102e08e6eac328aa9afe09dcd750b98831ee","modified":1753789460063},{"_id":"source/about/index.md","hash":"4974d288702c9b765cefb9e57f0ebba3dfa8c3af","modified":1753789460064},{"_id":"source/friends/index.md","hash":"e874662da2f53235311555585fbba162e86bad5d","modified":1753789460064},{"_id":"source/_data/links/qpoem.yml","hash":"91db142e36492847988f7ee2827179958b16268b","modified":1753789460061},{"_id":"source/_data/notebooks/scsn.yml","hash":"0ad42dd3fee1fec29acf16b1f79bcb36b6bc8d1d","modified":1753790954326},{"_id":"source/notebooks/scsn/index.md","hash":"03e5dd2b5bb8cfe8ec0d5611d9c5bc05239f1758","modified":1753790690054},{"_id":"node_modules/hexo-theme-stellar/_data/chat_users.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1753789456574},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tree.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1753789456737},{"_id":"node_modules/hexo-theme-stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1753791090847},{"_id":"node_modules/hexo-theme-stellar/README.md","hash":"2af9a521d78c96c4aeb6069adcb52b138536b800","modified":1753791090849},{"_id":"node_modules/hexo-theme-stellar/_config.yml","hash":"9f8e9ff8a8c2bff829a1ae8a18288b876db543c5","modified":1753791090851},{"_id":"node_modules/hexo-theme-stellar/package.json","hash":"04c43bb3fb975acdbdf6e0f5145ed54e4e7b866a","modified":1753791090853},{"_id":"node_modules/hexo-theme-stellar/_data/widgets.yml","hash":"f86a03e31758e096050ecf5b82e687fddb174073","modified":1753791090860},{"_id":"node_modules/hexo-theme-stellar/_data/icons.yml","hash":"3b9ed4cec71810dfa8ec661af1811327c88bda52","modified":1753791090858},{"_id":"node_modules/hexo-theme-stellar/languages/en.yml","hash":"42c8040336776386f974ca127f0aa1b213bb8f1a","modified":1753791090863},{"_id":"node_modules/hexo-theme-stellar/languages/zh-CN.yml","hash":"67c6742bd95c6669fe91e33ddc5950d2cf35923c","modified":1753791090866},{"_id":"node_modules/hexo-theme-stellar/languages/zh-TW.yml","hash":"b136f321fbbab62c0c5669ee8051473db11d4d86","modified":1753791090869},{"_id":"node_modules/hexo-theme-stellar/layout/404.ejs","hash":"d84f01256feb3c0bc0b280031fb78ae9f0d86f26","modified":1753791090870},{"_id":"node_modules/hexo-theme-stellar/layout/archive.ejs","hash":"239657e053d7a66851f3205bed74d99d892dc5a8","modified":1753791090873},{"_id":"node_modules/hexo-theme-stellar/layout/categories.ejs","hash":"50e24a6dd300ebb787ef3ad9d746eb7f71590772","modified":1753791090875},{"_id":"node_modules/hexo-theme-stellar/layout/index.ejs","hash":"56c641005125a0abf1227a9ba339a7dd5aac960e","modified":1753791090877},{"_id":"node_modules/hexo-theme-stellar/layout/index_wiki.ejs","hash":"d35222b0f070f31d80bb1ca90354bdc60bd62692","modified":1753791090880},{"_id":"node_modules/hexo-theme-stellar/layout/index_topic.ejs","hash":"85ac8aed79bf2e939f3def0137d1c5724d33a6e6","modified":1753791090878},{"_id":"node_modules/hexo-theme-stellar/layout/notebooks.ejs","hash":"d11ab953e00bd4191459451f63601582ab53f38f","modified":1753791090882},{"_id":"node_modules/hexo-theme-stellar/layout/notes.ejs","hash":"492e8d83b5233d510d094c66e66949a6a88dacf5","modified":1753791090883},{"_id":"node_modules/hexo-theme-stellar/layout/layout.ejs","hash":"4292198534807d1303aef5fc224f46d584fe2e25","modified":1753791090881},{"_id":"node_modules/hexo-theme-stellar/layout/page.ejs","hash":"b8070e812b4468b4a7df22d5b5e8e848afdab251","modified":1753791090884},{"_id":"node_modules/hexo-theme-stellar/layout/tags.ejs","hash":"66477707f525a1ee4131c11d79defd18da641599","modified":1753791090886},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/head.ejs","hash":"dedbd6a5507fc3cf8cf23f5a4cd1f4f3abe07bb5","modified":1753791090897},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts.ejs","hash":"125084ef723813968aac71bfe841aad5c4b6460e","modified":1753791090901},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/menubtn.ejs","hash":"0f080d7aefc9c7e208daddf2981b81d36783e034","modified":1753791090899},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/copycode.ejs","hash":"7cedd8eced00f6813f7d772334ec92acbc8bd982","modified":1753791090901},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/fancybox.ejs","hash":"2f6b7c118fcb54a1cae0bdaa55a1e8a09cf3e013","modified":1753791090903},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/heti.ejs","hash":"c3956c8fd5fabd4ec8cea05dc076bf7a03eb012a","modified":1753791090904},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mathjax.ejs","hash":"ddcb15575bf2897c57b92c9b23ffb0b3878e5ec4","modified":1753791090907},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/index.ejs","hash":"29407e95f14d4d50c1f8a8b9a5af242927676432","modified":1753791090904},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/mermaid.ejs","hash":"5ad208b430071ed4ee84af4ae69356219ec586f0","modified":1753791090909},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/preload.ejs","hash":"f25523da5633b249da8cebe7c866265bf7825697","modified":1753791090910},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/scrollreveal.ejs","hash":"f763156bcd1ed4611e4541069d9d928d3df37fe9","modified":1753791090911},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/swiper.ejs","hash":"b80d6185c0263375df82498705a98ad32238b12f","modified":1753791090912},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/tianli_gpt.ejs","hash":"c63f65df336bd10b2c5f068830c3086f3f13f3a3","modified":1753791090913},{"_id":"node_modules/hexo-theme-stellar/source/css/_custom.styl","hash":"4a3aa7213e89a72a30b35b08d5e6b79a90a898ed","modified":1753791090946},{"_id":"node_modules/hexo-theme-stellar/source/css/main.styl","hash":"7244b3269d777a3a67446c0e20c53bc60b577304","modified":1753791090947},{"_id":"node_modules/hexo-theme-stellar/source/js/main.js","hash":"e702e941a62bf081e9209fdc20d0f5873e9eb902","modified":1753791090957},{"_id":"node_modules/hexo-theme-stellar/scripts/.cache/stellar-version.json","hash":"01cd52de0e2376bcd1a616e420933c792e618e4f","modified":1753795370614},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/index.js","hash":"1fca6cadef00b661f1ef4fc27c2dffc5d97bebdd","modified":1753791090917},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/pretty_urls.js","hash":"b3fd456a0ce1388886306afe99ec1e7342998ee3","modified":1753791090918},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/404.js","hash":"66b53d2b35b18d5f3835b47467c23f31eb322553","modified":1753791090920},{"_id":"node_modules/hexo-theme-stellar/scripts/events/index.js","hash":"0ce4b1068fe46e3c2cb0da1b3b8b4357d64f7250","modified":1753791090915},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/author.js","hash":"0de0824fdbc4f67c84910267901095504b253751","modified":1753791090920},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/categories.js","hash":"936d4d406fd401359bab1e5f74c6e1e097e8f092","modified":1753791090921},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/search.js","hash":"8a59c0923c2a4a11c09ce87fccf98c090c73a0e4","modified":1753791090925},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/notebooks.js","hash":"87ede05eb8ea9c02f53177c83a2258dc163f28dc","modified":1753791090922},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/tags.js","hash":"ed29755154d8e7a9346019ba4ac8782a8649b177","modified":1753791090926},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/topic.js","hash":"88c0f2990365fb0ce751682815e07f36cf333d3f","modified":1753791090927},{"_id":"node_modules/hexo-theme-stellar/scripts/generators/wiki.js","hash":"61efe22787c3fea9d935df4b088a9dd2d1af0868","modified":1753791090928},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/category_color.js","hash":"20b19d6b6307cdeb0b0832bf4931366abe972490","modified":1753791090930},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/dynamic_color.js","hash":"507acbb7445ec172e10ab03c8917a4d8132e264a","modified":1753791090931},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/icon.js","hash":"b7c84be7f08abc1725f351ed8718791a861466c3","modified":1753791090932},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/json_ld.js","hash":"16a52b6c7fb7899c4f7b04bf4e87194d71d25f06","modified":1753791090934},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/parse_config.js","hash":"1251d82318972f22283dc7a089b77a3f0135b1b6","modified":1753791090935},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/pretty_url.js","hash":"f2d94135de1d44460e65ed2167271c2068b18597","modified":1753791090935},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/related_posts.js","hash":"6763a97fa25669fa1d1aa8e5291919deb5dc7f67","modified":1753791090937},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/scrollreveal.js","hash":"57e3da4a3dd751b3ebd384a674e26f08f69da018","modified":1753791090937},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1753791090938},{"_id":"node_modules/hexo-theme-stellar/scripts/helpers/utils.js","hash":"05c127baa250b192c9c673355bf90d7134e1ea11","modified":1753791090941},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/layout.ejs","hash":"a38e9684721afe2015570b978654f5805e173ae0","modified":1753791090960},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/inline-labels.js","hash":"307a7331ab39521f4af0d6bdbc2ba3a114942017","modified":1753791090944},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/index.js","hash":"ee19ee68f94844ea7bd91dbd914938a46da3ee99","modified":1753791090942},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/script.ejs","hash":"62be59ef634ceee342c81ecc4e23cb664cdbf620","modified":1753791090961},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/footer.ejs","hash":"39e822090c2f9dbe1f1ebc4ed108b16bb0e7da9e","modified":1753791090967},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/defines.ejs","hash":"f6db1704f9b89992b802c01af332289c4af718d1","modified":1753791090969},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/index.ejs","hash":"4b317700640749b1e04e6d51a542a2bcd28c8b72","modified":1753791090964},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/wiki_cover.ejs","hash":"8c2b00fed4124fb9571944d87177dba4d925780d","modified":1753791090966},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/cover/post_cover.ejs","hash":"56ed19f8150e2e3f3070a79ba7c4b63f903d9df2","modified":1753791090964},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/lazyload.ejs","hash":"d88f31ea258c52e80e9134b56ab58e65830f805e","modified":1753791090971},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/services.ejs","hash":"9dec23072ebbdf96d164bc698a11f3a09ea26d1a","modified":1753791090972},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/tagtree.ejs","hash":"c16031694fee3e0c305139136126dee88e1e88cf","modified":1753791090976},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/sidebar.ejs","hash":"403b6986bfc54177a7ee3ddba9e0a55e7b79e3a1","modified":1753791090973},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/theme.ejs","hash":"ad8194beff5faa3495ad72799cc81399b7d84871","modified":1753791090978},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/scripts/utils.ejs","hash":"d07baba303b5e03d4ee4a33d404524da3e3499cf","modified":1753791090980},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_leftbar.ejs","hash":"c005a146d8f733e83af8f1652bbd71d75b13b807","modified":1753791090983},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/index_rightbar.ejs","hash":"a16ecd6d9421c30ffe2ca1a44cc9597309b5b70c","modified":1753791090985},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/author.ejs","hash":"b77e88418227d4691e2ad8a4996727753f31b1f5","modified":1753791090989},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghissues.ejs","hash":"e65ed1f0fffb6fef595eb775d34742798bb2493e","modified":1753791090991},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/menu.ejs","hash":"84ee2d7fe8eededb5103e5fab0b7359cb01d6408","modified":1753791090987},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/logo.ejs","hash":"9bbac48b3d18b3e686dacc624e12758c0c96f6e3","modified":1753791090986},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghuser.ejs","hash":"b9ba4cca16293986e5980027fdd2da78dae95b6b","modified":1753791090993},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/sidebar/search.ejs","hash":"770056e023a00b22d2853c4fa65bb48035ade3b2","modified":1753791090988},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/linklist.ejs","hash":"813336cbbe4505e9be42d5682fd7b720dba25194","modified":1753791090995},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/markdown.ejs","hash":"16c0553fb56422ce343e5c9ddcfda5d989c97579","modified":1753791090996},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/ghrepo.ejs","hash":"8586ff53e3fe7361880f77c2cc1782335770c089","modified":1753791090993},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/recent.ejs","hash":"425419a7b67082366ed391392d9ac861f6cba851","modified":1753791090997},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/related.ejs","hash":"abef14819f5c513e8834ea92a625a87cb9dfcf57","modified":1753791090997},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagcloud.ejs","hash":"d95c26f84c7d9061ba3ef6188d58fa14f1c63bf3","modified":1753791090999},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/timeline.ejs","hash":"54f105f537c5c6cd1b84e4f5e586d4cca15c3c2a","modified":1753791091001},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tagtree.ejs","hash":"f7f7705da3313a90f6c3312880986a275d93d570","modified":1753791091000},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/toc.ejs","hash":"bdfd167a73304ab76903011a26be456839bd5816","modified":1753791091002},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/tree.ejs","hash":"395b2e4cc644f2e62824b4f5493baa8208e82839","modified":1753791091003},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/algolia_search.ejs","hash":"1d720e4b0308a0818f45a9a4b63df1e9f6521737","modified":1753791091004},{"_id":"node_modules/hexo-theme-stellar/layout/_plugins/search/local_search.ejs","hash":"38a3641bb532583b699fda42175cb14242f07575","modified":1753791091005},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blockquote.styl","hash":"64be440550197ab5cbed921428a8e63846bb351c","modified":1753791091106},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/base.styl","hash":"ae0332e4cf880e833648a4b30b21fbab2b0be69b","modified":1753791091105},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/blur.styl","hash":"81685461475c4c98b7850490ddf54116a469306a","modified":1753791091107},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/button.styl","hash":"6794cf6af2538d56537b7ece30132c6918a9a78f","modified":1753791091109},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/canonical.styl","hash":"4d6087993858fa21415a1453310905a27e5ef099","modified":1753791091110},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/cap.styl","hash":"1b10f72a936ad9695196116626dd741a0b797918","modified":1753791091110},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1753791091112},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/device.styl","hash":"59a6b9ac262a87fcb57e50e69d0d6518a7cf0bf8","modified":1753791091112},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/highlight.styl","hash":"086db146f4c108826ed41aa068805a673379fc63","modified":1753791091115},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/html.styl","hash":"fae4375fc45121ffc3a43872ddc3331d6d49700d","modified":1753791091116},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1753791091117},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/input.styl","hash":"953fc87072cd760d92dfef55310addbb17bb2b51","modified":1753791091118},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/layout.styl","hash":"c7d0d3c70087e14bd1f6d8d50d56762d8c5ad44d","modified":1753791091119},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/loading.styl","hash":"5daad36cbb1d05e7b579e0c775ea52fd777c80e0","modified":1753791091119},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/media.styl","hash":"fa7dbcaa31089fe547acb01a767af97fb019bba6","modified":1753791091120},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/pre.styl","hash":"68b2c99a811dc03a4aa1c4ce35003f65404306e8","modified":1753791091121},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/span.styl","hash":"86462ffaf1603b5d5ab6534c0f7fe0eb495aad2d","modified":1753791091122},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/svg.styl","hash":"bb4d1a4676eb5229685ba21c7c69acbf4482bf55","modified":1753791091124},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/title.styl","hash":"12323840adcc748d5c854536ae38db26f7bd3687","modified":1753791091125},{"_id":"node_modules/hexo-theme-stellar/source/css/_common/toast.styl","hash":"f2930874174763da2338fa95087c345bf5c41800","modified":1753791091126},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/index.styl","hash":"7a7ab293e065116646102546c6bab01166836059","modified":1753791091128},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/layout.styl","hash":"4be8936e7f2f593ecc14668bdf2ea6c7e44aa53c","modified":1753791091131},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/const.styl","hash":"223292db0208f8ed8127d54d42501d2a29d24dc1","modified":1753791091136},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/main.styl","hash":"66bf332a79067e871e20ae29722175e0bb1c4f98","modified":1753791091133},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/func.styl","hash":"d19aaeb33d5f249b064bb338b50ee746b5a2e2ec","modified":1753791091138},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/list.styl","hash":"8872ff6cab827775d47e7017c9e9c028c732eb0e","modified":1753791091132},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/md.styl","hash":"150aa0d6654b3d2775499304c0cec8ac6112d845","modified":1753791091134},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/theme_base.styl","hash":"08a6592c43e19b7fb073825bc9dd3d73b8cc1e77","modified":1753791091138},{"_id":"node_modules/hexo-theme-stellar/source/css/_defines/theme_colorful.styl","hash":"1c602b7e690e6fb08acb8e9eae30ce7540625de4","modified":1753791091140},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/copycode.styl","hash":"a9f27136143eb779d1aeb903e863c94a98b82aac","modified":1753791091143},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/aplayer.styl","hash":"00b6e9209638eef9f70e75a24a5a90b05f7b5347","modified":1753791091142},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/katex.styl","hash":"f58016799f7a534d453625fab4cd66a13063e4b8","modified":1753791091148},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/fancybox.styl","hash":"f4a709dcac4e21ca0fbeca552a8dde2ac2bf8d97","modified":1753791091145},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/index.styl","hash":"c5ce6de9724f74a81c3b0567639385a2b5dcc549","modified":1753791091147},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/lazyload.styl","hash":"d4c9e49fb99ac4dccaa92c11bb3503552bc96598","modified":1753791091149},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/mermaid.styl","hash":"1a2643ba6375b0d3b5d56437604dcb94cd666977","modified":1753791091150},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/swiper.styl","hash":"759fdb34f0b2019f0a5d210225748e3a18c00603","modified":1753791091153},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/scrollreveal.styl","hash":"21b9125c1bae3e5348547e85500ceb992de21923","modified":1753791091151},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/tianli_gpt.styl","hash":"1f2efe2e13866e25d5a1d7471aeb2314682a9f85","modified":1753791091155},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1753791091158},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/download-file.js","hash":"6bd0cc2f31164406013313543cb04f9ab3cd2452","modified":1753791091160},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1753791091161},{"_id":"node_modules/hexo-theme-stellar/source/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1753791091168},{"_id":"node_modules/hexo-theme-stellar/source/js/services/artalk_latest_comment.js","hash":"31acb9a3587aa3012569969675c17645b7722f1f","modified":1753791091175},{"_id":"node_modules/hexo-theme-stellar/source/js/search/local-search.js","hash":"d54e8d53e22875faa0e360fc7827f6f9dd068276","modified":1753791091173},{"_id":"node_modules/hexo-theme-stellar/source/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1753791091170},{"_id":"node_modules/hexo-theme-stellar/source/js/services/contributors.js","hash":"be5c8ae1055696a0da9c5552fce20c120b2eb584","modified":1753791091177},{"_id":"node_modules/hexo-theme-stellar/source/js/services/fcircle.js","hash":"a684b276713a1c6f07817de9b70744c1a5c745ea","modified":1753791091178},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends_and_posts.js","hash":"0ce8b46873e21e778b315e6c190387cdd1e1e107","modified":1753791091180},{"_id":"node_modules/hexo-theme-stellar/source/js/services/friends.js","hash":"6b30960a86ce11998c1861cfe3b7a9ecdc28259f","modified":1753791091178},{"_id":"node_modules/hexo-theme-stellar/source/js/services/ghinfo.js","hash":"693acbabc79426bf276dd3072f40b2d9a98ee026","modified":1753791091181},{"_id":"node_modules/hexo-theme-stellar/source/js/services/giscus_latest_comment.js","hash":"b1f0f1a5941a4fdd20fc53444fd4fa6e58b0088e","modified":1753791091182},{"_id":"node_modules/hexo-theme-stellar/source/js/services/mdrender.js","hash":"cf90dd3f4aa37b1131fb871ec1a78eff96f2a861","modified":1753791091183},{"_id":"node_modules/hexo-theme-stellar/source/js/services/memos.js","hash":"9ecffb14c952d903b21bf2184179868837f74ffa","modified":1753791091185},{"_id":"node_modules/hexo-theme-stellar/source/js/services/rating.js","hash":"19e8db4f26af6e656074bebda53d9a00216a0d31","modified":1753791091186},{"_id":"node_modules/hexo-theme-stellar/source/js/services/siteinfo.js","hash":"e484765fdcabdbbeabf2062baf6ccb94d7ba777f","modified":1753791091187},{"_id":"node_modules/hexo-theme-stellar/source/js/services/sites.js","hash":"f05d40a3476c796ed9e142ec2d1de15a8d1aef92","modified":1753791091187},{"_id":"node_modules/hexo-theme-stellar/source/js/services/timeline.js","hash":"43e225ee469d10efe22cae965483a0dabd13388c","modified":1753791091190},{"_id":"node_modules/hexo-theme-stellar/source/js/services/twikoo_latest_comment.js","hash":"4e9a18f32faa168b5fd1465d91df67ae3cdde6bf","modified":1753791091192},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/authors.js","hash":"eedefb5430fc4176bdc2814c8a88295f0e524d10","modified":1753791091008},{"_id":"node_modules/hexo-theme-stellar/source/js/services/vote.js","hash":"0fdef6519fa2528f2ffd3b38272955d8469a8b2e","modified":1753791091193},{"_id":"node_modules/hexo-theme-stellar/source/js/services/weibo.js","hash":"144200d261c85b4f353243afc1f50003bdf23a93","modified":1753791091195},{"_id":"node_modules/hexo-theme-stellar/source/js/services/waline_latest_comment.js","hash":"25ed1f668161941869e5effd4fbb408846c6deae","modified":1753791091195},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/config.js","hash":"731a596b124fd37671fb69fecf45c94f35bcece5","modified":1753791091013},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/doc_tree.js","hash":"f7d6b86a442afabf885566adfc02d42dc5eaf46e","modified":1753791091016},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/fix_image_tags.js","hash":"bf23791be2fdd6e12bac5745aa002888cae9bc4e","modified":1753791091017},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/get_image_ratios.js","hash":"0fc3d7e6083a2b0482504a86206fcdd723027075","modified":1753791091018},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/links.js","hash":"881cac75e4071d219a18156738e18eb397d83c00","modified":1753791091020},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/merge_posts.js","hash":"4e45b8dc5317f7d66bc14879ae6b5f972123ce5d","modified":1753791091022},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/notebooks.js","hash":"ad5eae17a77a92100c748fd668c73e1b09f7a21f","modified":1753791091024},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/topic_tree.js","hash":"7f735f2573c87d202e2d4b845307d0725d619e8e","modified":1753791091026},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/version-check.js","hash":"16a9602caaa37ac5bb047bb3fa4649b61e2fb3e3","modified":1753791091028},{"_id":"node_modules/hexo-theme-stellar/scripts/events/lib/utils.js","hash":"271ba6c8cc997e4f55b2e146a99bde8301818400","modified":1753791091027},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1753791091030},{"_id":"node_modules/hexo-theme-stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1753791091031},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/about.js","hash":"c9778c35c1ccd9f2018174bafbd37b23dd52cf62","modified":1753791091032},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/albums.js","hash":"9f95c5053a59ad05df8c8add8975df24b86266e1","modified":1753791091033},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/banner.js","hash":"8c7fb7f0abe55868dea09eaa0b4ae7d52cbe6b08","modified":1753791091036},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/audio.js","hash":"9b094b16dce131a5c09373661c88a1de9b5326f7","modified":1753791091035},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/blockquote.js","hash":"3db333c573f94346b1b0192c57e4609966f9a43f","modified":1753791091037},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/button.js","hash":"e0890a759335b1c5ad09db084bcf62073b2557cb","modified":1753791091039},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/box.js","hash":"66bed2e303468a8fd9c664ce3e697ceb4e3eb931","modified":1753791091038},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/checkbox.js","hash":"69caf7488b6c92cb2524df81ece6f33a46a89fe0","modified":1753791091053},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/copy.js","hash":"d22a82b6fd9c96c7ac49677b427e6c629fa889d7","modified":1753791091055},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/emoji.js","hash":"e10f68f69206fc6e9d0c478630be2b4514d328d7","modified":1753791091057},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folders.js","hash":"4ca5470285541033b8272ba7cc3bd5860504169e","modified":1753791091059},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/folding.js","hash":"9f51610fc62067a16a9c27884864f69e4200843c","modified":1753791091060},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/frame.js","hash":"1251a8622260af8efc55c2f0aac8ee5cf79d9043","modified":1753791091061},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/friends.js","hash":"89c23e27bd483ed1a842f205460f6c46e1cc2b2b","modified":1753791091066},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/gallery.js","hash":"b069a958377ed370e138a633280115103c89c731","modified":1753791091067},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/grid.js","hash":"dad59b638c2fd30538e3a69bf0c8d76d34cf3ece","modified":1753791091069},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/ghcard.js","hash":"87afee954b97b6f945cc4b7f50b012fca3e68f11","modified":1753791091069},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/icon.js","hash":"273898ae29a07c1baccb432efa0d33ccfabe7db9","modified":1753791091072},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/hashtag.js","hash":"f38ce98fff40ed35be9b1f1be3194bc4c5d44dc3","modified":1753791091071},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/image.js","hash":"b0f913a08f0b6df4271498c6a9e17d74e22b7897","modified":1753791091073},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/link.js","hash":"5b5d41a0bbe1af30487c178c69a7373f598f16b6","modified":1753791091077},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/mark.js","hash":"cfd8198f349dba60fbdf53042b6ebd9a0ba521c7","modified":1753791091078},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/md.js","hash":"cbc81d08056fcf071b480c806e358bf46c61060d","modified":1753791091079},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/navbar.js","hash":"b517b0a5758f7971868f4ca4b4472770ab205280","modified":1753791091081},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/note.js","hash":"a70d1fcb440ad029ddddb72b053a59b1ed3bfef8","modified":1753791091082},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/okr.js","hash":"6a11a364081ecb3fc5e36408fd57da91f6aa2297","modified":1753791091083},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/posters.js","hash":"4d9a6d4f392cd757513e94020e82e6e788962239","modified":1753791091085},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/poetry.js","hash":"c36321caeec845ed131bdd0922bff25eb59f086a","modified":1753791091084},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/quot.js","hash":"c262e4bd70a2c6501909a2ef51c13e64a445637d","modified":1753791091086},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/rating.js","hash":"0cba03c1b3931633cffc7a41a1554c025fb8d31c","modified":1753791091087},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/sites.js","hash":"62147a1d195a07d7c57fa5cfee6d2365bf4423ca","modified":1753791091088},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/tabs.js","hash":"1b3d7b6b962293b44430e7b40560b8d1fa5c618d","modified":1753791091090},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/swiper.js","hash":"dc025c79b190d233383fec001ddbe478f2675cc8","modified":1753791091088},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/timeline.js","hash":"2646355804c1c442a2ac19d6a5a67e01e36d19f2","modified":1753791091093},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/toc.js","hash":"d7b51b66d7b83a77e501930e735092a9967d5d18","modified":1753791091094},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/vote.js","hash":"d7fd783e9c22e6083d8042df89913c5991c9ef8c","modified":1753791091096},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/video.js","hash":"75c750467540777349a396a068517173fdac31b5","modified":1753791091095},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/layout.ejs","hash":"43ca5e6a263f1e06fe75f4ca11ca7d955311ea72","modified":1753791091197},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/artalk/script.ejs","hash":"3ee0e3b898c1fa5e5cf3843fab0baafb7fd0e95b","modified":1753791091198},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/script.ejs","hash":"69a2582d4e9e3203368196f4806adab2274e41fb","modified":1753791091200},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/beaudar/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1753791091199},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/layout.ejs","hash":"144e313ab45889c715ea1cfff3976b1f1322469e","modified":1753791091201},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/giscus/script.ejs","hash":"49fd68b7752d0ca06d80a52bf800cf03845909e0","modified":1753791091202},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/layout.ejs","hash":"a3d429f4eafc582f739dd48865b39afd7c22ed56","modified":1753791091203},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/twikoo/script.ejs","hash":"3c93fe825769cd70027281c28980021b3ff8c4b0","modified":1753791091203},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/script.ejs","hash":"0c54bbd610c1b31d7f45b9b4ded65690b673482c","modified":1753791091207},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/utterances/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1753791091205},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/layout.ejs","hash":"2abe764ffeab5603645b0e5148a17e9373de5eb4","modified":1753791091208},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/comments/waline/script.ejs","hash":"ef4b59476f4edf03cb25bdffe449b5da161d1d8e","modified":1753791091209},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/article_footer.ejs","hash":"d1bb42114db160e9f0d5ae078429db4c58bf7295","modified":1753791091212},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/contributors.ejs","hash":"c311ed2591b8b6155734df7dd50e14a603dbbf4a","modified":1753791091219},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/read_next.ejs","hash":"ce4f88f182022e1642345ddc09f98d4982ad7fd5","modified":1753791091220},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/article/related_posts.ejs","hash":"ef485a4dc2db40bd68b35128f2140520db859b45","modified":1753791091221},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/article_banner.ejs","hash":"80dd9ebe6c7dbfb8c2bc6e8199320f339e6264e1","modified":1753791091223},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/dateinfo.ejs","hash":"d6e317db0030ace1f9cbab283ae7c40183859996","modified":1753791091225},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/ghinfo.ejs","hash":"336cad7d997ba31000ee1f08cd6cff84978a589a","modified":1753791091227},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_blog.ejs","hash":"a377fe5c3fde1fc215428cd41f82a8a7f7aa4a59","modified":1753791091228},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/nav_tabs_wiki.ejs","hash":"8a796024968a344c33a96ab0d003119ddd5d9e47","modified":1753791091229},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_card.ejs","hash":"f9b87418fbecf9e7e3a5d074ee9e9a26f5cc1788","modified":1753791091232},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/note_tags.ejs","hash":"c74624f495b34cf3f40c8771542f9913f060effc","modified":1753791091232},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/paginator.ejs","hash":"1a4b3bc64325ec7d5932ea78c36f2ec4978c09eb","modified":1753791091235},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/notebook_card.ejs","hash":"999b9c8895d84db707b1654c42326dfbb5fbe0fa","modified":1753791091233},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/notebook/paginator.ejs","hash":"3c2f797fd3cf7e6e8c1b1dac168db26e92430b60","modified":1753791091234},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/post_card.ejs","hash":"0de2735c06858282a94a3152bba916e2c8b70a62","modified":1753791091235},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/topic_card.ejs","hash":"9f100016e7cfa07c8728f9c3cf9543ed3ed43cfe","modified":1753791091235},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"d2676c1817f09be21008fbf1c2a25e3c9dc1793f","modified":1753791091237},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/linklist.ejs","hash":"91f3a83ff54284200951637c0cfcd3e4e613942e","modified":1753791091240},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/widgets/components/link.ejs","hash":"090d697211e4ff984923342fdd3272f46aec415c","modified":1753791091239},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/archives.styl","hash":"775f54ade1ed0c673946104149bf37eda06928c2","modified":1753791091246},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-story.styl","hash":"8c9ffd8309df412b306d2df5f732335a0391007f","modified":1753791091248},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-tech.styl","hash":"31fd2b79251b3ebc17976f68c98619a230339b6d","modified":1753791091249},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/article-indent.styl","hash":"06ac54d4c380a973b0705e3edab099fc218b07d3","modified":1753791091247},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/error.styl","hash":"91f9df285a87bc7b7e9da19d547ea4b1dc392828","modified":1753791091250},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/pages/notebook.styl","hash":"50784f59807f63440f49fd499f05c8871462ef1c","modified":1753791091251},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-banner.styl","hash":"49acfb06f81cc0326ffb32c2401876574475fffd","modified":1753791091252},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/article-footer.styl","hash":"c8f47c3798efba31b87c09d880a02e8d59752481","modified":1753791091254},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/cover.styl","hash":"ef44c47d0a70feb84d69cf8bb2bc6977f61b94f2","modified":1753791091256},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/footer.styl","hash":"870db1f93f9f20d6e86ab11f403eb3011f384c41","modified":1753791091258},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/bread-nav.styl","hash":"daf58b32af0b5dfea6cbfa1c3cab695976e57164","modified":1753791091255},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/paginator.styl","hash":"04a60ae497a75a8c11880544f97c44e4468608a3","modified":1753791091261},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/navbar.styl","hash":"101bc440e18dca938deaf287278e72550f5b7144","modified":1753791091260},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/partial/related.styl","hash":"699c8b97933358e14ae52873831144165ad5443c","modified":1753791091261},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/footer.styl","hash":"e12be49ec96b592f39be2e12b14630b45cd2f508","modified":1753791091263},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/logo.styl","hash":"f81eb3d7a49c71f728d8bf42081bde30c6ff596e","modified":1753791091265},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/menu.styl","hash":"11dfb9446c15d6a76073040712aba688e77d8d53","modified":1753791091266},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/nav-area.styl","hash":"35a7482eba84fd48f2439dff626b5e1dc7471dbe","modified":1753791091266},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/search.styl","hash":"976cfd5fe6b10e5227f67f7b06184d3ef009764c","modified":1753791091267},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/sidebar/sidebar.styl","hash":"e2683183e29c54b69df1dd5606159f893e7c9f5d","modified":1753791091269},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/about.styl","hash":"cdaf1ccd782db961cecda0802c94dabe27656731","modified":1753791091270},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/banner.styl","hash":"6dd2b64394bed541814304b90d4bb5ee169e45bb","modified":1753791091271},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/button.styl","hash":"25a0fd7d6a39005b2f30f03f94eaa038ece87b22","modified":1753791091272},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/checkbox.styl","hash":"0ba4c88831b8a395e2da74969084cbb3e579a5a1","modified":1753791091284},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/chat.styl","hash":"728954cb8b94823e19abc3483ef57b0d0beb40ae","modified":1753791091282},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/copy.styl","hash":"a51ee1eea2f332d95299e408421fc1f2894b738d","modified":1753791091285},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/emoji.styl","hash":"100d2e0c43496464dd97fa83fa3e603e68bf30e9","modified":1753791091287},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folders.styl","hash":"2eae18b521a613a19dd6399dcb5504f843dcbb88","modified":1753791091291},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/folding.styl","hash":"84eb11a5a5808f3a4bd0985d97a7b108a36fd044","modified":1753791091293},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/frame.styl","hash":"f8621b5a155ea78c5828e7ccbd1dfe6a72c9733c","modified":1753791091295},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/friends.styl","hash":"98cd2513e233dcc3a6aa96e0bb93e87db6d6bc5e","modified":1753791091297},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/friends_posts.styl","hash":"405c282fa3faab5a4aa6a32971b67abb6852aadf","modified":1753791091298},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1753791091299},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/gallery.styl","hash":"73bc6159765a8dae07733bb313967500dcc49a75","modified":1753791091299},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/icon.styl","hash":"ea5372d1042db221f6c3ce5a31e18153c5e00d39","modified":1753791091302},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/hashtag.styl","hash":"0e2e74fcff5c30be9533e451a1c06ed1477dc9aa","modified":1753791091301},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/grid.styl","hash":"606311fa8326152f99fc721284a09e06490d0cca","modified":1753791091299},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/index.styl","hash":"d76245514a5a0aecb65120b7117cd125a70617fb","modified":1753789456721},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/image.styl","hash":"51dc8e343a5f1ed5b8153138d1d0b4be203052b0","modified":1753791091302},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/inline-labels.styl","hash":"76d7777eb68de8738286ba6ac428854bfdda1945","modified":1753791091305},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/link.styl","hash":"b0039f8ac20f463c3b7dedf2c4f664b48cef8c41","modified":1753791091307},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/mark.styl","hash":"1d31ad6ea25b23dd068508d05e12f76b723790a6","modified":1753791091308},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/mdrender.styl","hash":"95ef27e5937b145329a67e829e20f77e9475ccac","modified":1753791091309},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/media.styl","hash":"392b64b346f6f363f7a15febbc975e5d6c0d33d2","modified":1753791091310},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/navbar.styl","hash":"75a5d208c0a83fa27ed33331ab97dad2bd358d36","modified":1753791091311},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/note.styl","hash":"c037dec8860118dba2c5a4f395a3af2ff33ce7b6","modified":1753791091313},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/okr.styl","hash":"3f2232b94fc7fa5a3aa7c3ea120cef87c6379fdd","modified":1753791091314},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/override.styl","hash":"f02bad5416362f2f82213ce9b111ecfd1cd776ab","modified":1753791091315},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/poetry.styl","hash":"b495d798f4c8a08c6a4bf7b71e1a414b9be0786b","modified":1753791091316},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/quote.styl","hash":"e22fd4527a90f39da29f46e5d35d4d3413ffaa77","modified":1753791091318},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/quot.styl","hash":"aa90d3d99f40da8eebb8f16cfc41ce54b62e88c6","modified":1753791091317},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/rating.styl","hash":"498934d5b483dcb42bef70c4be7d6e058904b19e","modified":1753791091318},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/sites.styl","hash":"da34492a66b411ed77a15a8c9c398145a9aaf0e2","modified":1753791091319},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/tabs.styl","hash":"5c4b4ae76404d9bbfd428f741f371f116296cccb","modified":1753791091320},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/timeline.styl","hash":"acad47a9b0175169a5515b2ef6483d7d32e1b9b1","modified":1753791091322},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/toc.styl","hash":"32a35fe8c237583542c6965f601a32b28ad83713","modified":1753791091325},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/vote.styl","hash":"9253a4627025265da5d22b49955bdc931957af91","modified":1753791091326},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghrepo.styl","hash":"ec728b9649f617a290eb6e4084e30f892671c5b7","modified":1753791091329},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/components.styl","hash":"ebaa8306267f42265be69351a61ae236fc42f4b3","modified":1753791091328},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/ghuser.styl","hash":"21f5f557292ec7b6b434bde918c97ba2a07014ea","modified":1753791091330},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/list.styl","hash":"568645fa91b9bf250af335e10bd8f38df6707a1f","modified":1753791091331},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/related.styl","hash":"edc3e6dd86d881cce6162d6dfb10983c5b843560","modified":1753791091333},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/markdown.styl","hash":"e687ca89549dedd4a724847df1b3be937d945e35","modified":1753791091332},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/tagcloud.styl","hash":"b7bd034f85e449c1d5d0f7e691c1812fa9510a3a","modified":1753791091333},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/toc.styl","hash":"cf3ee0ed3b6e855415fc5e858ea63127753caae8","modified":1753791091336},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/timeline.styl","hash":"b913cd570a38276e1806fb7685055beb6036973d","modified":1753791091335},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/artalk.styl","hash":"cbfd6ab362260d7e869cb1fc927d8c66e21a5390","modified":1753791091341},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/widgets/widgets.styl","hash":"d7d8b864b0e60ae5a55294a2be2bad9001d315c1","modified":1753791091338},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/beaudar.styl","hash":"e9800f67a650f1c022aee494768e05da76e6a6b7","modified":1753791091342},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/twikoo.styl","hash":"838e3c44274ddce8f2d5bb3c54daf6abeae30fc6","modified":1753791091343},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/reel.js","hash":"3a833a0c7d29f98972d6141103d62d5abfd913e4","modified":1753791091243},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/read/paper.js","hash":"e87bbcf10f743e1fcfadc03cf6281aee87c255f5","modified":1753791091242},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/blog.ejs","hash":"4dad91e5f12af9ee9af91e263afe0796f4f536f0","modified":1753791091347},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/utterances.styl","hash":"be43f728d9515acaf050fbb3eed83cfefa2fe702","modified":1753791091343},{"_id":"node_modules/hexo-theme-stellar/source/css/_plugins/comments/waline.styl","hash":"36bfdb6a763f13ff669612c72d066de72d81c0af","modified":1753791091346},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/note.ejs","hash":"c5305bc48e085085334c0e04ddfc597b5c6bc7ae","modified":1753791091348},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/paper.styl","hash":"60f9acda855f45ce57ebb2cbc5ef509aa535c0c8","modified":1753791091351},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/wiki.ejs","hash":"6cdde847f337ddb06bd11f9f0cd26c3183995ddb","modified":1753791091349},{"_id":"node_modules/hexo-theme-stellar/layout/_partial/main/navbar/breadcrumb/page.ejs","hash":"e27ef964f56860d483e435143c3bf70206223484","modified":1753791091348},{"_id":"node_modules/hexo-theme-stellar/source/css/_components/tag-plugins/read/reel.styl","hash":"7cc17cd641629d11d435722f75525a92b02c1b5f","modified":1753791091356},{"_id":"node_modules/hexo-theme-stellar/scripts/tags/lib/chat.js","hash":"5effce604c1e4c9868fe0a4f258eef1c44c1b94f","modified":1753791091052},{"_id":"public/search.json","hash":"a170ac8e6fb7783725e961b1901215482b6e3d51","modified":1753795049938},{"_id":"public/about/index.html","hash":"3cf941c7c57049690f1788cce86a0a690896a156","modified":1753795367065},{"_id":"public/friends/index.html","hash":"c3f13054b70876061a05cb9b0a4a92c402edc88d","modified":1753795367065},{"_id":"public/404.html","hash":"e28126af84ba34836bbe75abf8581110c420f2d9","modified":1753795367065},{"_id":"public/notebooks/scsn/index.html","hash":"d3672e3670c3ba9d07cf7e6c1126546bdc000847","modified":1753795367065},{"_id":"public/2025/07/12/搜索题目整理/index.html","hash":"6f7b057c77e30c59a5c49df97b73fa54bf0e9fc4","modified":1753795367065},{"_id":"public/2025/07/15/链式前向星/index.html","hash":"e680bb2796e2a6e589e01198c8a4193b6904761f","modified":1753795367065},{"_id":"public/2025/07/12/快读快写模板/index.html","hash":"76fb97d1d1dee9c1b5fdbecc4267f33eff9111ee","modified":1753795367065},{"_id":"public/2025/07/10/最短路/index.html","hash":"fceeaaf7a6e2b4e882322314aacfd262dbcd88f7","modified":1753795367065},{"_id":"public/2025/07/10/最小生成树/index.html","hash":"a40286d4213816d6fae819c43e54ae0df75c3889","modified":1753795367065},{"_id":"public/archives/index.html","hash":"1595231367882912075ac4e08192540751a478fe","modified":1753795049938},{"_id":"public/archives/2025/index.html","hash":"5a1d1827b811f87d15959ea41c02f2b3743c7825","modified":1753795049938},{"_id":"public/archives/2025/07/index.html","hash":"4b281bbe47a525a91e989d52893e3486b7bf90ab","modified":1753795049938},{"_id":"public/categories/学习/index.html","hash":"b0bd9f257a2559cf8a32690f0e5ed609c52f21a3","modified":1753795049938},{"_id":"public/categories/学习/分享/index.html","hash":"4b40deabc907ffe0f3d317c313705ece9b1faed5","modified":1753795049938},{"_id":"public/tags/OI/index.html","hash":"0a504477d65fc93f4d5effa6aa3dafdda01603b2","modified":1753795049938},{"_id":"public/tags/模板/index.html","hash":"2f6dbb06b87da68bf7b54cabab843f2b23d3ce40","modified":1753795049938},{"_id":"public/tags/搜索/index.html","hash":"fab14a30aeb66daaccff9291e62ab8dc773917bf","modified":1753795049938},{"_id":"public/index.html","hash":"c5ee6ce32eabc53d7a4787507fdae8f73c511ceb","modified":1753795049938},{"_id":"public/tags/算法/index.html","hash":"4519a5713a0c4c90bf5c1dc5110b8355b226154f","modified":1753795049938},{"_id":"public/tags/图论/index.html","hash":"bf224d6645f20492a1e2ab245cf365f692ba46d2","modified":1753795049938},{"_id":"public/tags/最小生成树/index.html","hash":"60f7f443e3c65a2160b3c4e61d906e02237f849f","modified":1753795049938},{"_id":"public/tags/最短路/index.html","hash":"0406e59cf0a16a7710313f0994bc41f910b18300","modified":1753795049938},{"_id":"public/categories/index.html","hash":"37ac253af935dde2f7fc511a5fb539093e740a0a","modified":1753795049938},{"_id":"public/notebooks/index.html","hash":"ddebf573026f25e9267a979ac30750eb801115d5","modified":1753791175513},{"_id":"public/tags/存储/index.html","hash":"e81d39e58f10c063fe71d69eb27bd96c545a9aee","modified":1753795049938},{"_id":"public/scsn/index.html","hash":"2ccfc5bc799f763a9f398fbf29f5f8c3d2156baf","modified":1753795049938},{"_id":"public/tags/index.html","hash":"9be1cb6cae1eab12a4ee99f9f657d3e6db05583e","modified":1753795049938},{"_id":"public/css/main.css","hash":"2a5c0888797df8913c77028293f38b48968d4ddf","modified":1753790547787},{"_id":"public/js/main.js","hash":"e702e941a62bf081e9209fdc20d0f5873e9eb902","modified":1753790547787},{"_id":"public/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1753790547787},{"_id":"public/js/plugins/video.js","hash":"e87d271175dfb4763c9c017046f7d857c7a3ba56","modified":1753790547787},{"_id":"public/js/plugins/download-file.js","hash":"6bd0cc2f31164406013313543cb04f9ab3cd2452","modified":1753790547787},{"_id":"public/js/plugins/voice.js","hash":"4c865125754c98dd61de28ad88c831be3d673a35","modified":1753790547787},{"_id":"public/js/search/algolia-search.js","hash":"94dae768b275b12753553553b3338fca4973a1e3","modified":1753790547787},{"_id":"public/js/search/local-search.js","hash":"d54e8d53e22875faa0e360fc7827f6f9dd068276","modified":1753790547787},{"_id":"public/js/services/contributors.js","hash":"be5c8ae1055696a0da9c5552fce20c120b2eb584","modified":1753790547787},{"_id":"public/js/services/fcircle.js","hash":"a684b276713a1c6f07817de9b70744c1a5c745ea","modified":1753790547787},{"_id":"public/js/services/artalk_latest_comment.js","hash":"31acb9a3587aa3012569969675c17645b7722f1f","modified":1753790547787},{"_id":"public/js/services/friends.js","hash":"6b30960a86ce11998c1861cfe3b7a9ecdc28259f","modified":1753790547787},{"_id":"public/js/services/friends_and_posts.js","hash":"0ce8b46873e21e778b315e6c190387cdd1e1e107","modified":1753790547787},{"_id":"public/js/services/giscus_latest_comment.js","hash":"b1f0f1a5941a4fdd20fc53444fd4fa6e58b0088e","modified":1753790547787},{"_id":"public/js/services/mdrender.js","hash":"cf90dd3f4aa37b1131fb871ec1a78eff96f2a861","modified":1753790547787},{"_id":"public/js/services/ghinfo.js","hash":"693acbabc79426bf276dd3072f40b2d9a98ee026","modified":1753790547787},{"_id":"public/js/services/memos.js","hash":"9ecffb14c952d903b21bf2184179868837f74ffa","modified":1753790547787},{"_id":"public/js/services/rating.js","hash":"19e8db4f26af6e656074bebda53d9a00216a0d31","modified":1753790547787},{"_id":"public/js/services/siteinfo.js","hash":"e484765fdcabdbbeabf2062baf6ccb94d7ba777f","modified":1753790547787},{"_id":"public/js/services/timeline.js","hash":"43e225ee469d10efe22cae965483a0dabd13388c","modified":1753790547787},{"_id":"public/js/services/sites.js","hash":"f05d40a3476c796ed9e142ec2d1de15a8d1aef92","modified":1753790547787},{"_id":"public/js/services/twikoo_latest_comment.js","hash":"4e9a18f32faa168b5fd1465d91df67ae3cdde6bf","modified":1753790547787},{"_id":"public/js/services/vote.js","hash":"0fdef6519fa2528f2ffd3b38272955d8469a8b2e","modified":1753790547787},{"_id":"public/js/services/waline_latest_comment.js","hash":"25ed1f668161941869e5effd4fbb408846c6deae","modified":1753790547787},{"_id":"public/js/services/weibo.js","hash":"144200d261c85b4f353243afc1f50003bdf23a93","modified":1753790547787},{"_id":"source/notebooks/scsn/单调栈和单调队列.md","hash":"388d4b07aa6f295958c6c148ac639020dc7f4c14","modified":1753795034893},{"_id":"public/notebooks/scsn/单调栈和单调队列/index.html","hash":"b55bfa7bbdd5d7760aaed2b5fbe174dbfd0001a0","modified":1753795367065},{"_id":"public/scsn/tags/数据提高班/index.html","hash":"6cfdc6d3a1fd1858fab39ca9fd2a9c13e8fe3a2d","modified":1753795049938}],"Category":[{"name":"学习","_id":"cmdohm0nd0004zgboa1t64orb"},{"name":"分享","parent":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0oe000fzgbo14prb8ul"}],"Data":[{"_id":"links/qpoem","data":[{"title":"量子诗笺","url":"https://qpoem.org.cn","cover":"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png","icon":"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png","description":"代码如量子般跳跃，书写在诗笺上的每一行都是对未来的预言。"}]},{"_id":"notebooks/scsn","data":{"name":"夏令营学习笔记","title":"Summer Camping Study Note","description":"这是一本用来记录夏令营学习笔记的笔记本","base_dir":"/scsn/","sort":1,"per_page":10,"license":true,"menu_id":"scsn","leftbar":["tagtree"],"rightbar":[],"note_leftbar":["tagtree"],"note_rightbar":["toc"]}}],"Page":[{"menu_id":"about","title":"关于我","_content":"\n我写的不好，大部分都是直接搬运 [Luogu 主页](https://www.luogu.com.cn/user/1023494) 的。\n\n<!-- more -->\n\n![](https://cards.jerryz.com.cn/api?img=2&counter=ED_Builder&date=2025-10-22&str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&quote=Loves+star+forever&qq=2100553299&site=ED-Builder.top&email=ED-Builder%40outlook.com&gitee=ED_Builder&bilibili=ED_Builder&google=edbuilder398%40gmail.com&microsoft=ED-Builder%40outlook.com&luogu=ED_Builder&codeforces=ED_Builder&linuxdo=ED_Builder&bg=255%2C255%2C255%2C0.8)\n### 关于我\n- 一个 [ISTJ-T](https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC)\n- 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）\n- 一个尽力学习的 OIer\n- 一个用私人服务器的 Arcaea 玩家（PTT = 11.08）\n- 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）\n- 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）\n- 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）\n### 我的参与\n- 现任 [量子诗笺](https://qpoem.org.cn) 技术站长\n- [生物死刑网站](https://github.com/FishLucky/Lucky-Entity) 主要开发者\n- 欢迎来使用 [ED-ImgHub](https://imghub.ed-builder.top) 和 [ED-Comment](https://comment.api.ed-builder.top)","source":"about/index.md","raw":"---\nmenu_id: about\ntitle: 关于我\n---\n\n我写的不好，大部分都是直接搬运 [Luogu 主页](https://www.luogu.com.cn/user/1023494) 的。\n\n<!-- more -->\n\n![](https://cards.jerryz.com.cn/api?img=2&counter=ED_Builder&date=2025-10-22&str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&quote=Loves+star+forever&qq=2100553299&site=ED-Builder.top&email=ED-Builder%40outlook.com&gitee=ED_Builder&bilibili=ED_Builder&google=edbuilder398%40gmail.com&microsoft=ED-Builder%40outlook.com&luogu=ED_Builder&codeforces=ED_Builder&linuxdo=ED_Builder&bg=255%2C255%2C255%2C0.8)\n### 关于我\n- 一个 [ISTJ-T](https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC)\n- 一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）\n- 一个尽力学习的 OIer\n- 一个用私人服务器的 Arcaea 玩家（PTT = 11.08）\n- 一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）\n- 一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）\n- 一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）\n### 我的参与\n- 现任 [量子诗笺](https://qpoem.org.cn) 技术站长\n- [生物死刑网站](https://github.com/FishLucky/Lucky-Entity) 主要开发者\n- 欢迎来使用 [ED-ImgHub](https://imghub.ed-builder.top) 和 [ED-Comment](https://comment.api.ed-builder.top)","date":"2025-07-29T11:44:20.064Z","updated":"2025-07-29T11:44:20.064Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmdohm0mf0000zgboecqd2ltg","content":"<p>我写的不好，大部分都是直接搬运 <a href=\"https://www.luogu.com.cn/user/1023494\">Luogu 主页</a> 的。</p>\n<span id=\"more\"></span>\n<p><img src=\"https://cards.jerryz.com.cn/api?img=2&amp;counter=ED_Builder&amp;date=2025-10-22&amp;str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&amp;quote=Loves+star+forever&amp;qq=2100553299&amp;site=ED-Builder.top&amp;email=ED-Builder%40outlook.com&amp;gitee=ED_Builder&amp;bilibili=ED_Builder&amp;google=edbuilder398%40gmail.com&amp;microsoft=ED-Builder%40outlook.com&amp;luogu=ED_Builder&amp;codeforces=ED_Builder&amp;linuxdo=ED_Builder&amp;bg=255%2C255%2C255%2C0.8\" alt=\"\" /></p>\n<h3 id=\"关于我\"><a class=\"markdownIt-Anchor\" href=\"#关于我\"></a> 关于我</h3>\n<ul>\n<li>一个 <a href=\"https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC\">ISTJ-T</a></li>\n<li>一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）</li>\n<li>一个尽力学习的 OIer</li>\n<li>一个用私人服务器的 Arcaea 玩家（PTT = 11.08）</li>\n<li>一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）</li>\n<li>一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）</li>\n<li>一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）</li>\n</ul>\n<h3 id=\"我的参与\"><a class=\"markdownIt-Anchor\" href=\"#我的参与\"></a> 我的参与</h3>\n<ul>\n<li>现任 <a href=\"https://qpoem.org.cn\">量子诗笺</a> 技术站长</li>\n<li><a href=\"https://github.com/FishLucky/Lucky-Entity\">生物死刑网站</a> 主要开发者</li>\n<li>欢迎来使用 <a href=\"https://imghub.ed-builder.top\">ED-ImgHub</a> 和 <a href=\"https://comment.api.ed-builder.top\">ED-Comment</a></li>\n</ul>\n","excerpt":"<p>我写的不好，大部分都是直接搬运 <a href=\"https://www.luogu.com.cn/user/1023494\">Luogu 主页</a> 的。</p>","more":"<p><img src=\"https://cards.jerryz.com.cn/api?img=2&amp;counter=ED_Builder&amp;date=2025-10-22&amp;str=%E5%92%95%E5%92%95%E7%9A%84%E7%94%9F%E6%97%A5&amp;quote=Loves+star+forever&amp;qq=2100553299&amp;site=ED-Builder.top&amp;email=ED-Builder%40outlook.com&amp;gitee=ED_Builder&amp;bilibili=ED_Builder&amp;google=edbuilder398%40gmail.com&amp;microsoft=ED-Builder%40outlook.com&amp;luogu=ED_Builder&amp;codeforces=ED_Builder&amp;linuxdo=ED_Builder&amp;bg=255%2C255%2C255%2C0.8\" alt=\"\" /></p>\n<h3 id=\"关于我\"><a class=\"markdownIt-Anchor\" href=\"#关于我\"></a> 关于我</h3>\n<ul>\n<li>一个 <a href=\"https://www.16personalities.com/ch/istj-%E4%BA%BA%E6%A0%BC\">ISTJ-T</a></li>\n<li>一个尽力推 RKS 的 Phigros 玩家（RKS = 15.02）</li>\n<li>一个尽力学习的 OIer</li>\n<li>一个用私人服务器的 Arcaea 玩家（PTT = 11.08）</li>\n<li>一个用私人服务器的 Paradigm:Reboot 玩家（刚入坑，Rating D）</li>\n<li>一个尽力推 RLT 的 Milthm 玩家（RLT = 11.57）</li>\n<li>一个用私人服务器的 Rotaeno 玩家（2025/05/24 晚 10:00 入坑，拿着板子晃来晃去太累了）</li>\n</ul>\n<h3 id=\"我的参与\"><a class=\"markdownIt-Anchor\" href=\"#我的参与\"></a> 我的参与</h3>\n<ul>\n<li>现任 <a href=\"https://qpoem.org.cn\">量子诗笺</a> 技术站长</li>\n<li><a href=\"https://github.com/FishLucky/Lucky-Entity\">生物死刑网站</a> 主要开发者</li>\n<li>欢迎来使用 <a href=\"https://imghub.ed-builder.top\">ED-ImgHub</a> 和 <a href=\"https://comment.api.ed-builder.top\">ED-Comment</a></li>\n</ul>"},{"_content":"{% friends qpoem %}","source":"friends/index.md","raw":"{% friends qpoem %}","date":"2025-07-29T11:44:20.064Z","updated":"2025-07-29T11:44:20.064Z","path":"friends/index.html","title":"","comments":1,"layout":"page","_id":"cmdohm0n50002zgbo92yr2qpp","content":"<div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://qpoem.org.cn\"><div class=\"lazy-box icon\"><img class=\"lazy\" data-src=\"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"lazy-icon\" style=\"background-image:url(&quot;https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd&quot;);\"></div></div><div class=\"name\"><span>量子诗笺</span></div></a></div></div></div>","excerpt":"","more":"<div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://qpoem.org.cn\"><div class=\"lazy-box icon\"><img class=\"lazy\" data-src=\"https://qpoem.org.cn/assets/favicon-kdwmmsrt.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"lazy-icon\" style=\"background-image:url(&quot;https://api.iconify.design/eos-icons:three-dots-loading.svg?color=%231cd0fd&quot;);\"></div></div><div class=\"name\"><span>量子诗笺</span></div></a></div></div></div>"},{"notebook":"scsn","title":"Summer Camping Study Note","_content":"\n这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。","source":"notebooks/scsn/index.md","raw":"---\nnotebook: scsn\ntitle: Summer Camping Study Note\n---\n\n这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。","date":"2025-07-29T12:04:50.054Z","updated":"2025-07-29T12:04:50.054Z","path":"notebooks/scsn/index.html","_id":"cmdohm0nl0006zgbodyl36se8","comments":1,"layout":"page","content":"<p>这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。</p>\n","excerpt":"","more":"<p>这里是夏令营学习笔记的总目录，整合了 2025/07/21 到 2025/07/28 的学习笔记。内容包括数据基础班和数据提高班的知识点。</p>\n"},{"notebook":"scsn","title":"单调栈和单调队列","tags":["数据提高班"],"_content":"\n## 算法分析\n|数据结构|时间复杂度|空间复杂度|典型用途|\n|:-:|:-:|:-:|:-:|\n|单调栈|$O(n)$|$O(n)$|找下一个更大 / 更小元素|\n|单调队列|$O(n)$|$O(n)$|滑动窗口最大 / 最小值|\n\n## 单调栈\n单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。  \n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。\n### 思路\n- 使用一个栈 `sta`，栈中存储的是“候选元素”的下标（下同）。\n- 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。\n- 遍历数组 `A`：\n  1. 当 `A[i]` 大于栈顶元素 `A[sta.top()]` 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。\n  2. 重复上述步骤直到栈空或 `A[i] <= A[sta.top()]`。\n  3. 将当前下标 `i` 入栈。\n- 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。\n### 代码示例\n例题：[Luogu P5788 - 【模板】单调栈](https://luogu.com.cn/problem/P5788)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=3e6+5;\nint a[LEN],f[LEN];\nint n;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    stack<int> sta;//存储下标\n    for(int i=1;i<=n;i++)\n    {\n        //找到一个更大的元素下标\n        while(!sta.empty()&&a[i]>a[sta.top()])\n        {\n            f[sta.top()]=i;\n            sta.pop();//维护单调性\n        }\n        sta.push(i);\n    }\n    for(int i=1;i<=n;i++)  cout<<f[i]<<' ';\n    return 0;\n}\n\n```\n\n---\n## 单调队列\n单调队列通常用来维护滑动窗口中的最大值或最小值，以 **O(1)** 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。\n### 思路\n- 使用 `deque<int> dq`，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。\n- 遍历数组 `A`，下标为 `i`：\n  1. 如果队头 `dq.front()` 已经滑出窗口范围（`i - dq.front() >= k`），则 `dq.pop_front()`。\n  2. 将当前元素与队尾元素比较，若 `A[i]` 大于等于 `A[dq.back()]`，弹出队尾，直到队尾大于当前元素。\n  3. 将 `i` 推入队尾。\n  4. 当窗口形成（`i >= k-1`）时，队头即为窗口最大值下标，记录 `A[dq.front()]`。\n\n### 代码示例\n例题：[Luogu P1886 - 滑动窗口 /【模板】单调队列](https://luogu.com.cn/problem/P1886)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=1e6+5;\nint a[LEN],n,k;\n//单调递增队列求最小值\nvoid getMin()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递增性：弹出比当前值大的队尾元素\n        while(!dq.empty()&&a[dq.back()]>a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        //输出窗口最小值\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\n//单调递减队列求最大值\nvoid getMax()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递减性：弹出比当前值小的队尾元素\n        while(!dq.empty()&&a[dq.back()]<a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\nint main()\n{\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    getMin();//输出每个窗口的最小值\n    cout<<endl;\n    getMax();//输出每个窗口的最大值\n    return 0;\n}\n\n```\n\n---\n## 小结\n- 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。\n- 单调队列主要用于“滑动窗口”相关最大/最小值。\n- 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","source":"notebooks/scsn/单调栈和单调队列.md","raw":"---\nnotebook: scsn\ntitle: 单调栈和单调队列\ntags: [数据提高班]\n---\n\n## 算法分析\n|数据结构|时间复杂度|空间复杂度|典型用途|\n|:-:|:-:|:-:|:-:|\n|单调栈|$O(n)$|$O(n)$|找下一个更大 / 更小元素|\n|单调队列|$O(n)$|$O(n)$|滑动窗口最大 / 最小值|\n\n## 单调栈\n单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。  \n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。\n### 思路\n- 使用一个栈 `sta`，栈中存储的是“候选元素”的下标（下同）。\n- 栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。\n- 遍历数组 `A`：\n  1. 当 `A[i]` 大于栈顶元素 `A[sta.top()]` 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。\n  2. 重复上述步骤直到栈空或 `A[i] <= A[sta.top()]`。\n  3. 将当前下标 `i` 入栈。\n- 最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。\n### 代码示例\n例题：[Luogu P5788 - 【模板】单调栈](https://luogu.com.cn/problem/P5788)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=3e6+5;\nint a[LEN],f[LEN];\nint n;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    stack<int> sta;//存储下标\n    for(int i=1;i<=n;i++)\n    {\n        //找到一个更大的元素下标\n        while(!sta.empty()&&a[i]>a[sta.top()])\n        {\n            f[sta.top()]=i;\n            sta.pop();//维护单调性\n        }\n        sta.push(i);\n    }\n    for(int i=1;i<=n;i++)  cout<<f[i]<<' ';\n    return 0;\n}\n\n```\n\n---\n## 单调队列\n单调队列通常用来维护滑动窗口中的最大值或最小值，以 **O(1)** 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。\n### 思路\n- 使用 `deque<int> dq`，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。\n- 遍历数组 `A`，下标为 `i`：\n  1. 如果队头 `dq.front()` 已经滑出窗口范围（`i - dq.front() >= k`），则 `dq.pop_front()`。\n  2. 将当前元素与队尾元素比较，若 `A[i]` 大于等于 `A[dq.back()]`，弹出队尾，直到队尾大于当前元素。\n  3. 将 `i` 推入队尾。\n  4. 当窗口形成（`i >= k-1`）时，队头即为窗口最大值下标，记录 `A[dq.front()]`。\n\n### 代码示例\n例题：[Luogu P1886 - 滑动窗口 /【模板】单调队列](https://luogu.com.cn/problem/P1886)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=1e6+5;\nint a[LEN],n,k;\n//单调递增队列求最小值\nvoid getMin()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递增性：弹出比当前值大的队尾元素\n        while(!dq.empty()&&a[dq.back()]>a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        //输出窗口最小值\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\n//单调递减队列求最大值\nvoid getMax()\n{\n    deque<int> dq;\n    for(int i=1;i<=n;i++)\n    {\n        //队头元素是否滑出窗口\n        if(!dq.empty()&&dq.front()<=i-k)  dq.pop_front();\n\n        //维护递减性：弹出比当前值小的队尾元素\n        while(!dq.empty()&&a[dq.back()]<a[i])  dq.pop_back();\n\n        dq.push_back(i);\n\n        if(i>=k)  cout<<a[dq.front()]<<' ';\n    }\n}\nint main()\n{\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>a[i];\n    getMin();//输出每个窗口的最小值\n    cout<<endl;\n    getMax();//输出每个窗口的最大值\n    return 0;\n}\n\n```\n\n---\n## 小结\n- 单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。\n- 单调队列主要用于“滑动窗口”相关最大/最小值。\n- 维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。","date":"2025-07-29T13:17:14.893Z","updated":"2025-07-29T13:17:14.893Z","path":"notebooks/scsn/单调栈和单调队列.html","_id":"cmdohrsm50000awbo41hb7n6s","comments":1,"layout":"page","content":"<h2 id=\"算法分析\"><a class=\"markdownIt-Anchor\" href=\"#算法分析\"></a> 算法分析</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单调栈</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">找下一个更大 / 更小元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单调队列</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">滑动窗口最大 / 最小值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h2>\n<p>单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。<br />\n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<ul>\n<li>使用一个栈 <code>sta</code>，栈中存储的是“候选元素”的下标（下同）。</li>\n<li>栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。</li>\n<li>遍历数组 <code>A</code>：\n<ol>\n<li>当 <code>A[i]</code> 大于栈顶元素 <code>A[sta.top()]</code> 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。</li>\n<li>重复上述步骤直到栈空或 <code>A[i] &lt;= A[sta.top()]</code>。</li>\n<li>将当前下标 <code>i</code> 入栈。</li>\n</ol>\n</li>\n<li>最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。</li>\n</ul>\n<h3 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P5788\">Luogu P5788 - 【模板】单调栈</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">3e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],f[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; sta;<span class=\"comment\">//存储下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到一个更大的元素下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!sta.<span class=\"built_in\">empty</span>()&amp;&amp;a[i]&gt;a[sta.<span class=\"built_in\">top</span>()])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[sta.<span class=\"built_in\">top</span>()]=i;</span><br><span class=\"line\">            sta.<span class=\"built_in\">pop</span>();<span class=\"comment\">//维护单调性</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sta.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;f[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h2>\n<p>单调队列通常用来维护滑动窗口中的最大值或最小值，以 <strong>O(1)</strong> 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<ul>\n<li>使用 <code>deque&lt;int&gt; dq</code>，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。</li>\n<li>遍历数组 <code>A</code>，下标为 <code>i</code>：\n<ol>\n<li>如果队头 <code>dq.front()</code> 已经滑出窗口范围（<code>i - dq.front() &gt;= k</code>），则 <code>dq.pop_front()</code>。</li>\n<li>将当前元素与队尾元素比较，若 <code>A[i]</code> 大于等于 <code>A[dq.back()]</code>，弹出队尾，直到队尾大于当前元素。</li>\n<li>将 <code>i</code> 推入队尾。</li>\n<li>当窗口形成（<code>i &gt;= k-1</code>）时，队头即为窗口最大值下标，记录 <code>A[dq.front()]</code>。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P1886\">Luogu P1886 - 滑动窗口 /【模板】单调队列</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],n,k;</span><br><span class=\"line\"><span class=\"comment\">//单调递增队列求最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递增性：弹出比当前值大的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&gt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出窗口最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//单调递减队列求最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMax</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递减性：弹出比当前值小的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&lt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">getMin</span>();<span class=\"comment\">//输出每个窗口的最小值</span></span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">getMax</span>();<span class=\"comment\">//输出每个窗口的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h2>\n<ul>\n<li>单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。</li>\n<li>单调队列主要用于“滑动窗口”相关最大/最小值。</li>\n<li>维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"算法分析\"><a class=\"markdownIt-Anchor\" href=\"#算法分析\"></a> 算法分析</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据结构</th>\n<th style=\"text-align:center\">时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">典型用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">单调栈</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">找下一个更大 / 更小元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单调队列</td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></td>\n<td style=\"text-align:center\">滑动窗口最大 / 最小值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"单调栈\"><a class=\"markdownIt-Anchor\" href=\"#单调栈\"></a> 单调栈</h2>\n<p>单调栈是一种在栈内部维持元素单调性的技巧，常用于求“每个元素的下一个更大/更小元素”等问题。<br />\n单调栈即要求栈内元素具有单调性（单调递增/单调递减/单调不增/单调不降），并且同时优先保留后加入的元素。</p>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\"></a> 思路</h3>\n<ul>\n<li>使用一个栈 <code>sta</code>，栈中存储的是“候选元素”的下标（下同）。</li>\n<li>栈内元素按值单调递增（或递减）。以“找下一个更大元素”为例，栈内维护单调递增。</li>\n<li>遍历数组 <code>A</code>：\n<ol>\n<li>当 <code>A[i]</code> 大于栈顶元素 <code>A[sta.top()]</code> 时，说明栈顶元素找到了它的下一个更大值，弹出栈顶并记录答案。</li>\n<li>重复上述步骤直到栈空或 <code>A[i] &lt;= A[sta.top()]</code>。</li>\n<li>将当前下标 <code>i</code> 入栈。</li>\n</ol>\n</li>\n<li>最后栈中剩余元素没有下一个更大值，可统一置为 -1 或其他默认值。</li>\n</ul>\n<h3 id=\"代码示例\"><a class=\"markdownIt-Anchor\" href=\"#代码示例\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P5788\">Luogu P5788 - 【模板】单调栈</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">3e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],f[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; sta;<span class=\"comment\">//存储下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到一个更大的元素下标</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!sta.<span class=\"built_in\">empty</span>()&amp;&amp;a[i]&gt;a[sta.<span class=\"built_in\">top</span>()])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            f[sta.<span class=\"built_in\">top</span>()]=i;</span><br><span class=\"line\">            sta.<span class=\"built_in\">pop</span>();<span class=\"comment\">//维护单调性</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sta.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;f[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"单调队列\"><a class=\"markdownIt-Anchor\" href=\"#单调队列\"></a> 单调队列</h2>\n<p>单调队列通常用来维护滑动窗口中的最大值或最小值，以 <strong>O(1)</strong> 均摊复杂度取窗口值。常见场景是“滑动窗口最大值”和“滑动窗口最小值”。</p>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\"></a> 思路</h3>\n<ul>\n<li>使用 <code>deque&lt;int&gt; dq</code>，存储窗口内的下标，并保持队列内对应的值单调递减（以求最大值为例）。</li>\n<li>遍历数组 <code>A</code>，下标为 <code>i</code>：\n<ol>\n<li>如果队头 <code>dq.front()</code> 已经滑出窗口范围（<code>i - dq.front() &gt;= k</code>），则 <code>dq.pop_front()</code>。</li>\n<li>将当前元素与队尾元素比较，若 <code>A[i]</code> 大于等于 <code>A[dq.back()]</code>，弹出队尾，直到队尾大于当前元素。</li>\n<li>将 <code>i</code> 推入队尾。</li>\n<li>当窗口形成（<code>i &gt;= k-1</code>）时，队头即为窗口最大值下标，记录 <code>A[dq.front()]</code>。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"代码示例-2\"><a class=\"markdownIt-Anchor\" href=\"#代码示例-2\"></a> 代码示例</h3>\n<p>例题：<a href=\"https://luogu.com.cn/problem/P1886\">Luogu P1886 - 滑动窗口 /【模板】单调队列</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[LEN],n,k;</span><br><span class=\"line\"><span class=\"comment\">//单调递增队列求最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递增性：弹出比当前值大的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&gt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//输出窗口最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//单调递减队列求最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">getMax</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//队头元素是否滑出窗口</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;dq.<span class=\"built_in\">front</span>()&lt;=i-k)  dq.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//维护递减性：弹出比当前值小的队尾元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!dq.<span class=\"built_in\">empty</span>()&amp;&amp;a[dq.<span class=\"built_in\">back</span>()]&lt;a[i])  dq.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        dq.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=k)  cout&lt;&lt;a[dq.<span class=\"built_in\">front</span>()]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;a[i];</span><br><span class=\"line\">    <span class=\"built_in\">getMin</span>();<span class=\"comment\">//输出每个窗口的最小值</span></span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"built_in\">getMax</span>();<span class=\"comment\">//输出每个窗口的最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<hr />\n<h2 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h2>\n<ul>\n<li>单调栈解决“下一个更大/更小元素”、直方图最大矩形等问题。</li>\n<li>单调队列主要用于“滑动窗口”相关最大/最小值。</li>\n<li>维护方式：逐个元素进来时，先弹出不符合单调原则的元素，再将当前下标压入；必要时再弹出过期元素。</li>\n</ul>\n"}],"Post":[{"title":"快读快写模板","date":"2025-07-12T07:36:30.000Z","poster":{"headline":"快读快写模板","topic":"持续更新中..."},"katex":true,"author":"ED_Builder","_content":"\n本文整理了在 OI 中可以提升读写速度的模板，持续更新中...\n\n<!-- more -->\n\n### 整型快读快写模板\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline void read(int& a)\n{\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n        if(ch=='-')  w=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n        s=s*10+ch-'0';\n        ch=getchar();\n    }\n    a=s*w;\n    return;\n}\ninline void write(int x)\n{\n    static int sta[10];\n    int top=0;\n    do\n    {\n        sta[top++]=x%10;\n        x/=10;\n    }while(x);\n    while(top)  putchar(sta[--top]+'0');\n    //putchar(' '); //可选的行末空格\n    //putchar('\\n'); //可选的行末换行\n    return;\n}\nsigned main()\n{\n    int a,b;\n    read(a);\n    read(b);\n    write(a+b);\n    return 0;\n}\n```","source":"_posts/快读快写模板.md","raw":"---\ntitle: 快读快写模板\ndate: 2025-07-12 15:36:30\ntags: ['OI', '模板']\ncategories: ['学习', '分享']\nposter:\n    headline: 快读快写模板\n    topic: 持续更新中...\nkatex: true\nauthor: ED_Builder\n---\n\n本文整理了在 OI 中可以提升读写速度的模板，持续更新中...\n\n<!-- more -->\n\n### 整型快读快写模板\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline void read(int& a)\n{\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n        if(ch=='-')  w=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n        s=s*10+ch-'0';\n        ch=getchar();\n    }\n    a=s*w;\n    return;\n}\ninline void write(int x)\n{\n    static int sta[10];\n    int top=0;\n    do\n    {\n        sta[top++]=x%10;\n        x/=10;\n    }while(x);\n    while(top)  putchar(sta[--top]+'0');\n    //putchar(' '); //可选的行末空格\n    //putchar('\\n'); //可选的行末换行\n    return;\n}\nsigned main()\n{\n    int a,b;\n    read(a);\n    read(b);\n    write(a+b);\n    return 0;\n}\n```","slug":"快读快写模板","published":1,"updated":"2025-07-29T11:44:20.061Z","comments":1,"layout":"post","photos":[],"_id":"cmdohm0mr0001zgbogrhhg106","content":"<p>本文整理了在 OI 中可以提升读写速度的模板，持续更新中…</p>\n<span id=\"more\"></span>\n<h3 id=\"整型快读快写模板\"><a class=\"markdownIt-Anchor\" href=\"#整型快读快写模板\"></a> 整型快读快写模板</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>,w=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">&#x27;0&#x27;</span>||ch&gt;<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">&#x27;-&#x27;</span>)  w=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+ch-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a=s*w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> sta[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sta[top++]=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top)  <span class=\"built_in\">putchar</span>(sta[--top]+<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27; &#x27;); //可选的行末空格</span></span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27;\\n&#x27;); //可选的行末换行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(b);</span><br><span class=\"line\">    <span class=\"built_in\">write</span>(a+b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文整理了在 OI 中可以提升读写速度的模板，持续更新中…</p>","more":"<h3 id=\"整型快读快写模板\"><a class=\"markdownIt-Anchor\" href=\"#整型快读快写模板\"></a> 整型快读快写模板</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s=<span class=\"number\">0</span>,w=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&lt;<span class=\"string\">&#x27;0&#x27;</span>||ch&gt;<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">&#x27;-&#x27;</span>)  w=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ch&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        s=s*<span class=\"number\">10</span>+ch-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        ch=<span class=\"built_in\">getchar</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    a=s*w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> sta[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> top=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sta[top++]=x%<span class=\"number\">10</span>;</span><br><span class=\"line\">        x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(x);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(top)  <span class=\"built_in\">putchar</span>(sta[--top]+<span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27; &#x27;); //可选的行末空格</span></span><br><span class=\"line\">    <span class=\"comment\">//putchar(&#x27;\\n&#x27;); //可选的行末换行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">read</span>(b);</span><br><span class=\"line\">    <span class=\"built_in\">write</span>(a+b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"搜索题目整理","date":"2025-07-12T07:36:30.000Z","banner":"https://imghub.ed-builder.top/file/2JkPK8tN.jpeg","cover":"https://imghub.ed-builder.top/file/2JkPK8tN.jpeg","poster":{"headline":"搜索题目整理","topic":"只是基础的搜索而已，没有什么图上搜索之类的高阶算法"},"katex":true,"author":"ED_Builder","_content":"\n本文整理了 ED_Builder 在初学搜索算法时做的题目\n\n<!-- more -->\n\n# DFS\n## [P1219](https://luogu.com.cn/problem/P1219) 八皇后\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案\nbool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问\nvoid print()//输出答案\n{\n    if(ans>3)  return;//由题可得,只需要输出 3 种排列\n    for(int i=1;i<=n;i++)  cout<<a[i]<<' ';\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)//形参 x :当前是第 x 个皇后\n{\n    if(x>n)//一种可行的方案达成\n    {\n        ans++;//方案数++\n        print();//输出答案\n        return;\n    }\n    for(int i=1;i<=n;i++)//枚举所有答案\n    {\n        if(!vis_lie[i]&&!vis_l[x-i+n]&&!vis_r[x+i])//是否被访问过(规律见 L40 )\n        {\n            vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记\n            a[x]=i;//存答案\n            dfs(x+1);//继续递归\n            vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n\n/*\n对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界\n对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等\n*/\n```\n## [P1706](https://luogu.com.cn/problem/P1706) 全排列问题\n### P1 - DFS\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20];//枚举 n 个数字,可行的答案存放在 a 中\nbool vis[20];//已经被访问过的\nvoid print()//输出答案\n{\n    for(int i=1;i<=n;i++)  cout<<setw(5)<<a[i];\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)\n{\n    if(x>n)//已经有了一个方案\n    {\n        print();\n        return;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i])//没被访问\n        {\n            a[x]=i;//记录答案\n            vis[i]=true;//标记\n            dfs(x+1);//继续递归\n            vis[i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);//从 1 开始\n    return 0;\n}\n```\n### P2 - 枚举优化\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint num[n];\n\tfor(int i=1;i<=n;i++)  num[i]=i;\n\tdo\n\t{\n\t\tfor(int i=1;i<=n;i++)  cout<<setw(5)<<num[i];\n\t\tcout<<endl;\n\t}while(next_permutation(num+1,num+1+n));\n\treturn 0;\n}\n```\n## [P1605](https://luogu.com.cn/problem/P1605) 迷宫\n```cpp\n#include<iostream>\n#include<cstring>//这里不用万能头是因为想用 map 当变量名\nusing namespace std;\nint n,m,t,sx,sy,fx,fy,ans;\n//地图长宽,障碍数量,起点坐标,终点坐标,答案\nint dx[5]={1,0,-1,0},dy[5]={0,-1,0,1};//位移\nbool map[10][10];//地图\nvoid dfs(int x,int y)\n{\n    if(x==fx&&y==fy)//到达终点\n    {\n        ans++;\n        return;\n    }\n    for(int i=0;i<4;i++)//枚举位移\n    {\n        int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动\n        if(tmp_x>=1&&tmp_x<=n&&tmp_y>=1&&tmp_y<=m&&map[tmp_x][tmp_y])\n        //合法判断:坐标未越界,位置可用(没有障碍且没被访问)\n        {\n            map[tmp_x][tmp_y]=false;//标记访问\n            dfs(tmp_x,tmp_y);//继续递归\n            map[tmp_x][tmp_y]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(map,true,sizeof(map));//初始化\n    cin>>n>>m>>t>>sx>>sy>>fx>>fy;\n    for(int i=1;i<=t;i++)//读入障碍\n    {\n        int x,y;\n        cin>>x>>y;\n        map[x][y]=false;//不能走\n    }\n    map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!\n    dfs(sx,sy);\n    cout<<ans;\n    return 0;\n}\n```\n## [P1036](https://luogu.com.cn/problem/P1036) 选数\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案\nbool vis[25];//是否已经被选择\nbool check_prime(int n)//判断质数\n{\n    if(n<=1)  return false;\n    for(int i=2;i<=sqrt(n);i++)\n        if(n%i==0)  return false;\n    return true;\n}\nvoid dfs(int pos,int cnt,int sum)\n{\n    if(cnt>=k)//选完了\n    {\n        if(check_prime(sum))  ans++;//判断质数,然后答案自增\n        return;\n    }\n    for(int i=pos;i<=n;i++)\n    {\n        if(vis[i])//没被选\n        {\n            vis[i]=false;//标记\n            dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数\n            vis[i]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(vis,true,sizeof(vis));//初始化\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>x[i];\n    dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0\n    cout<<ans;\n    return 0;\n}\n```\n## [P1238](https://luogu.com.cn/problem/P1238) 走迷宫\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint m,n;// m 行 n 列 \nint mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 \nint begin_x,begin_y,end_x,end_y;//起点和终点 \nint dx[5]={0,-1,0,1},dy[5]={-1,0,1,0};//偏移\nint ans[100000][3],k;\n//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 \n\nvoid print()//输出一种答案 \n{\n\tif(have_solution==false)  have_solution=true;//更新为有解 \n\tfor(int i=0;i<k;i++)  cout<<'('<<ans[i][1]<<','<<ans[i][2]<<')'<<\"->\";\n\tcout<<'('<<end_x<<','<<end_y<<')'<<endl;\n\t//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 \n}\n\nvoid dfs(int x,int y)\n{\n\tif(x==end_x&&y==end_y)//到达终点 \n\t{\n\t\tprint();//输出答案 \n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++)//枚举偏移 \n\t{\n\t\tint nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 \n\t\tif(mp[nxt_x][nxt_y]==1&&vis[nxt_x][nxt_y]==0)\n\t\t//下一步可以走并且没被访问 \n\t\t{\n\t\t\tvis[x][y]=1;//标记上一步被访问 \n\t\t\tans[k][1]=x,ans[k][2]=y;//记录可行的一步 \n\t\t\tk++;//增加指针 \n\t\t\tdfs(nxt_x,nxt_y);//继续找下一步 \n\t\t\tvis[x][y]=0;//回溯,设为未访问 \n\t\t\tk--;//倒回去 \n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin>>m>>n;\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcin>>mp[i][j];//读入地图 \n\tcin>>begin_x>>begin_y>>end_x>>end_y;//读入起点和终点 \n\tdfs(begin_x,begin_y);\n\tif(!have_solution)  cout<<-1;//没有解 \n\treturn 0;//结束 :) \n}\n```\n# BFS\n注意: **BFS 不能用于加权图**,因为 BFS 只会查找**边数最少**的路径  \n例如 100 -> 100 和 1 -> 1 -> 1 -> 1  \nBFS 会选择 100 -> 100\n\n当数据范围较小（ $\\le20$ ）时，用 DFS 也不是不可以\n## [P1746](https://luogu.com.cn/problem/P1746) 离开中山路\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point//单个点的坐标\n{\n    int x,y;\n};\nint n;\nchar map[1005][1005];\nint dis[1005][1005];//到起点的距离\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};//位移\nint start_x,start_y,final_x,final_y;//由题可得,起点和终点\nqueue<Point> q;//等待处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//压入当前点\n    dis[x][y]=0;//起点\n    while(!q.empty())//只要队列非空\n    {\n        Point t=q.front();//读取当前队头\n        q.pop();//弹出\n        for(int i=0;i<4;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>n||map[nxt_x][nxt_y]=='1'||dis[nxt_x][nxt_y]>0)  continue;\n            //判断:越界+有障碍+被访问\n\n            q.push((Point){nxt_x,nxt_y});//压入下一个点\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离\n        }\n    }\n    return;\n}\nint main()\n{\n\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>map[i][j];\n    cin>>start_x>>start_y>>final_x>>final_y;\n    bfs(start_x,start_y);\n    cout<<dis[final_x][final_y];\n    return 0;\n}\n```\n## [P1443](https://luogu.com.cn/problem/P1443) 马的遍历\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point//当前马位于的坐标\n{\n    int x,y;\n};\nint n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步\nint dx[]={2,1,-2,1,-1,2,-2,-1};\nint dy[]={1,2,1,-2,2,-1,-1,-2};//位移\nqueue<Point> q;//当前需要处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//入队处理起点\n    dis[x][y]=0;//起点已经有一个马了\n    while(!q.empty())\n    {\n        Point t=q.front();//取队头处理\n        q.pop();//弹出\n        for(int i=0;i<8;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||dis[nxt_x][nxt_y]!=-1)  continue;\n            //检查:越界+被访问\n\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1\n            q.push((Point){nxt_x,nxt_y});//继续压入新的点继续处理\n        }\n    }\n    return;\n}\nint main()\n{\n    memset(dis,-1,sizeof(dis));//初始化\n    cin>>n>>m>>x>>y;\n    bfs(x,y);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)  cout<<setw(5)<<dis[i][j];\n        cout<<endl;\n    }\n    return 0;\n}\n```\n## [P2895](https://luogu.com.cn/problem/P2895) Meteor Shower S\n耗时 2 个月的巅峰对决，但最终还是我赢了！\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=305;\nstruct Point//存储坐标的点 \n{\n    int x,y;\n};\nint m;\nint mp[LEN][LEN],dis[LEN][LEN];//地图,距离 \nint dx[]={-1,0,1,0},dy[]={0,1,0,-1};//偏移 \nqueue<Point> q;\nint bfs()\n{\n    q.push((Point){0,0});//第一个位置是 (0,0) \n    dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 \n    while(!q.empty())\n    {\n        Point now=q.front();//找到当前点 \n        q.pop();\n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置\n            if(nxt_x<0||nxt_y<0)  continue;//越界 \n            if(dis[nxt_x][nxt_y])  continue;//被访问\n            if(dis[now.x][now.y]+1>=mp[nxt_x][nxt_y])  continue;\n            //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较\n            dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 \n            q.push((Point){nxt_x,nxt_y});//压入下一个点 \n            if(mp[nxt_x][nxt_y]>1e9)  return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 \n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 \n    cin>>m;\n    while(m--)\n    {\n        int x,y,time;//坐标,流星砸下来的时间 \n        cin>>x>>y>>time;\n        mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 \n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 \n            if(nxt_x<0||nxt_x>301||nxt_y<0||nxt_y>301)  continue;//越界 \n            mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 \n        }\n    }\n    cout<<bfs();\n    exit(0);\n}\n```","source":"_posts/搜索题目整理.md","raw":"---\ntitle: 搜索题目整理\ndate: 2025-07-12 15:36:30\nbanner: https://imghub.ed-builder.top/file/2JkPK8tN.jpeg\ncover: https://imghub.ed-builder.top/file/2JkPK8tN.jpeg\ntags: ['搜索', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 搜索题目整理\n    topic: 只是基础的搜索而已，没有什么图上搜索之类的高阶算法\nkatex: true\nauthor: ED_Builder\n---\n\n本文整理了 ED_Builder 在初学搜索算法时做的题目\n\n<!-- more -->\n\n# DFS\n## [P1219](https://luogu.com.cn/problem/P1219) 八皇后\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20],ans;//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案\nbool vis_lie[30],vis_l[30],vis_r[30];//记录当前列(|),左斜(/),右斜(\\)是否被访问\nvoid print()//输出答案\n{\n    if(ans>3)  return;//由题可得,只需要输出 3 种排列\n    for(int i=1;i<=n;i++)  cout<<a[i]<<' ';\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)//形参 x :当前是第 x 个皇后\n{\n    if(x>n)//一种可行的方案达成\n    {\n        ans++;//方案数++\n        print();//输出答案\n        return;\n    }\n    for(int i=1;i<=n;i++)//枚举所有答案\n    {\n        if(!vis_lie[i]&&!vis_l[x-i+n]&&!vis_r[x+i])//是否被访问过(规律见 L40 )\n        {\n            vis_lie[i]=true,vis_l[x-i+n]=true,vis_r[x+i]=true;//标记\n            a[x]=i;//存答案\n            dfs(x+1);//继续递归\n            vis_lie[i]=false,vis_l[x-i+n]=false,vis_r[x+i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);\n    cout<<ans;\n    return 0;\n}\n\n/*\n对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界\n对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等\n*/\n```\n## [P1706](https://luogu.com.cn/problem/P1706) 全排列问题\n### P1 - DFS\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,a[20];//枚举 n 个数字,可行的答案存放在 a 中\nbool vis[20];//已经被访问过的\nvoid print()//输出答案\n{\n    for(int i=1;i<=n;i++)  cout<<setw(5)<<a[i];\n    cout<<endl;\n    return;\n}\nvoid dfs(int x)\n{\n    if(x>n)//已经有了一个方案\n    {\n        print();\n        return;\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i])//没被访问\n        {\n            a[x]=i;//记录答案\n            vis[i]=true;//标记\n            dfs(x+1);//继续递归\n            vis[i]=false;//回溯\n        }\n    }\n}\nint main()\n{\n    cin>>n;\n    dfs(1);//从 1 开始\n    return 0;\n}\n```\n### P2 - 枚举优化\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint num[n];\n\tfor(int i=1;i<=n;i++)  num[i]=i;\n\tdo\n\t{\n\t\tfor(int i=1;i<=n;i++)  cout<<setw(5)<<num[i];\n\t\tcout<<endl;\n\t}while(next_permutation(num+1,num+1+n));\n\treturn 0;\n}\n```\n## [P1605](https://luogu.com.cn/problem/P1605) 迷宫\n```cpp\n#include<iostream>\n#include<cstring>//这里不用万能头是因为想用 map 当变量名\nusing namespace std;\nint n,m,t,sx,sy,fx,fy,ans;\n//地图长宽,障碍数量,起点坐标,终点坐标,答案\nint dx[5]={1,0,-1,0},dy[5]={0,-1,0,1};//位移\nbool map[10][10];//地图\nvoid dfs(int x,int y)\n{\n    if(x==fx&&y==fy)//到达终点\n    {\n        ans++;\n        return;\n    }\n    for(int i=0;i<4;i++)//枚举位移\n    {\n        int tmp_x=dx[i]+x,tmp_y=dy[i]+y;//移动\n        if(tmp_x>=1&&tmp_x<=n&&tmp_y>=1&&tmp_y<=m&&map[tmp_x][tmp_y])\n        //合法判断:坐标未越界,位置可用(没有障碍且没被访问)\n        {\n            map[tmp_x][tmp_y]=false;//标记访问\n            dfs(tmp_x,tmp_y);//继续递归\n            map[tmp_x][tmp_y]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(map,true,sizeof(map));//初始化\n    cin>>n>>m>>t>>sx>>sy>>fx>>fy;\n    for(int i=1;i<=t;i++)//读入障碍\n    {\n        int x,y;\n        cin>>x>>y;\n        map[x][y]=false;//不能走\n    }\n    map[sx][sy]=false;//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!\n    dfs(sx,sy);\n    cout<<ans;\n    return 0;\n}\n```\n## [P1036](https://luogu.com.cn/problem/P1036) 选数\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k,x[25],ans;//共有 n 个数,要选 k 个数,答案\nbool vis[25];//是否已经被选择\nbool check_prime(int n)//判断质数\n{\n    if(n<=1)  return false;\n    for(int i=2;i<=sqrt(n);i++)\n        if(n%i==0)  return false;\n    return true;\n}\nvoid dfs(int pos,int cnt,int sum)\n{\n    if(cnt>=k)//选完了\n    {\n        if(check_prime(sum))  ans++;//判断质数,然后答案自增\n        return;\n    }\n    for(int i=pos;i<=n;i++)\n    {\n        if(vis[i])//没被选\n        {\n            vis[i]=false;//标记\n            dfs(i+1,cnt+1,sum+x[i]);//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数\n            vis[i]=true;//回溯\n        }\n    }\n}\nint main()\n{\n    memset(vis,true,sizeof(vis));//初始化\n    cin>>n>>k;\n    for(int i=1;i<=n;i++)  cin>>x[i];\n    dfs(1,0,0);//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0\n    cout<<ans;\n    return 0;\n}\n```\n## [P1238](https://luogu.com.cn/problem/P1238) 走迷宫\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint m,n;// m 行 n 列 \nint mp[20][20],vis[20][20],have_solution=false;//地图,是否被访问,是否有解 \nint begin_x,begin_y,end_x,end_y;//起点和终点 \nint dx[5]={0,-1,0,1},dy[5]={-1,0,1,0};//偏移\nint ans[100000][3],k;\n//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 \n\nvoid print()//输出一种答案 \n{\n\tif(have_solution==false)  have_solution=true;//更新为有解 \n\tfor(int i=0;i<k;i++)  cout<<'('<<ans[i][1]<<','<<ans[i][2]<<')'<<\"->\";\n\tcout<<'('<<end_x<<','<<end_y<<')'<<endl;\n\t//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 \n}\n\nvoid dfs(int x,int y)\n{\n\tif(x==end_x&&y==end_y)//到达终点 \n\t{\n\t\tprint();//输出答案 \n\t\treturn;\n\t}\n\tfor(int i=0;i<4;i++)//枚举偏移 \n\t{\n\t\tint nxt_x=x+dx[i],nxt_y=y+dy[i];//定位下一步 \n\t\tif(mp[nxt_x][nxt_y]==1&&vis[nxt_x][nxt_y]==0)\n\t\t//下一步可以走并且没被访问 \n\t\t{\n\t\t\tvis[x][y]=1;//标记上一步被访问 \n\t\t\tans[k][1]=x,ans[k][2]=y;//记录可行的一步 \n\t\t\tk++;//增加指针 \n\t\t\tdfs(nxt_x,nxt_y);//继续找下一步 \n\t\t\tvis[x][y]=0;//回溯,设为未访问 \n\t\t\tk--;//倒回去 \n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tcin>>m>>n;\n\tfor(int i=1;i<=m;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tcin>>mp[i][j];//读入地图 \n\tcin>>begin_x>>begin_y>>end_x>>end_y;//读入起点和终点 \n\tdfs(begin_x,begin_y);\n\tif(!have_solution)  cout<<-1;//没有解 \n\treturn 0;//结束 :) \n}\n```\n# BFS\n注意: **BFS 不能用于加权图**,因为 BFS 只会查找**边数最少**的路径  \n例如 100 -> 100 和 1 -> 1 -> 1 -> 1  \nBFS 会选择 100 -> 100\n\n当数据范围较小（ $\\le20$ ）时，用 DFS 也不是不可以\n## [P1746](https://luogu.com.cn/problem/P1746) 离开中山路\n```cpp\n#include<iostream>\n#include<queue>\nusing namespace std;\nstruct Point//单个点的坐标\n{\n    int x,y;\n};\nint n;\nchar map[1005][1005];\nint dis[1005][1005];//到起点的距离\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};//位移\nint start_x,start_y,final_x,final_y;//由题可得,起点和终点\nqueue<Point> q;//等待处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//压入当前点\n    dis[x][y]=0;//起点\n    while(!q.empty())//只要队列非空\n    {\n        Point t=q.front();//读取当前队头\n        q.pop();//弹出\n        for(int i=0;i<4;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//下一个点\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>n||map[nxt_x][nxt_y]=='1'||dis[nxt_x][nxt_y]>0)  continue;\n            //判断:越界+有障碍+被访问\n\n            q.push((Point){nxt_x,nxt_y});//压入下一个点\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//增加 1 段距离\n        }\n    }\n    return;\n}\nint main()\n{\n\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>map[i][j];\n    cin>>start_x>>start_y>>final_x>>final_y;\n    bfs(start_x,start_y);\n    cout<<dis[final_x][final_y];\n    return 0;\n}\n```\n## [P1443](https://luogu.com.cn/problem/P1443) 马的遍历\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Point//当前马位于的坐标\n{\n    int x,y;\n};\nint n,m,x,y,dis[405][405];//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步\nint dx[]={2,1,-2,1,-1,2,-2,-1};\nint dy[]={1,2,1,-2,2,-1,-1,-2};//位移\nqueue<Point> q;//当前需要处理的点\nvoid bfs(int x,int y)\n{\n    q.push((Point){x,y});//入队处理起点\n    dis[x][y]=0;//起点已经有一个马了\n    while(!q.empty())\n    {\n        Point t=q.front();//取队头处理\n        q.pop();//弹出\n        for(int i=0;i<8;i++)//枚举位移\n        {\n            int nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];//生成新坐标\n            if(nxt_x<1||nxt_x>n||nxt_y<1||nxt_y>m||dis[nxt_x][nxt_y]!=-1)  continue;\n            //检查:越界+被访问\n\n            dis[nxt_x][nxt_y]=dis[t.x][t.y]+1;//更新步数为上一个点+1\n            q.push((Point){nxt_x,nxt_y});//继续压入新的点继续处理\n        }\n    }\n    return;\n}\nint main()\n{\n    memset(dis,-1,sizeof(dis));//初始化\n    cin>>n>>m>>x>>y;\n    bfs(x,y);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)  cout<<setw(5)<<dis[i][j];\n        cout<<endl;\n    }\n    return 0;\n}\n```\n## [P2895](https://luogu.com.cn/problem/P2895) Meteor Shower S\n耗时 2 个月的巅峰对决，但最终还是我赢了！\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=305;\nstruct Point//存储坐标的点 \n{\n    int x,y;\n};\nint m;\nint mp[LEN][LEN],dis[LEN][LEN];//地图,距离 \nint dx[]={-1,0,1,0},dy[]={0,1,0,-1};//偏移 \nqueue<Point> q;\nint bfs()\n{\n    q.push((Point){0,0});//第一个位置是 (0,0) \n    dis[0][0]=0;//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 \n    while(!q.empty())\n    {\n        Point now=q.front();//找到当前点 \n        q.pop();\n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];//得到下一个点的位置\n            if(nxt_x<0||nxt_y<0)  continue;//越界 \n            if(dis[nxt_x][nxt_y])  continue;//被访问\n            if(dis[now.x][now.y]+1>=mp[nxt_x][nxt_y])  continue;\n            //剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较\n            dis[nxt_x][nxt_y]=dis[now.x][now.y]+1;//更新距离 \n            q.push((Point){nxt_x,nxt_y});//压入下一个点 \n            if(mp[nxt_x][nxt_y]>1e9)  return dis[nxt_x][nxt_y];//没有流行砸到,答案就是当前点的距离 \n        }\n    }\n    return -1;\n}\nsigned main()\n{\n    memset(mp,0x3f,sizeof(mp));//初始化一个足够大的数,为了在下面取到最小值 \n    cin>>m;\n    while(m--)\n    {\n        int x,y,time;//坐标,流星砸下来的时间 \n        cin>>x>>y>>time;\n        mp[x][y]=min(mp[x][y],time);//取砸下来的最小值 \n        for(int d=0;d<4;d++)//枚举偏移 \n        {\n            int nxt_x=x+dx[d],nxt_y=y+dy[d];//得到即将蔓延的点 \n            if(nxt_x<0||nxt_x>301||nxt_y<0||nxt_y>301)  continue;//越界 \n            mp[nxt_x][nxt_y]=min(mp[nxt_x][nxt_y],time);//继续取最小值 \n        }\n    }\n    cout<<bfs();\n    exit(0);\n}\n```","slug":"搜索题目整理","published":1,"updated":"2025-07-29T12:34:37.455Z","_id":"cmdohm0n70003zgbo1787346c","comments":1,"layout":"post","photos":[],"content":"<p>本文整理了 ED_Builder 在初学搜索算法时做的题目</p>\n<span id=\"more\"></span>\n<h1 id=\"dfs\"><a class=\"markdownIt-Anchor\" href=\"#dfs\"></a> DFS</h1>\n<h2 id=\"p1219\"><a class=\"markdownIt-Anchor\" href=\"#p1219\"></a> <a href=\"https://luogu.com.cn/problem/P1219\">P1219</a> 八皇后</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>],ans;<span class=\"comment\">//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis_lie[<span class=\"number\">30</span>],vis_l[<span class=\"number\">30</span>],vis_r[<span class=\"number\">30</span>];<span class=\"comment\">//记录当前列(|),左斜(/),右斜(\\)是否被访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans&gt;<span class=\"number\">3</span>)  <span class=\"keyword\">return</span>;<span class=\"comment\">//由题可得,只需要输出 3 种排列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//形参 x :当前是第 x 个皇后</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//一种可行的方案达成</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;<span class=\"comment\">//方案数++</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//枚举所有答案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis_lie[i]&amp;&amp;!vis_l[x-i+n]&amp;&amp;!vis_r[x+i])<span class=\"comment\">//是否被访问过(规律见 L40 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">true</span>,vis_l[x-i+n]=<span class=\"literal\">true</span>,vis_r[x+i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//存答案</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">false</span>,vis_l[x-i+n]=<span class=\"literal\">false</span>,vis_r[x+i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"p1706\"><a class=\"markdownIt-Anchor\" href=\"#p1706\"></a> <a href=\"https://luogu.com.cn/problem/P1706\">P1706</a> 全排列问题</h2>\n<h3 id=\"p1-dfs\"><a class=\"markdownIt-Anchor\" href=\"#p1-dfs\"></a> P1 - DFS</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>];<span class=\"comment\">//枚举 n 个数字,可行的答案存放在 a 中</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">20</span>];<span class=\"comment\">//已经被访问过的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;a[i];</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//已经有了一个方案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])<span class=\"comment\">//没被访问</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//记录答案</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);<span class=\"comment\">//从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"p2-枚举优化\"><a class=\"markdownIt-Anchor\" href=\"#p2-枚举优化\"></a> P2 - 枚举优化</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  num[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;num[i];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(num<span class=\"number\">+1</span>,num<span class=\"number\">+1</span>+n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1605\"><a class=\"markdownIt-Anchor\" href=\"#p1605\"></a> <a href=\"https://luogu.com.cn/problem/P1605\">P1605</a> 迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span><span class=\"comment\">//这里不用万能头是因为想用 map 当变量名</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t,sx,sy,fx,fy,ans;</span><br><span class=\"line\"><span class=\"comment\">//地图长宽,障碍数量,起点坐标,终点坐标,答案</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">bool</span> map[<span class=\"number\">10</span>][<span class=\"number\">10</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==fx&amp;&amp;y==fy)<span class=\"comment\">//到达终点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp_x=dx[i]+x,tmp_y=dy[i]+y;<span class=\"comment\">//移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_x&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_x&lt;=n&amp;&amp;tmp_y&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_y&lt;=m&amp;&amp;map[tmp_x][tmp_y])</span><br><span class=\"line\">        <span class=\"comment\">//合法判断:坐标未越界,位置可用(没有障碍且没被访问)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记访问</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(tmp_x,tmp_y);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(map,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(map));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)<span class=\"comment\">//读入障碍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        map[x][y]=<span class=\"literal\">false</span>;<span class=\"comment\">//不能走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map[sx][sy]=<span class=\"literal\">false</span>;<span class=\"comment\">//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(sx,sy);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1036\"><a class=\"markdownIt-Anchor\" href=\"#p1036\"></a> <a href=\"https://luogu.com.cn/problem/P1036\">P1036</a> 选数</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,x[<span class=\"number\">25</span>],ans;<span class=\"comment\">//共有 n 个数,要选 k 个数,答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">25</span>];<span class=\"comment\">//是否已经被选择</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_prime</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//判断质数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"built_in\">sqrt</span>(n);i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> pos,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt&gt;=k)<span class=\"comment\">//选完了</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check_prime</span>(sum))  ans++;<span class=\"comment\">//判断质数,然后答案自增</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i])<span class=\"comment\">//没被选</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i<span class=\"number\">+1</span>,cnt<span class=\"number\">+1</span>,sum+x[i]);<span class=\"comment\">//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;x[i];</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1238\"><a class=\"markdownIt-Anchor\" href=\"#p1238\"></a> <a href=\"https://luogu.com.cn/problem/P1238\">P1238</a> 走迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n;<span class=\"comment\">// m 行 n 列 </span></span><br><span class=\"line\"><span class=\"type\">int</span> mp[<span class=\"number\">20</span>][<span class=\"number\">20</span>],vis[<span class=\"number\">20</span>][<span class=\"number\">20</span>],have_solution=<span class=\"literal\">false</span>;<span class=\"comment\">//地图,是否被访问,是否有解 </span></span><br><span class=\"line\"><span class=\"type\">int</span> begin_x,begin_y,end_x,end_y;<span class=\"comment\">//起点和终点 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//偏移</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">100000</span>][<span class=\"number\">3</span>],k;</span><br><span class=\"line\"><span class=\"comment\">//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出一种答案 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(have_solution==<span class=\"literal\">false</span>)  have_solution=<span class=\"literal\">true</span>;<span class=\"comment\">//更新为有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">2</span>]&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;<span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;end_x&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;end_y&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==end_x&amp;&amp;y==end_y)<span class=\"comment\">//到达终点 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[i],nxt_y=y+dy[i];<span class=\"comment\">//定位下一步 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]==<span class=\"number\">1</span>&amp;&amp;vis[nxt_x][nxt_y]==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//下一步可以走并且没被访问 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">1</span>;<span class=\"comment\">//标记上一步被访问 </span></span><br><span class=\"line\">            ans[k][<span class=\"number\">1</span>]=x,ans[k][<span class=\"number\">2</span>]=y;<span class=\"comment\">//记录可行的一步 </span></span><br><span class=\"line\">            k++;<span class=\"comment\">//增加指针 </span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nxt_x,nxt_y);<span class=\"comment\">//继续找下一步 </span></span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯,设为未访问 </span></span><br><span class=\"line\">            k--;<span class=\"comment\">//倒回去 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];<span class=\"comment\">//读入地图 </span></span><br><span class=\"line\">    cin&gt;&gt;begin_x&gt;&gt;begin_y&gt;&gt;end_x&gt;&gt;end_y;<span class=\"comment\">//读入起点和终点 </span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(begin_x,begin_y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!have_solution)  cout&lt;&lt;<span class=\"number\">-1</span>;<span class=\"comment\">//没有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束 :) </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bfs\"><a class=\"markdownIt-Anchor\" href=\"#bfs\"></a> BFS</h1>\n<p>注意: <strong>BFS 不能用于加权图</strong>,因为 BFS 只会查找<strong>边数最少</strong>的路径<br />\n例如 100 -&gt; 100 和 1 -&gt; 1 -&gt; 1 -&gt; 1<br />\nBFS 会选择 100 -&gt; 100</p>\n<p>当数据范围较小（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span> ）时，用 DFS 也不是不可以</p>\n<h2 id=\"p1746\"><a class=\"markdownIt-Anchor\" href=\"#p1746\"></a> <a href=\"https://luogu.com.cn/problem/P1746\">P1746</a> 离开中山路</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//单个点的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> map[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//到起点的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">int</span> start_x,start_y,final_x,final_y;<span class=\"comment\">//由题可得,起点和终点</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//等待处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//压入当前点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//只要队列非空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//读取当前队头</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;n||map[nxt_x][nxt_y]==<span class=\"string\">&#x27;1&#x27;</span>||dis[nxt_x][nxt_y]&gt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断:越界+有障碍+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//增加 1 段距离</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">    cin&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;final_x&gt;&gt;final_y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(start_x,start_y);</span><br><span class=\"line\">    cout&lt;&lt;dis[final_x][final_y];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1443\"><a class=\"markdownIt-Anchor\" href=\"#p1443\"></a> <a href=\"https://luogu.com.cn/problem/P1443\">P1443</a> 马的遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//当前马位于的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,x,y,dis[<span class=\"number\">405</span>][<span class=\"number\">405</span>];<span class=\"comment\">//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//当前需要处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//入队处理起点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点已经有一个马了</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//取队头处理</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//生成新坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||dis[nxt_x][nxt_y]!=<span class=\"number\">-1</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//检查:越界+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新步数为上一个点+1</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//继续压入新的点继续处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(dis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;dis[i][j];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p2895\"><a class=\"markdownIt-Anchor\" href=\"#p2895\"></a> <a href=\"https://luogu.com.cn/problem/P2895\">P2895</a> Meteor Shower S</h2>\n<p>耗时 2 个月的巅峰对决，但最终还是我赢了！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">305</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//存储坐标的点 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> m;</span><br><span class=\"line\"><span class=\"type\">int</span> mp[LEN][LEN],dis[LEN][LEN];<span class=\"comment\">//地图,距离 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//偏移 </span></span><br><span class=\"line\">queue&lt;Point&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;);<span class=\"comment\">//第一个位置是 (0,0) </span></span><br><span class=\"line\">    dis[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;<span class=\"comment\">//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point now=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//找到当前点 </span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];<span class=\"comment\">//得到下一个点的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_y&lt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//被访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[now.x][now.y]<span class=\"number\">+1</span>&gt;=mp[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[now.x][now.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新距离 </span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]&gt;<span class=\"number\">1e9</span>)  <span class=\"keyword\">return</span> dis[nxt_x][nxt_y];<span class=\"comment\">//没有流行砸到,答案就是当前点的距离 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mp,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(mp));<span class=\"comment\">//初始化一个足够大的数,为了在下面取到最小值 </span></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y,time;<span class=\"comment\">//坐标,流星砸下来的时间 </span></span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;time;</span><br><span class=\"line\">        mp[x][y]=<span class=\"built_in\">min</span>(mp[x][y],time);<span class=\"comment\">//取砸下来的最小值 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//得到即将蔓延的点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_x&gt;<span class=\"number\">301</span>||nxt_y&lt;<span class=\"number\">0</span>||nxt_y&gt;<span class=\"number\">301</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            mp[nxt_x][nxt_y]=<span class=\"built_in\">min</span>(mp[nxt_x][nxt_y],time);<span class=\"comment\">//继续取最小值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文整理了 ED_Builder 在初学搜索算法时做的题目</p>","more":"<h1 id=\"dfs\"><a class=\"markdownIt-Anchor\" href=\"#dfs\"></a> DFS</h1>\n<h2 id=\"p1219\"><a class=\"markdownIt-Anchor\" href=\"#p1219\"></a> <a href=\"https://luogu.com.cn/problem/P1219\">P1219</a> 八皇后</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>],ans;<span class=\"comment\">//共计 n 个皇后,可行的答案存放在 a 数组中,共有 ans 种答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis_lie[<span class=\"number\">30</span>],vis_l[<span class=\"number\">30</span>],vis_r[<span class=\"number\">30</span>];<span class=\"comment\">//记录当前列(|),左斜(/),右斜(\\)是否被访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ans&gt;<span class=\"number\">3</span>)  <span class=\"keyword\">return</span>;<span class=\"comment\">//由题可得,只需要输出 3 种排列</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//形参 x :当前是第 x 个皇后</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//一种可行的方案达成</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;<span class=\"comment\">//方案数++</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//枚举所有答案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis_lie[i]&amp;&amp;!vis_l[x-i+n]&amp;&amp;!vis_r[x+i])<span class=\"comment\">//是否被访问过(规律见 L40 )</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">true</span>,vis_l[x-i+n]=<span class=\"literal\">true</span>,vis_r[x+i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//存答案</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis_lie[i]=<span class=\"literal\">false</span>,vis_l[x-i+n]=<span class=\"literal\">false</span>,vis_r[x+i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_l[x-i+n] : 画图可得,位于同一个左斜线的坐标, x+y 都相等, +n 防止越下界</span></span><br><span class=\"line\"><span class=\"comment\">对于 vis_r[x+i] : 画图可得,位于同一个右斜线的坐标, abs(x-y) 都相等</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"p1706\"><a class=\"markdownIt-Anchor\" href=\"#p1706\"></a> <a href=\"https://luogu.com.cn/problem/P1706\">P1706</a> 全排列问题</h2>\n<h3 id=\"p1-dfs\"><a class=\"markdownIt-Anchor\" href=\"#p1-dfs\"></a> P1 - DFS</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,a[<span class=\"number\">20</span>];<span class=\"comment\">//枚举 n 个数字,可行的答案存放在 a 中</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">20</span>];<span class=\"comment\">//已经被访问过的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出答案</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;a[i];</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&gt;n)<span class=\"comment\">//已经有了一个方案</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[i])<span class=\"comment\">//没被访问</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            a[x]=i;<span class=\"comment\">//记录答案</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x<span class=\"number\">+1</span>);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);<span class=\"comment\">//从 1 开始</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"p2-枚举优化\"><a class=\"markdownIt-Anchor\" href=\"#p2-枚举优化\"></a> P2 - 枚举优化</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> num[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  num[i]=i;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;num[i];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(num<span class=\"number\">+1</span>,num<span class=\"number\">+1</span>+n));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1605\"><a class=\"markdownIt-Anchor\" href=\"#p1605\"></a> <a href=\"https://luogu.com.cn/problem/P1605\">P1605</a> 迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;cstring&gt;</span><span class=\"comment\">//这里不用万能头是因为想用 map 当变量名</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t,sx,sy,fx,fy,ans;</span><br><span class=\"line\"><span class=\"comment\">//地图长宽,障碍数量,起点坐标,终点坐标,答案</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">bool</span> map[<span class=\"number\">10</span>][<span class=\"number\">10</span>];<span class=\"comment\">//地图</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==fx&amp;&amp;y==fy)<span class=\"comment\">//到达终点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ans++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> tmp_x=dx[i]+x,tmp_y=dy[i]+y;<span class=\"comment\">//移动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tmp_x&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_x&lt;=n&amp;&amp;tmp_y&gt;=<span class=\"number\">1</span>&amp;&amp;tmp_y&lt;=m&amp;&amp;map[tmp_x][tmp_y])</span><br><span class=\"line\">        <span class=\"comment\">//合法判断:坐标未越界,位置可用(没有障碍且没被访问)</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记访问</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(tmp_x,tmp_y);<span class=\"comment\">//继续递归</span></span><br><span class=\"line\">            map[tmp_x][tmp_y]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(map,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(map));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=t;i++)<span class=\"comment\">//读入障碍</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        map[x][y]=<span class=\"literal\">false</span>;<span class=\"comment\">//不能走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    map[sx][sy]=<span class=\"literal\">false</span>;<span class=\"comment\">//byd就是这个东西没加 WA 了 3 个点:起点永远被访问!</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(sx,sy);</span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1036\"><a class=\"markdownIt-Anchor\" href=\"#p1036\"></a> <a href=\"https://luogu.com.cn/problem/P1036\">P1036</a> 选数</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k,x[<span class=\"number\">25</span>],ans;<span class=\"comment\">//共有 n 个数,要选 k 个数,答案</span></span><br><span class=\"line\"><span class=\"type\">bool</span> vis[<span class=\"number\">25</span>];<span class=\"comment\">//是否已经被选择</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_prime</span><span class=\"params\">(<span class=\"type\">int</span> n)</span><span class=\"comment\">//判断质数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;=<span class=\"built_in\">sqrt</span>(n);i++)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n%i==<span class=\"number\">0</span>)  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> pos,<span class=\"type\">int</span> cnt,<span class=\"type\">int</span> sum)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cnt&gt;=k)<span class=\"comment\">//选完了</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check_prime</span>(sum))  ans++;<span class=\"comment\">//判断质数,然后答案自增</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i])<span class=\"comment\">//没被选</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[i]=<span class=\"literal\">false</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i<span class=\"number\">+1</span>,cnt<span class=\"number\">+1</span>,sum+x[i]);<span class=\"comment\">//继续递归:下标++ ,选择的数量++ ,总和增加对应下标的数</span></span><br><span class=\"line\">            vis[i]=<span class=\"literal\">true</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cin&gt;&gt;x[i];</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>);<span class=\"comment\">//DFS:下标从 1 开始,已经选了 0 个数,选择的数的总和为 0</span></span><br><span class=\"line\">    cout&lt;&lt;ans;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1238\"><a class=\"markdownIt-Anchor\" href=\"#p1238\"></a> <a href=\"https://luogu.com.cn/problem/P1238\">P1238</a> 走迷宫</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> m,n;<span class=\"comment\">// m 行 n 列 </span></span><br><span class=\"line\"><span class=\"type\">int</span> mp[<span class=\"number\">20</span>][<span class=\"number\">20</span>],vis[<span class=\"number\">20</span>][<span class=\"number\">20</span>],have_solution=<span class=\"literal\">false</span>;<span class=\"comment\">//地图,是否被访问,是否有解 </span></span><br><span class=\"line\"><span class=\"type\">int</span> begin_x,begin_y,end_x,end_y;<span class=\"comment\">//起点和终点 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[<span class=\"number\">5</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,dy[<span class=\"number\">5</span>]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;;<span class=\"comment\">//偏移</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">100000</span>][<span class=\"number\">3</span>],k;</span><br><span class=\"line\"><span class=\"comment\">//存放答案:第一维是答案,第二维是 x 和 y 坐标,例如 ans[3][2] 表示第 3 个答案的 y 坐标;k是答案的长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span><span class=\"comment\">//输出一种答案 </span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(have_solution==<span class=\"literal\">false</span>)  have_solution=<span class=\"literal\">true</span>;<span class=\"comment\">//更新为有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">1</span>]&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;ans[i][<span class=\"number\">2</span>]&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;<span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&#x27;(&#x27;</span>&lt;&lt;end_x&lt;&lt;<span class=\"string\">&#x27;,&#x27;</span>&lt;&lt;end_y&lt;&lt;<span class=\"string\">&#x27;)&#x27;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"comment\">//因为在 L20-41 的 dfs 中,如果到了终点就不会添加答案了,所以还要输出一遍终点的坐标 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==end_x&amp;&amp;y==end_y)<span class=\"comment\">//到达终点 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>();<span class=\"comment\">//输出答案 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> nxt_x=x+dx[i],nxt_y=y+dy[i];<span class=\"comment\">//定位下一步 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]==<span class=\"number\">1</span>&amp;&amp;vis[nxt_x][nxt_y]==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">//下一步可以走并且没被访问 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">1</span>;<span class=\"comment\">//标记上一步被访问 </span></span><br><span class=\"line\">            ans[k][<span class=\"number\">1</span>]=x,ans[k][<span class=\"number\">2</span>]=y;<span class=\"comment\">//记录可行的一步 </span></span><br><span class=\"line\">            k++;<span class=\"comment\">//增加指针 </span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(nxt_x,nxt_y);<span class=\"comment\">//继续找下一步 </span></span><br><span class=\"line\">            vis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯,设为未访问 </span></span><br><span class=\"line\">            k--;<span class=\"comment\">//倒回去 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;mp[i][j];<span class=\"comment\">//读入地图 </span></span><br><span class=\"line\">    cin&gt;&gt;begin_x&gt;&gt;begin_y&gt;&gt;end_x&gt;&gt;end_y;<span class=\"comment\">//读入起点和终点 </span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(begin_x,begin_y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!have_solution)  cout&lt;&lt;<span class=\"number\">-1</span>;<span class=\"comment\">//没有解 </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//结束 :) </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"bfs\"><a class=\"markdownIt-Anchor\" href=\"#bfs\"></a> BFS</h1>\n<p>注意: <strong>BFS 不能用于加权图</strong>,因为 BFS 只会查找<strong>边数最少</strong>的路径<br />\n例如 100 -&gt; 100 和 1 -&gt; 1 -&gt; 1 -&gt; 1<br />\nBFS 会选择 100 -&gt; 100</p>\n<p>当数据范围较小（ <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><mn>20</mn></mrow><annotation encoding=\"application/x-tex\">\\le20</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span></span></span></span> ）时，用 DFS 也不是不可以</p>\n<h2 id=\"p1746\"><a class=\"markdownIt-Anchor\" href=\"#p1746\"></a> <a href=\"https://luogu.com.cn/problem/P1746\">P1746</a> 离开中山路</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//单个点的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">char</span> map[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dis[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>];<span class=\"comment\">//到起点的距离</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\"><span class=\"type\">int</span> start_x,start_y,final_x,final_y;<span class=\"comment\">//由题可得,起点和终点</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//等待处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//压入当前点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())<span class=\"comment\">//只要队列非空</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//读取当前队头</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;n||map[nxt_x][nxt_y]==<span class=\"string\">&#x27;1&#x27;</span>||dis[nxt_x][nxt_y]&gt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//判断:越界+有障碍+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//增加 1 段距离</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;map[i][j];</span><br><span class=\"line\">    cin&gt;&gt;start_x&gt;&gt;start_y&gt;&gt;final_x&gt;&gt;final_y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(start_x,start_y);</span><br><span class=\"line\">    cout&lt;&lt;dis[final_x][final_y];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p1443\"><a class=\"markdownIt-Anchor\" href=\"#p1443\"></a> <a href=\"https://luogu.com.cn/problem/P1443\">P1443</a> 马的遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//当前马位于的坐标</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,x,y,dis[<span class=\"number\">405</span>][<span class=\"number\">405</span>];<span class=\"comment\">//棋盘 n 行 m 列,在点 (x,y) 有一个马,当前点 (x,y) 马需要走 dis[x][y] 步</span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">2</span>,<span class=\"number\">-2</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dy[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">-2</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-2</span>&#125;;<span class=\"comment\">//位移</span></span><br><span class=\"line\">queue&lt;Point&gt; q;<span class=\"comment\">//当前需要处理的点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;x,y&#125;);<span class=\"comment\">//入队处理起点</span></span><br><span class=\"line\">    dis[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//起点已经有一个马了</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point t=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//取队头处理</span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();<span class=\"comment\">//弹出</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">8</span>;i++)<span class=\"comment\">//枚举位移</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=t.x+dx[i],nxt_y=t.y+dy[i];<span class=\"comment\">//生成新坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">1</span>||nxt_x&gt;n||nxt_y&lt;<span class=\"number\">1</span>||nxt_y&gt;m||dis[nxt_x][nxt_y]!=<span class=\"number\">-1</span>)  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//检查:越界+被访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[t.x][t.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新步数为上一个点+1</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//继续压入新的点继续处理</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dis,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(dis));<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>(x,y);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=m;j++)  cout&lt;&lt;<span class=\"built_in\">setw</span>(<span class=\"number\">5</span>)&lt;&lt;dis[i][j];</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"p2895\"><a class=\"markdownIt-Anchor\" href=\"#p2895\"></a> <a href=\"https://luogu.com.cn/problem/P2895\">P2895</a> Meteor Shower S</h2>\n<p>耗时 2 个月的巅峰对决，但最终还是我赢了！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">305</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span><span class=\"comment\">//存储坐标的点 </span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> m;</span><br><span class=\"line\"><span class=\"type\">int</span> mp[LEN][LEN],dis[LEN][LEN];<span class=\"comment\">//地图,距离 </span></span><br><span class=\"line\"><span class=\"type\">int</span> dx[]=&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,dy[]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;;<span class=\"comment\">//偏移 </span></span><br><span class=\"line\">queue&lt;Point&gt; q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Point)&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;);<span class=\"comment\">//第一个位置是 (0,0) </span></span><br><span class=\"line\">    dis[<span class=\"number\">0</span>][<span class=\"number\">0</span>]=<span class=\"number\">0</span>;<span class=\"comment\">//起点 (0,0) 距离当前位置 (0,0) 的距离是 0 </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Point now=q.<span class=\"built_in\">front</span>();<span class=\"comment\">//找到当前点 </span></span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=now.x+dx[d],nxt_y=now.y+dy[d];<span class=\"comment\">//得到下一个点的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_y&lt;<span class=\"number\">0</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//被访问</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[now.x][now.y]<span class=\"number\">+1</span>&gt;=mp[nxt_x][nxt_y])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//剪枝: 下一个点已经无法到达: 当前距离 +1 即为到下一个点的距离,然后和下一个点的坠落时间比较</span></span><br><span class=\"line\">            dis[nxt_x][nxt_y]=dis[now.x][now.y]<span class=\"number\">+1</span>;<span class=\"comment\">//更新距离 </span></span><br><span class=\"line\">            q.<span class=\"built_in\">push</span>((Point)&#123;nxt_x,nxt_y&#125;);<span class=\"comment\">//压入下一个点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nxt_x][nxt_y]&gt;<span class=\"number\">1e9</span>)  <span class=\"keyword\">return</span> dis[nxt_x][nxt_y];<span class=\"comment\">//没有流行砸到,答案就是当前点的距离 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mp,<span class=\"number\">0x3f</span>,<span class=\"built_in\">sizeof</span>(mp));<span class=\"comment\">//初始化一个足够大的数,为了在下面取到最小值 </span></span><br><span class=\"line\">    cin&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x,y,time;<span class=\"comment\">//坐标,流星砸下来的时间 </span></span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;time;</span><br><span class=\"line\">        mp[x][y]=<span class=\"built_in\">min</span>(mp[x][y],time);<span class=\"comment\">//取砸下来的最小值 </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d=<span class=\"number\">0</span>;d&lt;<span class=\"number\">4</span>;d++)<span class=\"comment\">//枚举偏移 </span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nxt_x=x+dx[d],nxt_y=y+dy[d];<span class=\"comment\">//得到即将蔓延的点 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nxt_x&lt;<span class=\"number\">0</span>||nxt_x&gt;<span class=\"number\">301</span>||nxt_y&lt;<span class=\"number\">0</span>||nxt_y&gt;<span class=\"number\">301</span>)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//越界 </span></span><br><span class=\"line\">            mp[nxt_x][nxt_y]=<span class=\"built_in\">min</span>(mp[nxt_x][nxt_y],time);<span class=\"comment\">//继续取最小值 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">bfs</span>();</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"图论 - 最小生成树","date":"2025-07-10T12:01:47.000Z","banner":"https://imghub.ed-builder.top/file/1751761219115_5.png","cover":"https://imghub.ed-builder.top/file/1751761219115_5.png","poster":{"headline":"图论 - 最小生成树","topic":"大多适用于连接各种节点"},"katex":true,"author":"ED_Builder","_content":"\n本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal\n\n<!-- more -->\n\n# Prim（加点法）\n## 基本信息\n每次迭代选择边权最小的边对应的点，加入到最小生成树中。  \n算法从某个顶点 $start$ 开始，逐渐延伸覆盖整个连通网的所有顶点\n![pic-solution](https://imghub.ed-builder.top/file/1751761219115_5.png)\n\n时间复杂度：$O(n^2)$\n## 算法思想\n蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。  \n每次循环都将一个蓝点 $u$ 变为白点，并且这个蓝点 $u$ 与白点相连的最小边权 `min(weight[u])` 还是当前所有蓝点中最小的。  \n这样相当于向生成树中添加了 $n-1$ 次最小的边，最后得到的一定是最小生成树\n## 算法描述\n以 $1$ 为起点生成最小生成树，`min[v]` 表示蓝点 `v` 与白点相连的最小边权，`mst` 表示最小生成树的权值之和\n1. 初始化：`min[v]=INF`$(v\\ne 1)$ &nbsp; `min[1]=0` &nbsp; `mst=0`\n2.   \n```cpp\nfor(int i=1;i<=n;i++)\n{\n\t1. 寻找 min[u] 最小的蓝点 u\n\t2. 将 u 标记为白点\n\t3. mst+=min[u];\n\t4. for(与白点 u 相连的所有蓝点 v)\n\t\tif(weight[u][v]<min[v])\n\t\t\tmin[v]=weight[u][v];\n}\n```\n3. 算法结束，`mst` 即为最小生成树的权值之和\n## 例题 - [YBT 1349](https://ybt.ssoier.cn/problem_show.php?pid=1349)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN];\nint minn[LEN];\nbool vis[LEN];\nint n,mst=0;\nvoid init()\n{\n    memset(minn,INF,sizeof(minn));\n    minn[1]=0;\n    memset(vis,true,sizeof(vis));\n}\nint main()\n{\n    cin>>n;\n\tinit();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>graph[i][j];\n    for(int i=1;i<=n;i++)\n    {\n        int k=0;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(minn[j]<minn[k]))\n                k=j;\n        vis[k]=false;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(graph[k][j]<minn[j]))\n                minn[j]=graph[k][j];\n    }\n    for(int i=1;i<=n;i++)  mst+=minn[i];\n    cout<<mst;\n    return 0;\n}\n```\n# Kruskal\n## 基本信息\n- Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。\n- Kruskal 算法将一个连通块当做一个集合。\n\n时间复杂度为 $O(E\\ log(E))$，E为边数。\n## 算法思想\n1. 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 $n$ 个独立的集合。\n2. 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。\n3. 直到选取了 $n-1$ 条边为止。\n\n通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的\n边，一张 $n$ 个顶点的图总共选取 $n-1$ 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 $n$ 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 $n-1$ 条边，连接着 $n$ 个顶点的最小生成树。\n## 算法描述\n1. 初始化并查集：`fa[x]=x`，初始化总权值和：`mst=0`\n2. 将所有边用快排 **从小到大** 排序\n3. 计数器 `k=0`\n4.   \n```cpp\nfor(int i=1;i<=m;i++)\n{\n    if(这是一条 u,v 不属于同一集合的边 u->v)\n    {\n        1. 合并 u,v 所在的集合，相当于把 u->v 加入最小生成树\n        2. mst+=weight[u][v]\n        3. k++;\n        4. if(k==n-1)  break; 最小生成树已经生成，跳出循环\n    }\n}\n```\n5. 算法结束，`mst` 即为最小生成树的总权值之和\n## 例题 - [Luogu P3366](https://luogu.com.cn/problem/P3366)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=2e5+5;\nstruct Edge\n{\n    int u,v,w;\n}edge[LEN];\nint cnt;\nint fa[5005];\nint n,m,mst=0,edges_cnt=0;\nint find(int x)\n{\n    if(fa[x]!=x)  fa[x]=find(fa[x]);\n    return fa[x];\n}\nvoid merge(int x,int y)\n{\n    int fx=find(x);\n    int fy=find(y);\n    if(fx!=fy)  fa[fx]=fy;\n    return;\n}\nvoid addedge(int u,int v,int w)\n{\n    cnt+=1;\n    edge[cnt].u=u;\n    edge[cnt].v=v;\n    edge[cnt].w=w;\n    return;\n}\nbool cmp(Edge a,Edge b){return a.w<b.w;}\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        addedge(u,v,w);\n    }\n    for(int i=1;i<=n;i++)  fa[i]=i;\n    stable_sort(edge+1,edge+cnt+1,cmp);\n    for(int i=1;i<=cnt;i++)\n    {\n        if(find(edge[i].u)!=find(edge[i].v))\n        {\n            merge(edge[i].u,edge[i].v);\n            mst+=edge[i].w;\n            edges_cnt++;\n        }\n        if(edges_cnt==m)  break;\n    }\n    if(edges_cnt<n-1)  cout<<\"orz\";\n    else  cout<<mst;\n    return 0;\n}\n```","source":"_posts/最小生成树.md","raw":"---\ntitle: 图论 - 最小生成树\ndate: 2025-07-10 20:01:47\nbanner: https://imghub.ed-builder.top/file/1751761219115_5.png\ncover: https://imghub.ed-builder.top/file/1751761219115_5.png\ntags: ['图论', '最小生成树', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图论 - 最小生成树\n    topic: 大多适用于连接各种节点\nkatex: true\nauthor: ED_Builder\n---\n\n本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal\n\n<!-- more -->\n\n# Prim（加点法）\n## 基本信息\n每次迭代选择边权最小的边对应的点，加入到最小生成树中。  \n算法从某个顶点 $start$ 开始，逐渐延伸覆盖整个连通网的所有顶点\n![pic-solution](https://imghub.ed-builder.top/file/1751761219115_5.png)\n\n时间复杂度：$O(n^2)$\n## 算法思想\n蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。  \n每次循环都将一个蓝点 $u$ 变为白点，并且这个蓝点 $u$ 与白点相连的最小边权 `min(weight[u])` 还是当前所有蓝点中最小的。  \n这样相当于向生成树中添加了 $n-1$ 次最小的边，最后得到的一定是最小生成树\n## 算法描述\n以 $1$ 为起点生成最小生成树，`min[v]` 表示蓝点 `v` 与白点相连的最小边权，`mst` 表示最小生成树的权值之和\n1. 初始化：`min[v]=INF`$(v\\ne 1)$ &nbsp; `min[1]=0` &nbsp; `mst=0`\n2.   \n```cpp\nfor(int i=1;i<=n;i++)\n{\n\t1. 寻找 min[u] 最小的蓝点 u\n\t2. 将 u 标记为白点\n\t3. mst+=min[u];\n\t4. for(与白点 u 相连的所有蓝点 v)\n\t\tif(weight[u][v]<min[v])\n\t\t\tmin[v]=weight[u][v];\n}\n```\n3. 算法结束，`mst` 即为最小生成树的权值之和\n## 例题 - [YBT 1349](https://ybt.ssoier.cn/problem_show.php?pid=1349)\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN];\nint minn[LEN];\nbool vis[LEN];\nint n,mst=0;\nvoid init()\n{\n    memset(minn,INF,sizeof(minn));\n    minn[1]=0;\n    memset(vis,true,sizeof(vis));\n}\nint main()\n{\n    cin>>n;\n\tinit();\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            cin>>graph[i][j];\n    for(int i=1;i<=n;i++)\n    {\n        int k=0;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(minn[j]<minn[k]))\n                k=j;\n        vis[k]=false;\n        for(int j=1;j<=n;j++)\n            if(vis[j]&&(graph[k][j]<minn[j]))\n                minn[j]=graph[k][j];\n    }\n    for(int i=1;i<=n;i++)  mst+=minn[i];\n    cout<<mst;\n    return 0;\n}\n```\n# Kruskal\n## 基本信息\n- Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。\n- Kruskal 算法将一个连通块当做一个集合。\n\n时间复杂度为 $O(E\\ log(E))$，E为边数。\n## 算法思想\n1. 首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 $n$ 个独立的集合。\n2. 然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。\n3. 直到选取了 $n-1$ 条边为止。\n\n通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的\n边，一张 $n$ 个顶点的图总共选取 $n-1$ 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 $n$ 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 $n-1$ 条边，连接着 $n$ 个顶点的最小生成树。\n## 算法描述\n1. 初始化并查集：`fa[x]=x`，初始化总权值和：`mst=0`\n2. 将所有边用快排 **从小到大** 排序\n3. 计数器 `k=0`\n4.   \n```cpp\nfor(int i=1;i<=m;i++)\n{\n    if(这是一条 u,v 不属于同一集合的边 u->v)\n    {\n        1. 合并 u,v 所在的集合，相当于把 u->v 加入最小生成树\n        2. mst+=weight[u][v]\n        3. k++;\n        4. if(k==n-1)  break; 最小生成树已经生成，跳出循环\n    }\n}\n```\n5. 算法结束，`mst` 即为最小生成树的总权值之和\n## 例题 - [Luogu P3366](https://luogu.com.cn/problem/P3366)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=2e5+5;\nstruct Edge\n{\n    int u,v,w;\n}edge[LEN];\nint cnt;\nint fa[5005];\nint n,m,mst=0,edges_cnt=0;\nint find(int x)\n{\n    if(fa[x]!=x)  fa[x]=find(fa[x]);\n    return fa[x];\n}\nvoid merge(int x,int y)\n{\n    int fx=find(x);\n    int fy=find(y);\n    if(fx!=fy)  fa[fx]=fy;\n    return;\n}\nvoid addedge(int u,int v,int w)\n{\n    cnt+=1;\n    edge[cnt].u=u;\n    edge[cnt].v=v;\n    edge[cnt].w=w;\n    return;\n}\nbool cmp(Edge a,Edge b){return a.w<b.w;}\nsigned main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        addedge(u,v,w);\n    }\n    for(int i=1;i<=n;i++)  fa[i]=i;\n    stable_sort(edge+1,edge+cnt+1,cmp);\n    for(int i=1;i<=cnt;i++)\n    {\n        if(find(edge[i].u)!=find(edge[i].v))\n        {\n            merge(edge[i].u,edge[i].v);\n            mst+=edge[i].w;\n            edges_cnt++;\n        }\n        if(edges_cnt==m)  break;\n    }\n    if(edges_cnt<n-1)  cout<<\"orz\";\n    else  cout<<mst;\n    return 0;\n}\n```","slug":"最小生成树","published":1,"updated":"2025-07-29T11:44:20.062Z","comments":1,"layout":"post","photos":[],"_id":"cmdohm0nm0007zgbohssgf8ju","content":"<p>本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal</p>\n<span id=\"more\"></span>\n<h1 id=\"prim加点法\"><a class=\"markdownIt-Anchor\" href=\"#prim加点法\"></a> Prim（加点法）</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>每次迭代选择边权最小的边对应的点，加入到最小生成树中。<br />\n算法从某个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span></span></span></span> 开始，逐渐延伸覆盖整个连通网的所有顶点<br />\n<img src=\"https://imghub.ed-builder.top/file/1751761219115_5.png\" alt=\"pic-solution\" /></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法思想\"><a class=\"markdownIt-Anchor\" href=\"#算法思想\"></a> 算法思想</h2>\n<p>蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。<br />\n每次循环都将一个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 变为白点，并且这个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与白点相连的最小边权 <code>min(weight[u])</code> 还是当前所有蓝点中最小的。<br />\n这样相当于向生成树中添加了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次最小的边，最后得到的一定是最小生成树</p>\n<h2 id=\"算法描述\"><a class=\"markdownIt-Anchor\" href=\"#算法描述\"></a> 算法描述</h2>\n<p>以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点生成最小生成树，<code>min[v]</code> 表示蓝点 <code>v</code> 与白点相连的最小边权，<code>mst</code> 表示最小生成树的权值之和</p>\n<ol>\n<li>初始化：<code>min[v]=INF</code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo mathvariant=\"normal\">≠</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(v\\ne 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>   <code>min[1]=0</code>   <code>mst=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">1.</span> 寻找 min[u] 最小的蓝点 u</span><br><span class=\"line\">    <span class=\"number\">2.</span> 将 u 标记为白点</span><br><span class=\"line\">    <span class=\"number\">3.</span> mst+=min[u];</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"keyword\">for</span>(与白点 u 相连的所有蓝点 v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(weight[u][v]&lt;min[v])</span><br><span class=\"line\">            min[v]=weight[u][v];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>算法结束，<code>mst</code> 即为最小生成树的权值之和</li>\n</ol>\n<h2 id=\"例题-ybt-1349\"><a class=\"markdownIt-Anchor\" href=\"#例题-ybt-1349\"></a> 例题 - <a href=\"https://ybt.ssoier.cn/problem_show.php?pid=1349\">YBT 1349</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> minn[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,mst=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(minn,INF,<span class=\"built_in\">sizeof</span>(minn));</span><br><span class=\"line\">    minn[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;graph[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(minn[j]&lt;minn[k]))</span><br><span class=\"line\">                k=j;</span><br><span class=\"line\">        vis[k]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(graph[k][j]&lt;minn[j]))</span><br><span class=\"line\">                minn[j]=graph[k][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  mst+=minn[i];</span><br><span class=\"line\">    cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"kruskal\"><a class=\"markdownIt-Anchor\" href=\"#kruskal\"></a> Kruskal</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<ul>\n<li>Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。</li>\n<li>Kruskal 算法将一个连通块当做一个集合。</li>\n</ul>\n<p>时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(E\\ log(E))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，E为边数。</p>\n<h2 id=\"算法思想-2\"><a class=\"markdownIt-Anchor\" href=\"#算法思想-2\"></a> 算法思想</h2>\n<ol>\n<li>首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个独立的集合。</li>\n<li>然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。</li>\n<li>直到选取了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边为止。</li>\n</ol>\n<p>通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的<br />\n边，一张 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的图总共选取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边，连接着 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最小生成树。</p>\n<h2 id=\"算法描述-2\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-2\"></a> 算法描述</h2>\n<ol>\n<li>初始化并查集：<code>fa[x]=x</code>，初始化总权值和：<code>mst=0</code></li>\n<li>将所有边用快排 <strong>从小到大</strong> 排序</li>\n<li>计数器 <code>k=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(这是一条 u,v 不属于同一集合的边 u-&gt;v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"number\">1.</span> 合并 u,v 所在的集合，相当于把 u-&gt;v 加入最小生成树</span><br><span class=\"line\">        <span class=\"number\">2.</span> mst+=weight[u][v]</span><br><span class=\"line\">        <span class=\"number\">3.</span> k++;</span><br><span class=\"line\">        <span class=\"number\">4.</span> <span class=\"keyword\">if</span>(k==n<span class=\"number\">-1</span>)  <span class=\"keyword\">break</span>; 最小生成树已经生成，跳出循环</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>算法结束，<code>mst</code> 即为最小生成树的总权值之和</li>\n</ol>\n<h2 id=\"例题-luogu-p3366\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3366\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3366\">Luogu P3366</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> fa[<span class=\"number\">5005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,mst=<span class=\"number\">0</span>,edges_cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fa[x]!=x)  fa[x]=<span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    <span class=\"type\">int</span> fy=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fx!=fy)  fa[fx]=fy;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    edge[cnt].u=u;</span><br><span class=\"line\">    edge[cnt].v=v;</span><br><span class=\"line\">    edge[cnt].w=w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a,Edge b)</span></span>&#123;<span class=\"keyword\">return</span> a.w&lt;b.w;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  fa[i]=i;</span><br><span class=\"line\">    <span class=\"built_in\">stable_sort</span>(edge<span class=\"number\">+1</span>,edge+cnt<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(edge[i].u)!=<span class=\"built_in\">find</span>(edge[i].v))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">merge</span>(edge[i].u,edge[i].v);</span><br><span class=\"line\">            mst+=edge[i].w;</span><br><span class=\"line\">            edges_cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges_cnt==m)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(edges_cnt&lt;n<span class=\"number\">-1</span>)  cout&lt;&lt;<span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>本文主要介绍了图论中最小生成树问题的 2 种算法：Prim 和 Kruskal</p>","more":"<h1 id=\"prim加点法\"><a class=\"markdownIt-Anchor\" href=\"#prim加点法\"></a> Prim（加点法）</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>每次迭代选择边权最小的边对应的点，加入到最小生成树中。<br />\n算法从某个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">start</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span></span></span></span> 开始，逐渐延伸覆盖整个连通网的所有顶点<br />\n<img src=\"https://imghub.ed-builder.top/file/1751761219115_5.png\" alt=\"pic-solution\" /></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法思想\"><a class=\"markdownIt-Anchor\" href=\"#算法思想\"></a> 算法思想</h2>\n<p>蓝白点思想：白点表示已经进入最小生成树的点，蓝点表示没有进入最小生成树的点。<br />\n每次循环都将一个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 变为白点，并且这个蓝点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 与白点相连的最小边权 <code>min(weight[u])</code> 还是当前所有蓝点中最小的。<br />\n这样相当于向生成树中添加了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次最小的边，最后得到的一定是最小生成树</p>\n<h2 id=\"算法描述\"><a class=\"markdownIt-Anchor\" href=\"#算法描述\"></a> 算法描述</h2>\n<p>以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 为起点生成最小生成树，<code>min[v]</code> 表示蓝点 <code>v</code> 与白点相连的最小边权，<code>mst</code> 表示最小生成树的权值之和</p>\n<ol>\n<li>初始化：<code>min[v]=INF</code><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>v</mi><mo mathvariant=\"normal\">≠</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(v\\ne 1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\"><span class=\"mord vbox\"><span class=\"thinbox\"><span class=\"rlap\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"inner\"><span class=\"mrel\"></span></span><span class=\"fix\"></span></span></span></span></span><span class=\"mrel\">=</span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>   <code>min[1]=0</code>   <code>mst=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"number\">1.</span> 寻找 min[u] 最小的蓝点 u</span><br><span class=\"line\">    <span class=\"number\">2.</span> 将 u 标记为白点</span><br><span class=\"line\">    <span class=\"number\">3.</span> mst+=min[u];</span><br><span class=\"line\">    <span class=\"number\">4.</span> <span class=\"keyword\">for</span>(与白点 u 相连的所有蓝点 v)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(weight[u][v]&lt;min[v])</span><br><span class=\"line\">            min[v]=weight[u][v];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>算法结束，<code>mst</code> 即为最小生成树的权值之和</li>\n</ol>\n<h2 id=\"例题-ybt-1349\"><a class=\"markdownIt-Anchor\" href=\"#例题-ybt-1349\"></a> 例题 - <a href=\"https://ybt.ssoier.cn/problem_show.php?pid=1349\">YBT 1349</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> minn[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,mst=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(minn,INF,<span class=\"built_in\">sizeof</span>(minn));</span><br><span class=\"line\">    minn[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">true</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;graph[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(minn[j]&lt;minn[k]))</span><br><span class=\"line\">                k=j;</span><br><span class=\"line\">        vis[k]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[j]&amp;&amp;(graph[k][j]&lt;minn[j]))</span><br><span class=\"line\">                minn[j]=graph[k][j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  mst+=minn[i];</span><br><span class=\"line\">    cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"kruskal\"><a class=\"markdownIt-Anchor\" href=\"#kruskal\"></a> Kruskal</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<ul>\n<li>Kruskal 算法是一种巧妙利用并查集来求最小生成树的算法。</li>\n<li>Kruskal 算法将一个连通块当做一个集合。</li>\n</ul>\n<p>时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>E</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(E\\ log(E))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span>，E为边数。</p>\n<h2 id=\"算法思想-2\"><a class=\"markdownIt-Anchor\" href=\"#算法思想-2\"></a> 算法思想</h2>\n<ol>\n<li>首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个顶点都是孤立的，分属于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个独立的集合。</li>\n<li>然后按顺序枚举每一条边，如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点属于同一集合，就跳过。</li>\n<li>直到选取了 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边为止。</li>\n</ol>\n<p>通过上面的模拟能够看到，Kruskal 算法每次都选择一条最小的，且能合并两个不同集合的<br />\n边，一张 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的图总共选取 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 次边。因为每次我们选的都是最小的边，所以最后的生成树一定是最小生成树。每次我们选的边都能够合并两个集合，最后 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点一定会合并成一个集合。通过这样的贪心策略，Kruskal 算法就能得到一棵有 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 条边，连接着 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最小生成树。</p>\n<h2 id=\"算法描述-2\"><a class=\"markdownIt-Anchor\" href=\"#算法描述-2\"></a> 算法描述</h2>\n<ol>\n<li>初始化并查集：<code>fa[x]=x</code>，初始化总权值和：<code>mst=0</code></li>\n<li>将所有边用快排 <strong>从小到大</strong> 排序</li>\n<li>计数器 <code>k=0</code></li>\n<li></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(这是一条 u,v 不属于同一集合的边 u-&gt;v)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"number\">1.</span> 合并 u,v 所在的集合，相当于把 u-&gt;v 加入最小生成树</span><br><span class=\"line\">        <span class=\"number\">2.</span> mst+=weight[u][v]</span><br><span class=\"line\">        <span class=\"number\">3.</span> k++;</span><br><span class=\"line\">        <span class=\"number\">4.</span> <span class=\"keyword\">if</span>(k==n<span class=\"number\">-1</span>)  <span class=\"keyword\">break</span>; 最小生成树已经生成，跳出循环</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>算法结束，<code>mst</code> 即为最小生成树的总权值之和</li>\n</ol>\n<h2 id=\"例题-luogu-p3366\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3366\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3366\">Luogu P3366</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> fa[<span class=\"number\">5005</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,mst=<span class=\"number\">0</span>,edges_cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fa[x]!=x)  fa[x]=<span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> fx=<span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    <span class=\"type\">int</span> fy=<span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fx!=fy)  fa[fx]=fy;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt+=<span class=\"number\">1</span>;</span><br><span class=\"line\">    edge[cnt].u=u;</span><br><span class=\"line\">    edge[cnt].v=v;</span><br><span class=\"line\">    edge[cnt].w=w;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a,Edge b)</span></span>&#123;<span class=\"keyword\">return</span> a.w&lt;b.w;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  fa[i]=i;</span><br><span class=\"line\">    <span class=\"built_in\">stable_sort</span>(edge<span class=\"number\">+1</span>,edge+cnt<span class=\"number\">+1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=cnt;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(edge[i].u)!=<span class=\"built_in\">find</span>(edge[i].v))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">merge</span>(edge[i].u,edge[i].v);</span><br><span class=\"line\">            mst+=edge[i].w;</span><br><span class=\"line\">            edges_cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges_cnt==m)  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(edges_cnt&lt;n<span class=\"number\">-1</span>)  cout&lt;&lt;<span class=\"string\">&quot;orz&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>  cout&lt;&lt;mst;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"图论 - 最短路","date":"2025-07-10T12:01:47.000Z","banner":"https://imghub.ed-builder.top/file/sTEM0QcE.png","cover":"https://imghub.ed-builder.top/file/sTEM0QcE.png","poster":{"headline":"图论 - 最短路","topic":"多种算法，多种应用场景"},"katex":true,"author":"ED_Builder","_content":"\n本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA\n\n<!-- more -->\n\n# Floyd\n## 基本信息\n定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 $a$ 到顶点 $b$）之间的路程变短，只能引入第三个点（顶点 $k$），并通过这个顶点 $k$ 中转，即 `a->k->b`，才可能缩短原来从顶点 $a$ 到顶点 $b$ 的路程。\n\n原理：三重循环枚举中转点 `k`，状态转移方程：`dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])`\n\n时间复杂度：$O(n^3)$\n## 算法步骤\n由于在图中 **没有负环** 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。\n## 例题 - [Luogu B3647](https://luogu.com.cn/problem/B3647)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN],n,m;\nsigned main()\n{\n    cin>>n>>m;\n    memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连\n    for(int i=1;i<=n;i++)  graph[i][i]=0;//自己到自己为 0\n    while(m--)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值\n    }\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n                //暴力查找第三点 k，以及通过边权求最小值\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(graph[i][j]==INF)  cout<<0<<' ';//没有边相连\n            else  cout<<graph[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n~~上面这玩意只有 80pts~~\n\n---\n# Dijkstra\n## 基本信息\n定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。  \n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 **所有的边权全部非负**。\n\n原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。\n\n时间复杂度：$O(n^2)$\n## 算法步骤\n1. 初始化 `graph[v0]=0` ，**出发点** 到其他顶点的距离 `graph[i]=INF`\n2. 经过 $n$ 次下面的操作，最后得到 $v_0$ 到 $n$ 个顶点的最短距离  \n1\\. 选择一个未被标记的、且 `graph[k]` 的值是最小的顶点 $k$  \n2\\. 标记顶点 $k$，即 `vis[k]=true`  \n3\\. 以 $k$ 为中间点，修改出发点 $v_0$ 到其他未被标记的顶点的 $j$ 的距离值 `graph[j]`\n3. 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2  \n1\\. 在集合 2 中找一个到出发点距离最近的顶点 $k$： $min\\{dis[k]\\}$  \n2\\. 把顶点 $k$ 加到集合 1 中，同时检查集合 2 中的剩余顶点 $j$ 的 `dis[j]` 是否经过 $k$ 后变短，如果变短修改 `dis[j]`  \n`if(dis[k]+wait[k][j]<dis[j])  dis[j]=dis[k]+wait[k][j]`  \n3\\. 重复步骤 3.1 ，直至集合 2 空为止\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)（但是弱化版）\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint pos=s;\n\twhile(vis[pos]==0)\n\t{\n\t\tint minn=INF;\n\t\tvis[pos]=true;\n\t\tfor(int i=head[pos];i!=0;i=edge[i].nxt)\n\t\t\tif(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].weight)\n\t\t\t\tans[edge[i].to]=ans[pos]+edge[i].weight;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ans[i]<minn&&vis[i]==0)\n\t\t\t{\n\t\t\t\tminn=ans[i];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 `dis[]` 中的最小值，所以我们可以用……\n## 堆优化\n堆是一种可以在 $O(log(n))$ 的时间插入数据，$O(1)$ 的时间删除和查找当前极值（最大或最小值）  \n那么原来求最小值的 $O(n)$ 的算法，可以改为使用堆来求最小值，时间复杂度降到 $O(log(n))$ ，整体复杂度降到 $O(n\\ log(n))$  \n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）\n\n对于 Dijkstra 的堆优化有两种方法:\n1. 重载运算符\n2. 两元组\n## 例题 - [Luogu P4779](https://luogu.com.cn/problem/P4779)（但是标准版）\n别想把 P3371 的代码交上去，全部 TLE\n### Solution-1 重载运算符\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=0x3f;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nstruct Priority\n{\n    int ans,id;\n    bool operator <(const Priority &x)const{return x.ans<ans;}\n};\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n    return;\n}\nvoid init()\n{\n\tmemset(ans,INF,sizeof(ans));\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tinit();\n\tcin>>m>>n>>s;\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint u;\n    priority_queue<Priority> q;\n    q.push((Priority){0,s});\n\twhile(!q.empty())\n    {\n        Priority tmp=q.top();\n        q.pop();\n        u=tmp.id;\n        if(!vis[u])\n        {\n            vis[u]=true;\n            for(int i=head[u];i;i=edge[i].nxt)\n            {\n                int v=edge[i].to;\n                if(ans[v]>ans[u]+edge[i].weight)\n                {\n                    ans[v]=ans[u]+edge[i].weight;\n                    if(!vis[v])  q.push((Priority){ans[v],v});\n                }\n            }\n        }\n    }\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n    return 0;\n}\n```\n### Solution-2 两元组\n```cpp\n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tpriority_queue<pii,vector<pii>,greater<pii> >q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tans[s]=0;\n\tq.push(pii{0,s});\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tpii x=q.top();\n\t\tq.pop();\n\t\tif(vis[x.second])  continue;\n\t\tu=x.second;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=edge[i].nxt)\n\t\t{\n\t\t\tif(ans[edge[i].to]>ans[u]+edge[i].weight)\n\t\t\t{\n\t\t\t\tans[edge[i].to]=ans[u]+edge[i].weight;\n\t\t\t\tq.push(pii(ans[edge[i].to],edge[i].to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n\n---\n# SPFA\nSPFA 是 Bellman-Ford 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n## 基本信息\n定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n\nSPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。\n\n时间复杂度：$O(kE)$，$E$ 是边数，$k$ 是常数，平均值是 $2$\n## 算法步骤\n1. 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改\n2. 若某个相邻的顶点修改成功，则将其入队\n3. 队列为空时，算法结束\n## 实现方法\n1. 建立一个队列，并且将出发点入列，用 `dis[i]` 记录出发点到其他所有点的最短路径\n2. 执行松弛操作，一次用队列里有的点 $u$ 去更新所有后继节点 $v_i$ 的最短路，如果 $v_i$ 被更新成功且不在队列中，则把 $v_i$ 加入队列，重复执行直到队列为空\n3. 节点可能多次被更新，可以多次进入队列  \n`if(dis[u]+w<dis[v])  d[v]=d[u]+w;`\n4. 如果 $V$ 被更新了且队列中不存在，再一次进入队列\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=5e5+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[2*LEN];\nint cnt=0,head[LEN],dis[LEN];\nbool vis[LEN];\nint n,m,start;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n\treturn;\n}\nvoid SPFA()\n{\n\tqueue<int> q;\n\tdis[start]=0;\n\tq.push(start);\n\tvis[start]=true;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].nxt)\n\t\t{\n\t\t\tint to=edge[i].to;\n\t\t\tif(edge[i].weight+dis[now]<=dis[to])\n\t\t\t{\n\t\t\t\tdis[to]=edge[i].weight+dis[now];\n\t\t\t\tif(!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  dis[i]=INF;\n\tmemset(head,0,sizeof(head));\n\treturn;\n}\nsigned main()\n{\n\tcin>>n>>m>>start;\n\tinit();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tSPFA();\n\tfor(int i=1;i<=n;i++)  cout<<dis[i]<<' ';\n\treturn 0;\n}\n```\n有些考试会用数据卡掉 SPFA 导致 TLE，比如 [Luogu P4779](https://luogu.com.cn/problem/P4779) 会导致 SPFA 算法在 [\\#1,2,3,5,6 TLE](https://luogu.com.cn/record/222522444)  \nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别\n\n---\n# 总结\nFloyd 最简单，多源最短路大暴力，$O(n^3)$ 复杂度卡死你  \nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 $O(n\\ log(n))$  \nSPFA 易理解，和 BFS 很类似，[某些题目](https://luogu.com.cn/problem/P4768) 会卡掉，慎重选择需技巧\n\n被迫回去看链式前向星的笔记了 :\\(","source":"_posts/最短路.md","raw":"---\ntitle: 图论 - 最短路\ndate: 2025-07-10 20:01:47\nbanner: https://imghub.ed-builder.top/file/sTEM0QcE.png\ncover: https://imghub.ed-builder.top/file/sTEM0QcE.png\ntags: ['图论', '最短路', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图论 - 最短路\n    topic: 多种算法，多种应用场景\nkatex: true\nauthor: ED_Builder\n---\n\n本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA\n\n<!-- more -->\n\n# Floyd\n## 基本信息\n定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 $a$ 到顶点 $b$）之间的路程变短，只能引入第三个点（顶点 $k$），并通过这个顶点 $k$ 中转，即 `a->k->b`，才可能缩短原来从顶点 $a$ 到顶点 $b$ 的路程。\n\n原理：三重循环枚举中转点 `k`，状态转移方程：`dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])`\n\n时间复杂度：$O(n^3)$\n## 算法步骤\n由于在图中 **没有负环** 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。\n## 例题 - [Luogu B3647](https://luogu.com.cn/problem/B3647)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=105,INF=0x3f;\nint graph[LEN][LEN],n,m;\nsigned main()\n{\n    cin>>n>>m;\n    memset(graph,INF,sizeof(graph));//初始化为任何顶点都没有相连\n    for(int i=1;i<=n;i++)  graph[i][i]=0;//自己到自己为 0\n    while(m--)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u][v]=graph[v][u]=min(graph[u][v],w);//最小值\n    }\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n                graph[i][j]=min(graph[i][j],graph[i][k]+graph[k][j]);\n                //暴力查找第三点 k，以及通过边权求最小值\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(graph[i][j]==INF)  cout<<0<<' ';//没有边相连\n            else  cout<<graph[i][j]<<' ';\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n```\n~~上面这玩意只有 80pts~~\n\n---\n# Dijkstra\n## 基本信息\n定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。  \n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 **所有的边权全部非负**。\n\n原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。\n\n时间复杂度：$O(n^2)$\n## 算法步骤\n1. 初始化 `graph[v0]=0` ，**出发点** 到其他顶点的距离 `graph[i]=INF`\n2. 经过 $n$ 次下面的操作，最后得到 $v_0$ 到 $n$ 个顶点的最短距离  \n1\\. 选择一个未被标记的、且 `graph[k]` 的值是最小的顶点 $k$  \n2\\. 标记顶点 $k$，即 `vis[k]=true`  \n3\\. 以 $k$ 为中间点，修改出发点 $v_0$ 到其他未被标记的顶点的 $j$ 的距离值 `graph[j]`\n3. 将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2  \n1\\. 在集合 2 中找一个到出发点距离最近的顶点 $k$： $min\\{dis[k]\\}$  \n2\\. 把顶点 $k$ 加到集合 1 中，同时检查集合 2 中的剩余顶点 $j$ 的 `dis[j]` 是否经过 $k$ 后变短，如果变短修改 `dis[j]`  \n`if(dis[k]+wait[k][j]<dis[j])  dis[j]=dis[k]+wait[k][j]`  \n3\\. 重复步骤 3.1 ，直至集合 2 空为止\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)（但是弱化版）\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint pos=s;\n\twhile(vis[pos]==0)\n\t{\n\t\tint minn=INF;\n\t\tvis[pos]=true;\n\t\tfor(int i=head[pos];i!=0;i=edge[i].nxt)\n\t\t\tif(!vis[edge[i].to]&&ans[edge[i].to]>ans[pos]+edge[i].weight)\n\t\t\t\tans[edge[i].to]=ans[pos]+edge[i].weight;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(ans[i]<minn&&vis[i]==0)\n\t\t\t{\n\t\t\t\tminn=ans[i];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 `dis[]` 中的最小值，所以我们可以用……\n## 堆优化\n堆是一种可以在 $O(log(n))$ 的时间插入数据，$O(1)$ 的时间删除和查找当前极值（最大或最小值）  \n那么原来求最小值的 $O(n)$ 的算法，可以改为使用堆来求最小值，时间复杂度降到 $O(log(n))$ ，整体复杂度降到 $O(n\\ log(n))$  \n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）\n\n对于 Dijkstra 的堆优化有两种方法:\n1. 重载运算符\n2. 两元组\n## 例题 - [Luogu P4779](https://luogu.com.cn/problem/P4779)（但是标准版）\n别想把 P3371 的代码交上去，全部 TLE\n### Solution-1 重载运算符\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=0x3f;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nstruct Priority\n{\n    int ans,id;\n    bool operator <(const Priority &x)const{return x.ans<ans;}\n};\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n    return;\n}\nvoid init()\n{\n\tmemset(ans,INF,sizeof(ans));\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tinit();\n\tcin>>m>>n>>s;\n\tans[s]=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tint u;\n    priority_queue<Priority> q;\n    q.push((Priority){0,s});\n\twhile(!q.empty())\n    {\n        Priority tmp=q.top();\n        q.pop();\n        u=tmp.id;\n        if(!vis[u])\n        {\n            vis[u]=true;\n            for(int i=head[u];i;i=edge[i].nxt)\n            {\n                int v=edge[i].to;\n                if(ans[v]>ans[u]+edge[i].weight)\n                {\n                    ans[v]=ans[u]+edge[i].weight;\n                    if(!vis[v])  q.push((Priority){ans[v],v});\n                }\n            }\n        }\n    }\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n    return 0;\n}\n```\n### Solution-2 两元组\n```cpp\n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define int long long\nusing namespace std;\nconst int LEN=1e6+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[LEN];\nint head[LEN],cnt;\nint ans[LEN];\nbool vis[LEN];\nint m,n,s;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  ans[i]=INF;\n\tmemset(vis,false,sizeof(vis));\n\tmemset(head,0,sizeof(head));\n}\nsigned main()\n{\n\tcin>>m>>n>>s;\n\tinit();\n\tpriority_queue<pii,vector<pii>,greater<pii> >q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tans[s]=0;\n\tq.push(pii{0,s});\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tpii x=q.top();\n\t\tq.pop();\n\t\tif(vis[x.second])  continue;\n\t\tu=x.second;\n\t\tvis[u]=true;\n\t\tfor(int i=head[u];i;i=edge[i].nxt)\n\t\t{\n\t\t\tif(ans[edge[i].to]>ans[u]+edge[i].weight)\n\t\t\t{\n\t\t\t\tans[edge[i].to]=ans[u]+edge[i].weight;\n\t\t\t\tq.push(pii(ans[edge[i].to],edge[i].to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)  cout<<ans[i]<<' ';\n\treturn 0;\n}\n```\n\n---\n# SPFA\nSPFA 是 Bellman-Ford 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n## 基本信息\n定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 **队列优化**，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算\n\nSPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。\n\n时间复杂度：$O(kE)$，$E$ 是边数，$k$ 是常数，平均值是 $2$\n## 算法步骤\n1. 初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改\n2. 若某个相邻的顶点修改成功，则将其入队\n3. 队列为空时，算法结束\n## 实现方法\n1. 建立一个队列，并且将出发点入列，用 `dis[i]` 记录出发点到其他所有点的最短路径\n2. 执行松弛操作，一次用队列里有的点 $u$ 去更新所有后继节点 $v_i$ 的最短路，如果 $v_i$ 被更新成功且不在队列中，则把 $v_i$ 加入队列，重复执行直到队列为空\n3. 节点可能多次被更新，可以多次进入队列  \n`if(dis[u]+w<dis[v])  d[v]=d[u]+w;`\n4. 如果 $V$ 被更新了且队列中不存在，再一次进入队列\n## 例题 - [Luogu P3371](https://luogu.com.cn/problem/P3371)\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int LEN=5e5+5,INF=pow(2,31)-1;\nstruct Edge\n{\n\tint to,nxt,weight;\n}edge[2*LEN];\nint cnt=0,head[LEN],dis[LEN];\nbool vis[LEN];\nint n,m,start;\nvoid addedge(int u,int v,int w)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].weight=w;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n\treturn;\n}\nvoid SPFA()\n{\n\tqueue<int> q;\n\tdis[start]=0;\n\tq.push(start);\n\tvis[start]=true;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tvis[now]=false;\n\t\tfor(int i=head[now];i;i=edge[i].nxt)\n\t\t{\n\t\t\tint to=edge[i].to;\n\t\t\tif(edge[i].weight+dis[now]<=dis[to])\n\t\t\t{\n\t\t\t\tdis[to]=edge[i].weight+dis[now];\n\t\t\t\tif(!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to);\n\t\t\t\t\tvis[to]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nvoid init()\n{\n\tfor(int i=1;i<=n;i++)  dis[i]=INF;\n\tmemset(head,0,sizeof(head));\n\treturn;\n}\nsigned main()\n{\n\tcin>>n>>m>>start;\n\tinit();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tcin>>u>>v>>w;\n\t\taddedge(u,v,w);\n\t}\n\tSPFA();\n\tfor(int i=1;i<=n;i++)  cout<<dis[i]<<' ';\n\treturn 0;\n}\n```\n有些考试会用数据卡掉 SPFA 导致 TLE，比如 [Luogu P4779](https://luogu.com.cn/problem/P4779) 会导致 SPFA 算法在 [\\#1,2,3,5,6 TLE](https://luogu.com.cn/record/222522444)  \nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别\n\n---\n# 总结\nFloyd 最简单，多源最短路大暴力，$O(n^3)$ 复杂度卡死你  \nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 $O(n\\ log(n))$  \nSPFA 易理解，和 BFS 很类似，[某些题目](https://luogu.com.cn/problem/P4768) 会卡掉，慎重选择需技巧\n\n被迫回去看链式前向星的笔记了 :\\(","slug":"最短路","published":1,"updated":"2025-07-29T11:44:20.062Z","comments":1,"layout":"post","photos":[],"_id":"cmdohm0np0008zgbob9kgg0ls","content":"<p>本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA</p>\n<span id=\"more\"></span>\n<h1 id=\"floyd\"><a class=\"markdownIt-Anchor\" href=\"#floyd\"></a> Floyd</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>）之间的路程变短，只能引入第三个点（顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>），并通过这个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 中转，即 <code>a-&gt;k-&gt;b</code>，才可能缩短原来从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 的路程。</p>\n<p>原理：三重循环枚举中转点 <code>k</code>，状态转移方程：<code>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</code></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤\"></a> 算法步骤</h2>\n<p>由于在图中 <strong>没有负环</strong> 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。</p>\n<h2 id=\"例题-luogu-b3647\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-b3647\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/B3647\">Luogu B3647</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN],n,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(graph,INF,<span class=\"built_in\">sizeof</span>(graph));<span class=\"comment\">//初始化为任何顶点都没有相连</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  graph[i][i]=<span class=\"number\">0</span>;<span class=\"comment\">//自己到自己为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        graph[u][v]=graph[v][u]=<span class=\"built_in\">min</span>(graph[u][v],w);<span class=\"comment\">//最小值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">                graph[i][j]=<span class=\"built_in\">min</span>(graph[i][j],graph[i][k]+graph[k][j]);</span><br><span class=\"line\">                <span class=\"comment\">//暴力查找第三点 k，以及通过边权求最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[i][j]==INF)  cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;<span class=\"comment\">//没有边相连</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  cout&lt;&lt;graph[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><s>上面这玩意只有 80pts</s></p>\n<hr />\n<h1 id=\"dijkstra\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra\"></a> Dijkstra</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<p>定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。<br />\n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 <strong>所有的边权全部非负</strong>。</p>\n<p>原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤-2\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-2\"></a> 算法步骤</h2>\n<ol>\n<li>初始化 <code>graph[v0]=0</code> ，<strong>出发点</strong> 到其他顶点的距离 <code>graph[i]=INF</code></li>\n<li>经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次下面的操作，最后得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最短距离<br />\n1. 选择一个未被标记的、且 <code>graph[k]</code> 的值是最小的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><br />\n2. 标记顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，即 <code>vis[k]=true</code><br />\n3. 以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为中间点，修改出发点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到其他未被标记的顶点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的距离值 <code>graph[j]</code></li>\n<li>将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2<br />\n1. 在集合 2 中找一个到出发点距离最近的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">min\\{dis[k]\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span><br />\n2. 把顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 加到集合 1 中，同时检查集合 2 中的剩余顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的 <code>dis[j]</code> 是否经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 后变短，如果变短修改 <code>dis[j]</code><br />\n<code>if(dis[k]+wait[k][j]&lt;dis[j])  dis[j]=dis[k]+wait[k][j]</code><br />\n3. 重复步骤 3.1 ，直至集合 2 空为止</li>\n</ol>\n<h2 id=\"例题-luogu-p3371但是弱化版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371但是弱化版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a>（但是弱化版）</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos=s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(vis[pos]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minn=INF;</span><br><span class=\"line\">        vis[pos]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[pos];i!=<span class=\"number\">0</span>;i=edge[i].nxt)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].weight)</span><br><span class=\"line\">                ans[edge[i].to]=ans[pos]+edge[i].weight;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                minn=ans[i];</span><br><span class=\"line\">                pos=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 <code>dis[]</code> 中的最小值，所以我们可以用……</p>\n<h2 id=\"堆优化\"><a class=\"markdownIt-Anchor\" href=\"#堆优化\"></a> 堆优化</h2>\n<p>堆是一种可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 的时间插入数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间删除和查找当前极值（最大或最小值）<br />\n那么原来求最小值的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法，可以改为使用堆来求最小值，时间复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> ，整体复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）</p>\n<p>对于 Dijkstra 的堆优化有两种方法:</p>\n<ol>\n<li>重载运算符</li>\n<li>两元组</li>\n</ol>\n<h2 id=\"例题-luogu-p4779但是标准版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p4779但是标准版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a>（但是标准版）</h2>\n<p>别想把 P3371 的代码交上去，全部 TLE</p>\n<h3 id=\"solution-1-重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#solution-1-重载运算符\"></a> Solution-1 重载运算符</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Priority</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans,id;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"type\">const</span> Priority &amp;x)<span class=\"type\">const</span>&#123;<span class=\"keyword\">return</span> x.ans&lt;ans;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,INF,<span class=\"built_in\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    priority_queue&lt;Priority&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Priority)&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Priority tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        u=tmp.id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[u])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> v=edge[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans[v]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans[v]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!vis[v])  q.<span class=\"built_in\">push</span>((Priority)&#123;ans[v],v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"solution-2-两元组\"><a class=\"markdownIt-Anchor\" href=\"#solution-2-两元组\"></a> Solution-2 两元组</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(pii&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pii x=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[x.second])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        u=x.second;</span><br><span class=\"line\">        vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[edge[i].to]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans[edge[i].to]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">pii</span>(ans[edge[i].to],edge[i].to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"spfa\"><a class=\"markdownIt-Anchor\" href=\"#spfa\"></a> SPFA</h1>\n<p>SPFA 是 Bellman-Ford 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<h2 id=\"基本信息-3\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-3\"></a> 基本信息</h2>\n<p>定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<p>SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(kE)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是边数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 是常数，平均值是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></p>\n<h2 id=\"算法步骤-3\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-3\"></a> 算法步骤</h2>\n<ol>\n<li>初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改</li>\n<li>若某个相邻的顶点修改成功，则将其入队</li>\n<li>队列为空时，算法结束</li>\n</ol>\n<h2 id=\"实现方法\"><a class=\"markdownIt-Anchor\" href=\"#实现方法\"></a> 实现方法</h2>\n<ol>\n<li>建立一个队列，并且将出发点入列，用 <code>dis[i]</code> 记录出发点到其他所有点的最短路径</li>\n<li>执行松弛操作，一次用队列里有的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 去更新所有后继节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的最短路，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 被更新成功且不在队列中，则把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入队列，重复执行直到队列为空</li>\n<li>节点可能多次被更新，可以多次进入队列<br />\n<code>if(dis[u]+w&lt;dis[v])  d[v]=d[u]+w;</code></li>\n<li>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 被更新了且队列中不存在，再一次进入队列</li>\n</ol>\n<h2 id=\"例题-luogu-p3371\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">2</span>*LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt=<span class=\"number\">0</span>,head[LEN],dis[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,start;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    dis[start]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    vis[start]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> now=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        vis[now]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> to=edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[i].weight+dis[now]&lt;=dis[to])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[to]=edge[i].weight+dis[now];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(to);</span><br><span class=\"line\">                    vis[to]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  dis[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;start;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SPFA</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;dis[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有些考试会用数据卡掉 SPFA 导致 TLE，比如 <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a> 会导致 SPFA 算法在 <a href=\"https://luogu.com.cn/record/222522444\">#1,2,3,5,6 TLE</a><br />\nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别</p>\n<hr />\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<p>Floyd 最简单，多源最短路大暴力，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 复杂度卡死你<br />\nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\nSPFA 易理解，和 BFS 很类似，<a href=\"https://luogu.com.cn/problem/P4768\">某些题目</a> 会卡掉，慎重选择需技巧</p>\n<p>被迫回去看链式前向星的笔记了 :(</p>\n","excerpt":"<p>本文主要介绍了图论中最短路问题的三种算法：Floyd、Dijkstra、SPFA</p>","more":"<h1 id=\"floyd\"><a class=\"markdownIt-Anchor\" href=\"#floyd\"></a> Floyd</h1>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>定义：多源最短路径算法，通过动态规划求解任意两点间最短距离。如果要让任意两点（例如从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span>）之间的路程变短，只能引入第三个点（顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>），并通过这个顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 中转，即 <code>a-&gt;k-&gt;b</code>，才可能缩短原来从顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">a</span></span></span></span> 到顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">b</span></span></span></span> 的路程。</p>\n<p>原理：三重循环枚举中转点 <code>k</code>，状态转移方程：<code>dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</code></p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤\"></a> 算法步骤</h2>\n<p>由于在图中 <strong>没有负环</strong> 的情况下（如果存在负环则不存在最短路），任意两点之间的最短路不会走重复的点，因此把 1~n 所有的点都作为中转点更新一遍答案，求得的结果就是所有点对之间的最短路。</p>\n<h2 id=\"例题-luogu-b3647\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-b3647\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/B3647\">Luogu B3647</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">105</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> graph[LEN][LEN],n,m;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(graph,INF,<span class=\"built_in\">sizeof</span>(graph));<span class=\"comment\">//初始化为任何顶点都没有相连</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  graph[i][i]=<span class=\"number\">0</span>;<span class=\"comment\">//自己到自己为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        graph[u][v]=graph[v][u]=<span class=\"built_in\">min</span>(graph[u][v],w);<span class=\"comment\">//最小值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">                graph[i][j]=<span class=\"built_in\">min</span>(graph[i][j],graph[i][k]+graph[k][j]);</span><br><span class=\"line\">                <span class=\"comment\">//暴力查找第三点 k，以及通过边权求最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[i][j]==INF)  cout&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;<span class=\"comment\">//没有边相连</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  cout&lt;&lt;graph[i][j]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><s>上面这玩意只有 80pts</s></p>\n<hr />\n<h1 id=\"dijkstra\"><a class=\"markdownIt-Anchor\" href=\"#dijkstra\"></a> Dijkstra</h1>\n<h2 id=\"基本信息-2\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-2\"></a> 基本信息</h2>\n<p>定义：Dijkstra 算法是求从一个点出发到其他所有点的最短路算法。<br />\n主要特点：以起始点为中心向外层层扩展，直到扩展到终点为止。算法要求 <strong>所有的边权全部非负</strong>。</p>\n<p>原理：算法原理：每次找出一个到起点距离最小，且没有使用过的点（由于边权非负，从起点到这个点的最短距离已经确定求出），从这个点出发更新起点到（与这个点相连的点）的距离。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></p>\n<h2 id=\"算法步骤-2\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-2\"></a> 算法步骤</h2>\n<ol>\n<li>初始化 <code>graph[v0]=0</code> ，<strong>出发点</strong> 到其他顶点的距离 <code>graph[i]=INF</code></li>\n<li>经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 次下面的操作，最后得到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个顶点的最短距离<br />\n1. 选择一个未被标记的、且 <code>graph[k]</code> 的值是最小的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span><br />\n2. 标记顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，即 <code>vis[k]=true</code><br />\n3. 以 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为中间点，修改出发点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">v_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 到其他未被标记的顶点的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的距离值 <code>graph[j]</code></li>\n<li>将顶点分为两个集合：已求得（已标记的）最短距离的点集合 1，待求点集合 2<br />\n1. 在集合 2 中找一个到出发点距离最近的顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>i</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">min\\{dis[k]\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span><br />\n2. 把顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 加到集合 1 中，同时检查集合 2 中的剩余顶点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 的 <code>dis[j]</code> 是否经过 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 后变短，如果变短修改 <code>dis[j]</code><br />\n<code>if(dis[k]+wait[k][j]&lt;dis[j])  dis[j]=dis[k]+wait[k][j]</code><br />\n3. 重复步骤 3.1 ，直至集合 2 空为止</li>\n</ol>\n<h2 id=\"例题-luogu-p3371但是弱化版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371但是弱化版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a>（但是弱化版）</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos=s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(vis[pos]==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> minn=INF;</span><br><span class=\"line\">        vis[pos]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[pos];i!=<span class=\"number\">0</span>;i=edge[i].nxt)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].weight)</span><br><span class=\"line\">                ans[edge[i].to]=ans[pos]+edge[i].weight;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                minn=ans[i];</span><br><span class=\"line\">                pos=i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，这样的算法太慢了！大部分的时间都浪费在了找点上，需要每次选取 <code>dis[]</code> 中的最小值，所以我们可以用……</p>\n<h2 id=\"堆优化\"><a class=\"markdownIt-Anchor\" href=\"#堆优化\"></a> 堆优化</h2>\n<p>堆是一种可以在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> 的时间插入数据，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的时间删除和查找当前极值（最大或最小值）<br />\n那么原来求最小值的 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span> 的算法，可以改为使用堆来求最小值，时间复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span> ，整体复杂度降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\n对于堆可以用手写的，也可以用 STL 中的优先队列（应该没人想用手写堆吧……）</p>\n<p>对于 Dijkstra 的堆优化有两种方法:</p>\n<ol>\n<li>重载运算符</li>\n<li>两元组</li>\n</ol>\n<h2 id=\"例题-luogu-p4779但是标准版\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p4779但是标准版\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a>（但是标准版）</h2>\n<p>别想把 P3371 的代码交上去，全部 TLE</p>\n<h3 id=\"solution-1-重载运算符\"><a class=\"markdownIt-Anchor\" href=\"#solution-1-重载运算符\"></a> Solution-1 重载运算符</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"number\">0x3f</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Priority</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans,id;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span> &lt;(<span class=\"type\">const</span> Priority &amp;x)<span class=\"type\">const</span>&#123;<span class=\"keyword\">return</span> x.ans&lt;ans;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(ans,INF,<span class=\"built_in\">sizeof</span>(ans));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    priority_queue&lt;Priority&gt; q;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>((Priority)&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Priority tmp=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        u=tmp.id;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!vis[u])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> v=edge[i].to;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans[v]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ans[v]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!vis[v])  q.<span class=\"built_in\">push</span>((Priority)&#123;ans[v],v&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"solution-2-两元组\"><a class=\"markdownIt-Anchor\" href=\"#solution-2-两元组\"></a> Solution-2 两元组</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> pii pair<span class=\"string\">&lt;int,int&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">1e6</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> head[LEN],cnt;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,s;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  ans[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"literal\">false</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans[s]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(pii&#123;<span class=\"number\">0</span>,s&#125;);</span><br><span class=\"line\">    <span class=\"type\">int</span> u;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pii x=q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[x.second])  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        u=x.second;</span><br><span class=\"line\">        vis[u]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[edge[i].to]&gt;ans[u]+edge[i].weight)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ans[edge[i].to]=ans[u]+edge[i].weight;</span><br><span class=\"line\">                q.<span class=\"built_in\">push</span>(<span class=\"built_in\">pii</span>(ans[edge[i].to],edge[i].to));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)  cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h1 id=\"spfa\"><a class=\"markdownIt-Anchor\" href=\"#spfa\"></a> SPFA</h1>\n<p>SPFA 是 Bellman-Ford 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<h2 id=\"基本信息-3\"><a class=\"markdownIt-Anchor\" href=\"#基本信息-3\"></a> 基本信息</h2>\n<p>定义：SPFA 是 Bellman-Ford（解决存在负权边的单源最短路问题） 的一种 <strong>队列优化</strong>，利用了每个点不会更新次数太多的特点，减少了不必要的多余的计算</p>\n<p>SPFA 在形式上和 BFS 很像，但是 BFS 搜完一个点之后就不会重新放回队列了，SPFA 在取出一个点进行处理修改时，后面可能产生更短的路径，于是就再次用来修改其他的顶点。</p>\n<p>时间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(kE)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span> 是边数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 是常数，平均值是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></p>\n<h2 id=\"算法步骤-3\"><a class=\"markdownIt-Anchor\" href=\"#算法步骤-3\"></a> 算法步骤</h2>\n<ol>\n<li>初始时将出发点加入队列，每次从队列中取出队头，并对所有和队头相连的顶点进行修改</li>\n<li>若某个相邻的顶点修改成功，则将其入队</li>\n<li>队列为空时，算法结束</li>\n</ol>\n<h2 id=\"实现方法\"><a class=\"markdownIt-Anchor\" href=\"#实现方法\"></a> 实现方法</h2>\n<ol>\n<li>建立一个队列，并且将出发点入列，用 <code>dis[i]</code> 记录出发点到其他所有点的最短路径</li>\n<li>执行松弛操作，一次用队列里有的点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi></mrow><annotation encoding=\"application/x-tex\">u</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">u</span></span></span></span> 去更新所有后继节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的最短路，如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 被更新成功且不在队列中，则把 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding=\"application/x-tex\">v_i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 加入队列，重复执行直到队列为空</li>\n<li>节点可能多次被更新，可以多次进入队列<br />\n<code>if(dis[u]+w&lt;dis[v])  d[v]=d[u]+w;</code></li>\n<li>如果 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>V</mi></mrow><annotation encoding=\"application/x-tex\">V</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span></span></span></span> 被更新了且队列中不存在，再一次进入队列</li>\n</ol>\n<h2 id=\"例题-luogu-p3371\"><a class=\"markdownIt-Anchor\" href=\"#例题-luogu-p3371\"></a> 例题 - <a href=\"https://luogu.com.cn/problem/P3371\">Luogu P3371</a></h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> LEN=<span class=\"number\">5e5</span><span class=\"number\">+5</span>,INF=<span class=\"built_in\">pow</span>(<span class=\"number\">2</span>,<span class=\"number\">31</span>)<span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edge[<span class=\"number\">2</span>*LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> cnt=<span class=\"number\">0</span>,head[LEN],dis[LEN];</span><br><span class=\"line\"><span class=\"type\">bool</span> vis[LEN];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,start;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addedge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cnt++;</span><br><span class=\"line\">    edge[cnt].to=v;</span><br><span class=\"line\">    edge[cnt].weight=w;</span><br><span class=\"line\">    edge[cnt].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SPFA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">    dis[start]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">    vis[start]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> now=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        vis[now]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> to=edge[i].to;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edge[i].weight+dis[now]&lt;=dis[to])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dis[to]=edge[i].weight+dis[now];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!vis[to])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(to);</span><br><span class=\"line\">                    vis[to]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  dis[i]=INF;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(head));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;start;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">addedge</span>(u,v,w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SPFA</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  cout&lt;&lt;dis[i]&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有些考试会用数据卡掉 SPFA 导致 TLE，比如 <a href=\"https://luogu.com.cn/problem/P4779\">Luogu P4779</a> 会导致 SPFA 算法在 <a href=\"https://luogu.com.cn/record/222522444\">#1,2,3,5,6 TLE</a><br />\nSPFA 在最坏情况下和朴素 Bellman-Ford 几乎没有区别</p>\n<hr />\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<p>Floyd 最简单，多源最短路大暴力，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> 复杂度卡死你<br />\nDijkstra 时间短，边权非负要确保，不如写上堆优化，时间降到 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\ log(n))</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mclose\">)</span></span></span></span><br />\nSPFA 易理解，和 BFS 很类似，<a href=\"https://luogu.com.cn/problem/P4768\">某些题目</a> 会卡掉，慎重选择需技巧</p>\n<p>被迫回去看链式前向星的笔记了 :(</p>"},{"title":"图的存储 - 链式前向星","date":"2025-07-15T08:23:05.000Z","poster":{"headline":"图的存储 - 链式前向星","topic":"应用场景非常广泛，很多算法都可用到！"},"katex":true,"author":"ED_Builder","_content":"\n其实本质上就是用链表实现的邻接表\n\n<!-- more -->\n\n## 基本信息\n链式前向星是图论中一种 ~~牛逼~~ 高效的存储结构\n\n时间复杂度：  \n- 添加边：$O(1)$  \n  和邻接矩阵的复杂度一样，但是我们要在 `head` 数组的末尾添加新边，并更新头指针\n- 遍历节点的出边：$O(k)$  \n  其中：$k$ 为这个节点的出边数量。直接通过头指针开始遍历链表即可\n- 断边：最坏情况 $O(m)$  \n  需要遍历 `edges` 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星\n- 删除节点：$O(n)$  \n  需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）\n\n空间复杂度：$O(n+m)$，其中：$n$ 为节点数，$m$ 为边数\n## 添加与遍历\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int NODE_LEN=1e5+5;\nconst int EDGE_LEN=2e5+5;\n//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边\n\n//定义边，存储指向的目标节点和下一条边的索引，以及边权\nstruct Edge\n{\n    int to,nxt,weight;\n}edges[EDGE_LEN];//图中的所有边\n\nint head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标\nint cnt_edge=0;//边的数量\n\nvoid add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w\n{\n    edges[cnt_edge].to=v;\n    //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v\n\n    edges[cnt_edge].nxt=head[u];\n    head[u]=cnt_edge;\n    //下一条边\n    edges[cnt_edge].weight=w;//由出发节点伸出的边的权值\n    cnt_edge++;//存完一个啦！提前准备好下一个！\n    cout<<\"添加边：( \"<<u<<\" -> \"<<v<<\" ) 成功！且权值为 \"<<w<<endl;\n    return;\n}\n\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //由于下面就是示例了，所以就用局部变量了\n    int n;//共计 n 个节点\n    cin>>n;\n    for(int i=1;i<=n;i++)//读入节点\n    {\n        int u,v,w;//出发节点和目标节点\n        cin>>u>>v>>w;\n        add_edge(u,v,w);\n        //add_edge(v,u,w);\n        //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！\n    }\n    for(int i=1;i<=n;i++)  traverse_nodes(i);//遍历节点 i\n    exit(0);\n}\n```\n提示：学到这里已经足够应对大部分算法了，链式前向星 **非常不适合删除操作**\n\n---\n## 断边\n下面介绍如何在链式前向星数据结构上增加删除边的功能。\n\n需要注意的是，链式前向星本质上是一种一边 **只增不减** 的“静态”存储方式  \n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。  \n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。\n\n{% note color:red\n注意： \n1. 如果你的图中 **经常需要删除边** ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。\n%}\n\n### 1. 增加删除边所需要的代码\n假设我们在前面的加权图结构基础上（包括 `to`、`weight` 和 `nxt` 字段）进行扩展。我们给出一个 `delete_edge` 函数，函数参数为起点 `u` 和目标 `v` ，表示删除一条从 `u` 到 `v` 的边（如果存在多条，则只删除第一个碰到的）。\n\n我们来逐步说明删除边的思路，再给出代码：\n1. **找到目标边所在的链表位置**  \n   对于某个起点 `u` ，其边链表保存在从 `head[u]` 开始的一条单链表中。我们用两个变量：  \n   - `cur` 用于遍历链表，初始设为 `head[u]` 。  \n   - `pre` 记录前驱节点的索引，初始为 `-1`（表示当前边是链表的第一个）。\n2. **遍历链表，搜索符合条件的边**  \n   从 `cur` 开始，遍历链表：如果发现 `edges[cur].to==v`（满足目标条件），则说明找到了要删除的边。\n3. **更新指针实现删除**  \n   - 如果 `pre` 为 `-1`，说明要删除的边正好位于链表头部，此时更新 `head[u]=edges[cur].nxt`；  \n   - 否则，将前驱边的 `nxt` 指针更新为 `edges[cur].nxt`，这样跳过了当前边。\n4. **结束遍历**  \n   找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。\n\n下面是完整的删除边函数代码：\n```cpp\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n```\n\n### 2. 遍历节点，验证删除功能\n为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。  \n（其实这已经在 添加与遍历 演示了）\n```cpp\n// 遍历并输出结点 u 的所有出边（包括边的终点和权值）\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n```\n### 3. 示例\n下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：\n```cpp\n/*\n省略，真的太长了...\n可以翻到上面看看 添加与遍历\n*/\n\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //这是张 **无向图** \n    add_edge(1,2,5);add_edge(2,1,5);\n    add_edge(1,3,10);add_edge(3,1,10);\n    add_edge(1,4,3);add_edge(4,1,3);\n    add_edge(2,3,7);add_edge(3,2,7);\n    cout<<\"建边后的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    delete_edge(1,3);\n    cout<<\"现在的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    exit(0);\n}\n```\n示例中的初始图长这样：  \n![graph](https://imghub.ed-builder.top/file/1746946383810_graph.png)\n#### 程序执行过程说明\n1. **添加边阶段：**  \n   - 对于结点 1，经过多次调用 `add_edge(1, ...)`，其边链表可能为（头插法的结果是最新添加的边在链表头）：  \n     - 头部指向边：1 -> 4  \n     - 通过 `nxt` 链到边：1 -> 3  \n     - 再通过 `nxt` 链到边：1 -> 2  \n   - 结点 2 拥有边：2 -> 3。\n\n2. **删除操作：**  \n   - 调用 `delete_edge(1,3)` 后，会遍历结点 1 的边链。  \n   - 当遍历到边记录 `edges[i].to==3` 时，将其从链表中“删除”：  \n     - 如果该边不是头部，就把前一个边的 `nxt` 指向当前边的 `nxt`。  \n   - 此后，遍历结点 1 时，1 -> 3 就不会再被输出。\n\n3. **遍历验证：**  \n   - 调用 `traverse_node` 验证删除后，结点 1 的链表中只剩下 1 -> 4 和 1 -> 2。\n### 4. ASCII 图示辅助理解删除操作\n\n假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 1]\n           [index 1: (1 -> 3), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除 1->3 的过程：\n\n- 遍历时，`cur` 先指向 index 2 (边 1->4)，不匹配；  \n- 然后 `cur` 指向 index 1 (边 1->3)，匹配目标。此时 `pre` 指向 index 2。  \n- 更新 `edges[pre].nxt`，即 `edges[2].nxt = edges[1].nxt`（即 index 0）。  \n- 结果链表变为：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除后的遍历顺序即输出 1->4 和 1->2。\n\n---\n### 5. 小结\n- **删除边的思路：**  \n  - 在链表中找到目标边的位置。  \n  - 通过修改上一节点的 `nxt` 指针或更新 `head[u]`，跳过目标边，令其不参与后续遍历。\n\n- **局限性：**  \n  - 这种删除操作只更新了指针，并没有真正回收数组中的空间。  \n  - 如果后续还需要添加边，可以继续使用 `add_edge`，但是删除的空间不会被重用（除非重新构造数据结构）。\n\n- **扩展思考：**  \n  - 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。\n\n通过以上代码和说明，你可以在链式前向星上实现边的删除功能。\n\n---\n## 删除节点\n下面讨论如何在链式前向星中实现“删除节点”的功能。  \n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：\n1. **删除该节点的所有出边（从该节点出发的边），** 这部分比较简单；\n2. **删除其他节点中所有指向该节点的入边，** 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。\n\n因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：\n\n---\n### 方法 1：物理删除（实际修改链表结构）\n\n在物理删除时，我们需要同时删除：\n- 节点 **u** 的出边（即把 `head[u]` 置为 -1 或清空整个链表），\n- 其他所有节点链表中指向 **u** 的边。\n\n这种方法的基本思路如下：\n1. **删除 u 的出边**  \n   直接将 `head[u]` 设为 -1，相当于断开了 u 对外的所有边。\n\n2. **删除所有指向 u 的入边**  \n   遍历图中所有其他节点 v 的边链表，在每个链表中查找边：  \n   ```cpp\n   if (edges[cur].to == u)\n   ```\n   找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 `nxt` 指针或更新 `head[v]`）。\n\n由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：  \n```cpp\n// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边\nvoid delete_node(int u,int n)//n 表示图中总的节点数\n{ \n    // 1. 删除 u 的所有出边：直接断开该链表\n    head[u]=-1;\n    \n    // 2. 删除其他节点中指向 u 的入边\n    for(int v=1;v<=n;v++)\n    {\n        if(v==u)  continue;//已经处理了 u 的出边\n        int cur=head[v];\n        int pre=-1;\n        while(cur!=-1)\n        {\n            if(edges[cur].to==u)//找到边 v->u，需要删除\n            {\n                if(pre==-1)\n                {\n                    //被删除的边在链表头，更新 head[v]\n                    head[v]=edges[cur].nxt;\n                    //更新 cur 为新的头节点\n                    cur=head[v];\n                }\n                else\n                {\n                    // 跳过当前边\n                    edges[pre].nxt=edges[cur].nxt;\n                    cur=edges[cur].nxt;\n                }\n                // 注意：如果存在多条边指向 u，此处可以继续遍历删除\n            }\n            else\n            {\n                pre=cur;\n                cur=edges[cur].nxt;\n            }\n        }\n    }\n    cout<<\"节点 \"<<u<<\" 删除完成 (出边和入边均已移除）。\"<<endl;\n    return;\n}\n```\n\n#### 注意事项\n- 这种物理删除不会真正回收 `edges[]` 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。\n- 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。\n\n---\n### 方法 2：懒删除（逻辑删除）\n\n在很多实际场景下，动态删除节点（或边）时，我们可以采用 **懒删除** 的策略，而不是立即修改链表结构。方法是：\n1. 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 `nodeExist[N]`。\n2. 当需要删除节点 **u** 时，只需将 `nodeExist[u]` 标记为 `false`\n3. 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。\n\n这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。\n\n示例代码（仅思路）：\n\n```cpp\nbool nodeExist[N];\n\n// 初始化时，将所有节点设为存在\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)  nodeExist[i]=true;\n    return;\n}\n\n// 懒删除节点 u，标记为不存在\nvoid lazy_delete_node(int u)\n{\n    nodeExist[u]=false;\n    cout<<\"节点 \"<<u<<\" 已被标记为删除。\"<<endl;\n    return;\n}\n\n// 在遍历时，检查目标节点是否存在\nvoid process_edges(int u)\n{\n    if(!nodeExist[u])  return;//该节点已经被删除，则不处理\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        int v=edges[i].to;\n        if(!nodeExist[v])  continue;//如果终点已删除，则跳过该边\n        // 此处对边 (u -> v) 做处理\n    }\n    return;\n}\n```\n\n---\n### 小结\n- **物理删除节点：**  \n  - 将该节点的所有出边置为空（如 `head[u]=-1`），  \n  - 遍历其他所有节点的边链表，删除所有指向该节点的入边。  \n  - 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。\n\n- **懒删除（逻辑删除）：**  \n  - 通过维护一个节点存在标志，在删除节点时仅做标记。  \n  - 在遍历和处理时跳过被删除的节点及其相关边。  \n  - 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。\n\n根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","source":"_posts/链式前向星.md","raw":"---\ntitle: 图的存储 - 链式前向星\ndate: 2025-07-15 16:23:05\ntags: ['图论', '存储', '算法']\ncategories: ['学习', '分享']\nposter:\n    headline: 图的存储 - 链式前向星\n    topic: 应用场景非常广泛，很多算法都可用到！\nkatex: true\nauthor: ED_Builder\n---\n\n其实本质上就是用链表实现的邻接表\n\n<!-- more -->\n\n## 基本信息\n链式前向星是图论中一种 ~~牛逼~~ 高效的存储结构\n\n时间复杂度：  \n- 添加边：$O(1)$  \n  和邻接矩阵的复杂度一样，但是我们要在 `head` 数组的末尾添加新边，并更新头指针\n- 遍历节点的出边：$O(k)$  \n  其中：$k$ 为这个节点的出边数量。直接通过头指针开始遍历链表即可\n- 断边：最坏情况 $O(m)$  \n  需要遍历 `edges` 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星\n- 删除节点：$O(n)$  \n  需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）\n\n空间复杂度：$O(n+m)$，其中：$n$ 为节点数，$m$ 为边数\n## 添加与遍历\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int NODE_LEN=1e5+5;\nconst int EDGE_LEN=2e5+5;\n//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边\n\n//定义边，存储指向的目标节点和下一条边的索引，以及边权\nstruct Edge\n{\n    int to,nxt,weight;\n}edges[EDGE_LEN];//图中的所有边\n\nint head[NODE_LEN];//对于每一条边，记录第一条边在 edges 数组中的下标\nint cnt_edge=0;//边的数量\n\nvoid add_edge(int u,int v,int w)//添加一条边，由出发节点 u 到目标节点 v ，边权为 w\n{\n    edges[cnt_edge].to=v;\n    //当前计数边（也就是目前输入的第几个边）将会指向目标节点 v\n\n    edges[cnt_edge].nxt=head[u];\n    head[u]=cnt_edge;\n    //下一条边\n    edges[cnt_edge].weight=w;//由出发节点伸出的边的权值\n    cnt_edge++;//存完一个啦！提前准备好下一个！\n    cout<<\"添加边：( \"<<u<<\" -> \"<<v<<\" ) 成功！且权值为 \"<<w<<endl;\n    return;\n}\n\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //由于下面就是示例了，所以就用局部变量了\n    int n;//共计 n 个节点\n    cin>>n;\n    for(int i=1;i<=n;i++)//读入节点\n    {\n        int u,v,w;//出发节点和目标节点\n        cin>>u>>v>>w;\n        add_edge(u,v,w);\n        //add_edge(v,u,w);\n        //请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！\n    }\n    for(int i=1;i<=n;i++)  traverse_nodes(i);//遍历节点 i\n    exit(0);\n}\n```\n提示：学到这里已经足够应对大部分算法了，链式前向星 **非常不适合删除操作**\n\n---\n## 断边\n下面介绍如何在链式前向星数据结构上增加删除边的功能。\n\n需要注意的是，链式前向星本质上是一种一边 **只增不减** 的“静态”存储方式  \n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。  \n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。\n\n{% note color:red\n注意： \n1. 如果你的图中 **经常需要删除边** ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。\n%}\n\n### 1. 增加删除边所需要的代码\n假设我们在前面的加权图结构基础上（包括 `to`、`weight` 和 `nxt` 字段）进行扩展。我们给出一个 `delete_edge` 函数，函数参数为起点 `u` 和目标 `v` ，表示删除一条从 `u` 到 `v` 的边（如果存在多条，则只删除第一个碰到的）。\n\n我们来逐步说明删除边的思路，再给出代码：\n1. **找到目标边所在的链表位置**  \n   对于某个起点 `u` ，其边链表保存在从 `head[u]` 开始的一条单链表中。我们用两个变量：  \n   - `cur` 用于遍历链表，初始设为 `head[u]` 。  \n   - `pre` 记录前驱节点的索引，初始为 `-1`（表示当前边是链表的第一个）。\n2. **遍历链表，搜索符合条件的边**  \n   从 `cur` 开始，遍历链表：如果发现 `edges[cur].to==v`（满足目标条件），则说明找到了要删除的边。\n3. **更新指针实现删除**  \n   - 如果 `pre` 为 `-1`，说明要删除的边正好位于链表头部，此时更新 `head[u]=edges[cur].nxt`；  \n   - 否则，将前驱边的 `nxt` 指针更新为 `edges[cur].nxt`，这样跳过了当前边。\n4. **结束遍历**  \n   找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。\n\n下面是完整的删除边函数代码：\n```cpp\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n```\n\n### 2. 遍历节点，验证删除功能\n为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。  \n（其实这已经在 添加与遍历 演示了）\n```cpp\n// 遍历并输出结点 u 的所有出边（包括边的终点和权值）\nvoid traverse_nodes(int u)//遍历出发节点 u 的所有目标节点\n{\n    cout<<\"节点 \"<<u<<\" 的所有出边信息：\"<<endl;\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        cout<<\"( \"<<u<<\" -> \"<<edges[i].to<<\" )，权值为 \"<<edges[i].weight<<endl;\n    }\n    /*\n    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引\n    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！\n    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居\n    循环终止操作：找下一条边\n    */\n    return;\n}\n```\n### 3. 示例\n下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：\n```cpp\n/*\n省略，真的太长了...\n可以翻到上面看看 添加与遍历\n*/\n\n// 删除从 u 指向 v 的边（仅删除第一次匹配的边）\nvoid delete_edge(int u,int v)\n{\n    int cur=head[u];\n    int pre=-1;\n    while(cur!=-1)\n    {\n        if(edges[cur].to==v)//找到目标边\n        {\n            if (pre==-1)  head[u]=edges[cur].nxt;//目标边位于链表头部，更新 head[u]\n            else  edges[pre].nxt=edges[cur].nxt;//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur\n            //删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）\n            edges[cur].nxt=-1;\n            cout<<\"删除边 (\"<<u<<\" -> \"<<v<<\") 成功。\"<<endl;\n            return;\n        }\n        pre=cur;\n        cur=edges[cur].nxt;\n    }\n    cout<<\"边 (\"<<u<<\" -> \"<<v<<\") 不存在，删除失败。\"<<endl;\n    return;\n}\n\nsigned main()\n{\n    memset(head,-1,sizeof(head));//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接\n    \n    //这是张 **无向图** \n    add_edge(1,2,5);add_edge(2,1,5);\n    add_edge(1,3,10);add_edge(3,1,10);\n    add_edge(1,4,3);add_edge(4,1,3);\n    add_edge(2,3,7);add_edge(3,2,7);\n    cout<<\"建边后的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    delete_edge(1,3);\n    cout<<\"现在的图\"<<endl;\n    for(int i=1;i<=4;i++)  traverse_nodes(i);\n    exit(0);\n}\n```\n示例中的初始图长这样：  \n![graph](https://imghub.ed-builder.top/file/1746946383810_graph.png)\n#### 程序执行过程说明\n1. **添加边阶段：**  \n   - 对于结点 1，经过多次调用 `add_edge(1, ...)`，其边链表可能为（头插法的结果是最新添加的边在链表头）：  \n     - 头部指向边：1 -> 4  \n     - 通过 `nxt` 链到边：1 -> 3  \n     - 再通过 `nxt` 链到边：1 -> 2  \n   - 结点 2 拥有边：2 -> 3。\n\n2. **删除操作：**  \n   - 调用 `delete_edge(1,3)` 后，会遍历结点 1 的边链。  \n   - 当遍历到边记录 `edges[i].to==3` 时，将其从链表中“删除”：  \n     - 如果该边不是头部，就把前一个边的 `nxt` 指向当前边的 `nxt`。  \n   - 此后，遍历结点 1 时，1 -> 3 就不会再被输出。\n\n3. **遍历验证：**  \n   - 调用 `traverse_node` 验证删除后，结点 1 的链表中只剩下 1 -> 4 和 1 -> 2。\n### 4. ASCII 图示辅助理解删除操作\n\n假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 1]\n           [index 1: (1 -> 3), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除 1->3 的过程：\n\n- 遍历时，`cur` 先指向 index 2 (边 1->4)，不匹配；  \n- 然后 `cur` 指向 index 1 (边 1->3)，匹配目标。此时 `pre` 指向 index 2。  \n- 更新 `edges[pre].nxt`，即 `edges[2].nxt = edges[1].nxt`（即 index 0）。  \n- 结果链表变为：\n\n```\nhead[1] --> [index 2: (1 -> 4), nxt = index 0]\n           [index 0: (1 -> 2), nxt = -1]\n```\n\n删除后的遍历顺序即输出 1->4 和 1->2。\n\n---\n### 5. 小结\n- **删除边的思路：**  \n  - 在链表中找到目标边的位置。  \n  - 通过修改上一节点的 `nxt` 指针或更新 `head[u]`，跳过目标边，令其不参与后续遍历。\n\n- **局限性：**  \n  - 这种删除操作只更新了指针，并没有真正回收数组中的空间。  \n  - 如果后续还需要添加边，可以继续使用 `add_edge`，但是删除的空间不会被重用（除非重新构造数据结构）。\n\n- **扩展思考：**  \n  - 如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。\n\n通过以上代码和说明，你可以在链式前向星上实现边的删除功能。\n\n---\n## 删除节点\n下面讨论如何在链式前向星中实现“删除节点”的功能。  \n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：\n1. **删除该节点的所有出边（从该节点出发的边），** 这部分比较简单；\n2. **删除其他节点中所有指向该节点的入边，** 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。\n\n因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：\n\n---\n### 方法 1：物理删除（实际修改链表结构）\n\n在物理删除时，我们需要同时删除：\n- 节点 **u** 的出边（即把 `head[u]` 置为 -1 或清空整个链表），\n- 其他所有节点链表中指向 **u** 的边。\n\n这种方法的基本思路如下：\n1. **删除 u 的出边**  \n   直接将 `head[u]` 设为 -1，相当于断开了 u 对外的所有边。\n\n2. **删除所有指向 u 的入边**  \n   遍历图中所有其他节点 v 的边链表，在每个链表中查找边：  \n   ```cpp\n   if (edges[cur].to == u)\n   ```\n   找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 `nxt` 指针或更新 `head[v]`）。\n\n由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：  \n```cpp\n// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边\nvoid delete_node(int u,int n)//n 表示图中总的节点数\n{ \n    // 1. 删除 u 的所有出边：直接断开该链表\n    head[u]=-1;\n    \n    // 2. 删除其他节点中指向 u 的入边\n    for(int v=1;v<=n;v++)\n    {\n        if(v==u)  continue;//已经处理了 u 的出边\n        int cur=head[v];\n        int pre=-1;\n        while(cur!=-1)\n        {\n            if(edges[cur].to==u)//找到边 v->u，需要删除\n            {\n                if(pre==-1)\n                {\n                    //被删除的边在链表头，更新 head[v]\n                    head[v]=edges[cur].nxt;\n                    //更新 cur 为新的头节点\n                    cur=head[v];\n                }\n                else\n                {\n                    // 跳过当前边\n                    edges[pre].nxt=edges[cur].nxt;\n                    cur=edges[cur].nxt;\n                }\n                // 注意：如果存在多条边指向 u，此处可以继续遍历删除\n            }\n            else\n            {\n                pre=cur;\n                cur=edges[cur].nxt;\n            }\n        }\n    }\n    cout<<\"节点 \"<<u<<\" 删除完成 (出边和入边均已移除）。\"<<endl;\n    return;\n}\n```\n\n#### 注意事项\n- 这种物理删除不会真正回收 `edges[]` 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。\n- 删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。\n\n---\n### 方法 2：懒删除（逻辑删除）\n\n在很多实际场景下，动态删除节点（或边）时，我们可以采用 **懒删除** 的策略，而不是立即修改链表结构。方法是：\n1. 为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 `nodeExist[N]`。\n2. 当需要删除节点 **u** 时，只需将 `nodeExist[u]` 标记为 `false`\n3. 在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。\n\n这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。\n\n示例代码（仅思路）：\n\n```cpp\nbool nodeExist[N];\n\n// 初始化时，将所有节点设为存在\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)  nodeExist[i]=true;\n    return;\n}\n\n// 懒删除节点 u，标记为不存在\nvoid lazy_delete_node(int u)\n{\n    nodeExist[u]=false;\n    cout<<\"节点 \"<<u<<\" 已被标记为删除。\"<<endl;\n    return;\n}\n\n// 在遍历时，检查目标节点是否存在\nvoid process_edges(int u)\n{\n    if(!nodeExist[u])  return;//该节点已经被删除，则不处理\n    for(int i=head[u];i!=-1;i=edges[i].nxt)\n    {\n        int v=edges[i].to;\n        if(!nodeExist[v])  continue;//如果终点已删除，则跳过该边\n        // 此处对边 (u -> v) 做处理\n    }\n    return;\n}\n```\n\n---\n### 小结\n- **物理删除节点：**  \n  - 将该节点的所有出边置为空（如 `head[u]=-1`），  \n  - 遍历其他所有节点的边链表，删除所有指向该节点的入边。  \n  - 需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。\n\n- **懒删除（逻辑删除）：**  \n  - 通过维护一个节点存在标志，在删除节点时仅做标记。  \n  - 在遍历和处理时跳过被删除的节点及其相关边。  \n  - 简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。\n\n根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。","slug":"链式前向星","published":1,"updated":"2025-07-29T11:44:20.063Z","comments":1,"layout":"post","photos":[],"_id":"cmdohm0nv0009zgbobtuk80qh","content":"<p>其实本质上就是用链表实现的邻接表</p>\n<span id=\"more\"></span>\n<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>链式前向星是图论中一种 <s>牛逼</s> 高效的存储结构</p>\n<p>时间复杂度：</p>\n<ul>\n<li>添加边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n和邻接矩阵的复杂度一样，但是我们要在 <code>head</code> 数组的末尾添加新边，并更新头指针</li>\n<li>遍历节点的出边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span><br />\n其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为这个节点的出边数量。直接通过头指针开始遍历链表即可</li>\n<li>断边：最坏情况 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历 <code>edges</code> 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星</li>\n<li>删除节点：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）</li>\n</ul>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为节点数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为边数</p>\n<h2 id=\"添加与遍历\"><a class=\"markdownIt-Anchor\" href=\"#添加与遍历\"></a> 添加与遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> NODE_LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> EDGE_LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"comment\">//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义边，存储指向的目标节点和下一条边的索引，以及边权</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edges[EDGE_LEN];<span class=\"comment\">//图中的所有边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> head[NODE_LEN];<span class=\"comment\">//对于每一条边，记录第一条边在 edges 数组中的下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> cnt_edge=<span class=\"number\">0</span>;<span class=\"comment\">//边的数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span><span class=\"comment\">//添加一条边，由出发节点 u 到目标节点 v ，边权为 w</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edges[cnt_edge].to=v;</span><br><span class=\"line\">    <span class=\"comment\">//当前计数边（也就是目前输入的第几个边）将会指向目标节点 v</span></span><br><span class=\"line\"></span><br><span class=\"line\">    edges[cnt_edge].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt_edge;</span><br><span class=\"line\">    <span class=\"comment\">//下一条边</span></span><br><span class=\"line\">    edges[cnt_edge].weight=w;<span class=\"comment\">//由出发节点伸出的边的权值</span></span><br><span class=\"line\">    cnt_edge++;<span class=\"comment\">//存完一个啦！提前准备好下一个！</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;添加边：( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot; ) 成功！且权值为 &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//由于下面就是示例了，所以就用局部变量了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;<span class=\"comment\">//共计 n 个节点</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//读入节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;<span class=\"comment\">//出发节点和目标节点</span></span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">add_edge</span>(u,v,w);</span><br><span class=\"line\">        <span class=\"comment\">//add_edge(v,u,w);</span></span><br><span class=\"line\">        <span class=\"comment\">//请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">traverse_nodes</span>(i);<span class=\"comment\">//遍历节点 i</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：学到这里已经足够应对大部分算法了，链式前向星 <strong>非常不适合删除操作</strong></p>\n<hr />\n<h2 id=\"断边\"><a class=\"markdownIt-Anchor\" href=\"#断边\"></a> 断边</h2>\n<p>下面介绍如何在链式前向星数据结构上增加删除边的功能。</p>\n<p>需要注意的是，链式前向星本质上是一种一边 <strong>只增不减</strong> 的“静态”存储方式<br />\n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。<br />\n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。</p>\n<div class=\"tag-plugin colorful note\" color=\"red\"><div class=\"title\">注意：</div><div class=\"body\"><ol><li>如果你的图中 <strong>经常需要删除边</strong> ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。</li></ol></div></div>\n<h3 id=\"1-增加删除边所需要的代码\"><a class=\"markdownIt-Anchor\" href=\"#1-增加删除边所需要的代码\"></a> 1. 增加删除边所需要的代码</h3>\n<p>假设我们在前面的加权图结构基础上（包括 <code>to</code>、<code>weight</code> 和 <code>nxt</code> 字段）进行扩展。我们给出一个 <code>delete_edge</code> 函数，函数参数为起点 <code>u</code> 和目标 <code>v</code> ，表示删除一条从 <code>u</code> 到 <code>v</code> 的边（如果存在多条，则只删除第一个碰到的）。</p>\n<p>我们来逐步说明删除边的思路，再给出代码：</p>\n<ol>\n<li><strong>找到目标边所在的链表位置</strong><br />\n对于某个起点 <code>u</code> ，其边链表保存在从 <code>head[u]</code> 开始的一条单链表中。我们用两个变量：\n<ul>\n<li><code>cur</code> 用于遍历链表，初始设为 <code>head[u]</code> 。</li>\n<li><code>pre</code> 记录前驱节点的索引，初始为 <code>-1</code>（表示当前边是链表的第一个）。</li>\n</ul>\n</li>\n<li><strong>遍历链表，搜索符合条件的边</strong><br />\n从 <code>cur</code> 开始，遍历链表：如果发现 <code>edges[cur].to==v</code>（满足目标条件），则说明找到了要删除的边。</li>\n<li><strong>更新指针实现删除</strong>\n<ul>\n<li>如果 <code>pre</code> 为 <code>-1</code>，说明要删除的边正好位于链表头部，此时更新 <code>head[u]=edges[cur].nxt</code>；</li>\n<li>否则，将前驱边的 <code>nxt</code> 指针更新为 <code>edges[cur].nxt</code>，这样跳过了当前边。</li>\n</ul>\n</li>\n<li><strong>结束遍历</strong><br />\n找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。</li>\n</ol>\n<p>下面是完整的删除边函数代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历节点验证删除功能\"><a class=\"markdownIt-Anchor\" href=\"#2-遍历节点验证删除功能\"></a> 2. 遍历节点，验证删除功能</h3>\n<p>为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。<br />\n（其实这已经在 添加与遍历 演示了）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历并输出结点 u 的所有出边（包括边的终点和权值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-示例\"><a class=\"markdownIt-Anchor\" href=\"#3-示例\"></a> 3. 示例</h3>\n<p>下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">省略，真的太长了...</span></span><br><span class=\"line\"><span class=\"comment\">可以翻到上面看看 添加与遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这是张 **无向图** </span></span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;建边后的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">delete_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;现在的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中的初始图长这样：<br />\n<img src=\"https://imghub.ed-builder.top/file/1746946383810_graph.png\" alt=\"graph\" /></p>\n<h4 id=\"程序执行过程说明\"><a class=\"markdownIt-Anchor\" href=\"#程序执行过程说明\"></a> 程序执行过程说明</h4>\n<ol>\n<li>\n<p><strong>添加边阶段：</strong></p>\n<ul>\n<li>对于结点 1，经过多次调用 <code>add_edge(1, ...)</code>，其边链表可能为（头插法的结果是最新添加的边在链表头）：\n<ul>\n<li>头部指向边：1 -&gt; 4</li>\n<li>通过 <code>nxt</code> 链到边：1 -&gt; 3</li>\n<li>再通过 <code>nxt</code> 链到边：1 -&gt; 2</li>\n</ul>\n</li>\n<li>结点 2 拥有边：2 -&gt; 3。</li>\n</ul>\n</li>\n<li>\n<p><strong>删除操作：</strong></p>\n<ul>\n<li>调用 <code>delete_edge(1,3)</code> 后，会遍历结点 1 的边链。</li>\n<li>当遍历到边记录 <code>edges[i].to==3</code> 时，将其从链表中“删除”：\n<ul>\n<li>如果该边不是头部，就把前一个边的 <code>nxt</code> 指向当前边的 <code>nxt</code>。</li>\n</ul>\n</li>\n<li>此后，遍历结点 1 时，1 -&gt; 3 就不会再被输出。</li>\n</ul>\n</li>\n<li>\n<p><strong>遍历验证：</strong></p>\n<ul>\n<li>调用 <code>traverse_node</code> 验证删除后，结点 1 的链表中只剩下 1 -&gt; 4 和 1 -&gt; 2。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-ascii-图示辅助理解删除操作\"><a class=\"markdownIt-Anchor\" href=\"#4-ascii-图示辅助理解删除操作\"></a> 4. ASCII 图示辅助理解删除操作</h3>\n<p>假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">1</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 1: (1 -&gt;</span> <span class=\"number\">3</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除 1-&gt;3 的过程：</p>\n<ul>\n<li>遍历时，<code>cur</code> 先指向 index 2 (边 1-&gt;4)，不匹配；</li>\n<li>然后 <code>cur</code> 指向 index 1 (边 1-&gt;3)，匹配目标。此时 <code>pre</code> 指向 index 2。</li>\n<li>更新 <code>edges[pre].nxt</code>，即 <code>edges[2].nxt = edges[1].nxt</code>（即 index 0）。</li>\n<li>结果链表变为：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除后的遍历顺序即输出 1-&gt;4 和 1-&gt;2。</p>\n<hr />\n<h3 id=\"5-小结\"><a class=\"markdownIt-Anchor\" href=\"#5-小结\"></a> 5. 小结</h3>\n<ul>\n<li>\n<p><strong>删除边的思路：</strong></p>\n<ul>\n<li>在链表中找到目标边的位置。</li>\n<li>通过修改上一节点的 <code>nxt</code> 指针或更新 <code>head[u]</code>，跳过目标边，令其不参与后续遍历。</li>\n</ul>\n</li>\n<li>\n<p><strong>局限性：</strong></p>\n<ul>\n<li>这种删除操作只更新了指针，并没有真正回收数组中的空间。</li>\n<li>如果后续还需要添加边，可以继续使用 <code>add_edge</code>，但是删除的空间不会被重用（除非重新构造数据结构）。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩展思考：</strong></p>\n<ul>\n<li>如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。</li>\n</ul>\n</li>\n</ul>\n<p>通过以上代码和说明，你可以在链式前向星上实现边的删除功能。</p>\n<hr />\n<h2 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\"></a> 删除节点</h2>\n<p>下面讨论如何在链式前向星中实现“删除节点”的功能。<br />\n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：</p>\n<ol>\n<li><strong>删除该节点的所有出边（从该节点出发的边），</strong> 这部分比较简单；</li>\n<li><strong>删除其他节点中所有指向该节点的入边，</strong> 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。</li>\n</ol>\n<p>因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：</p>\n<hr />\n<h3 id=\"方法-1物理删除实际修改链表结构\"><a class=\"markdownIt-Anchor\" href=\"#方法-1物理删除实际修改链表结构\"></a> 方法 1：物理删除（实际修改链表结构）</h3>\n<p>在物理删除时，我们需要同时删除：</p>\n<ul>\n<li>节点 <strong>u</strong> 的出边（即把 <code>head[u]</code> 置为 -1 或清空整个链表），</li>\n<li>其他所有节点链表中指向 <strong>u</strong> 的边。</li>\n</ul>\n<p>这种方法的基本思路如下：</p>\n<ol>\n<li>\n<p><strong>删除 u 的出边</strong><br />\n直接将 <code>head[u]</code> 设为 -1，相当于断开了 u 对外的所有边。</p>\n</li>\n<li>\n<p><strong>删除所有指向 u 的入边</strong><br />\n遍历图中所有其他节点 v 的边链表，在每个链表中查找边：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (edges[cur].to == u)</span><br></pre></td></tr></table></figure>\n<p>找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 <code>nxt</code> 指针或更新 <code>head[v]</code>）。</p>\n</li>\n</ol>\n<p>由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> n)</span><span class=\"comment\">//n 表示图中总的节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除 u 的所有出边：直接断开该链表</span></span><br><span class=\"line\">    head[u]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除其他节点中指向 u 的入边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==u)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//已经处理了 u 的出边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> cur=head[v];</span><br><span class=\"line\">        <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edges[cur].to==u)<span class=\"comment\">//找到边 v-&gt;u，需要删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pre==<span class=\"number\">-1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//被删除的边在链表头，更新 head[v]</span></span><br><span class=\"line\">                    head[v]=edges[cur].nxt;</span><br><span class=\"line\">                    <span class=\"comment\">//更新 cur 为新的头节点</span></span><br><span class=\"line\">                    cur=head[v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跳过当前边</span></span><br><span class=\"line\">                    edges[pre].nxt=edges[cur].nxt;</span><br><span class=\"line\">                    cur=edges[cur].nxt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意：如果存在多条边指向 u，此处可以继续遍历删除</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre=cur;</span><br><span class=\"line\">                cur=edges[cur].nxt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 删除完成 (出边和入边均已移除）。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h4>\n<ul>\n<li>这种物理删除不会真正回收 <code>edges[]</code> 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。</li>\n<li>删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。</li>\n</ul>\n<hr />\n<h3 id=\"方法-2懒删除逻辑删除\"><a class=\"markdownIt-Anchor\" href=\"#方法-2懒删除逻辑删除\"></a> 方法 2：懒删除（逻辑删除）</h3>\n<p>在很多实际场景下，动态删除节点（或边）时，我们可以采用 <strong>懒删除</strong> 的策略，而不是立即修改链表结构。方法是：</p>\n<ol>\n<li>为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 <code>nodeExist[N]</code>。</li>\n<li>当需要删除节点 <strong>u</strong> 时，只需将 <code>nodeExist[u]</code> 标记为 <code>false</code></li>\n<li>在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。</li>\n</ol>\n<p>这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。</p>\n<p>示例代码（仅思路）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> nodeExist[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化时，将所有节点设为存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  nodeExist[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒删除节点 u，标记为不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lazy_delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    nodeExist[u]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 已被标记为删除。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在遍历时，检查目标节点是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_edges</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!nodeExist[u])  <span class=\"keyword\">return</span>;<span class=\"comment\">//该节点已经被删除，则不处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v=edges[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!nodeExist[v])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//如果终点已删除，则跳过该边</span></span><br><span class=\"line\">        <span class=\"comment\">// 此处对边 (u -&gt; v) 做处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h3 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h3>\n<ul>\n<li>\n<p><strong>物理删除节点：</strong></p>\n<ul>\n<li>将该节点的所有出边置为空（如 <code>head[u]=-1</code>），</li>\n<li>遍历其他所有节点的边链表，删除所有指向该节点的入边。</li>\n<li>需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。</li>\n</ul>\n</li>\n<li>\n<p><strong>懒删除（逻辑删除）：</strong></p>\n<ul>\n<li>通过维护一个节点存在标志，在删除节点时仅做标记。</li>\n<li>在遍历和处理时跳过被删除的节点及其相关边。</li>\n<li>简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。</li>\n</ul>\n</li>\n</ul>\n<p>根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。</p>\n","excerpt":"<p>其实本质上就是用链表实现的邻接表</p>","more":"<h2 id=\"基本信息\"><a class=\"markdownIt-Anchor\" href=\"#基本信息\"></a> 基本信息</h2>\n<p>链式前向星是图论中一种 <s>牛逼</s> 高效的存储结构</p>\n<p>时间复杂度：</p>\n<ul>\n<li>添加边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span><br />\n和邻接矩阵的复杂度一样，但是我们要在 <code>head</code> 数组的末尾添加新边，并更新头指针</li>\n<li>遍历节点的出边：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span><br />\n其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span> 为这个节点的出边数量。直接通过头指针开始遍历链表即可</li>\n<li>断边：最坏情况 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历 <code>edges</code> 边数组找到目标边，但是通常如果涉及到了删除功能，我们不会用链式前向星</li>\n<li>删除节点：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span><br />\n需要遍历所有的边，删除与该节点相关的边。如果我们真的需要这个功能的话，我们通常使用标记删除（也叫做“懒删除”，就是把这个点标记为被删除，实际上还存在于数据结构里）</li>\n</ul>\n<p>空间复杂度：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n+m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，其中：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为节点数，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 为边数</p>\n<h2 id=\"添加与遍历\"><a class=\"markdownIt-Anchor\" href=\"#添加与遍历\"></a> 添加与遍历</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> int long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> NODE_LEN=<span class=\"number\">1e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> EDGE_LEN=<span class=\"number\">2e5</span><span class=\"number\">+5</span>;</span><br><span class=\"line\"><span class=\"comment\">//最多有 NODE_LEN 个节点，和最多 EDGE_LEN 条边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义边，存储指向的目标节点和下一条边的索引，以及边权</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> to,nxt,weight;</span><br><span class=\"line\">&#125;edges[EDGE_LEN];<span class=\"comment\">//图中的所有边</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> head[NODE_LEN];<span class=\"comment\">//对于每一条边，记录第一条边在 edges 数组中的下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> cnt_edge=<span class=\"number\">0</span>;<span class=\"comment\">//边的数量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v,<span class=\"type\">int</span> w)</span><span class=\"comment\">//添加一条边，由出发节点 u 到目标节点 v ，边权为 w</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    edges[cnt_edge].to=v;</span><br><span class=\"line\">    <span class=\"comment\">//当前计数边（也就是目前输入的第几个边）将会指向目标节点 v</span></span><br><span class=\"line\"></span><br><span class=\"line\">    edges[cnt_edge].nxt=head[u];</span><br><span class=\"line\">    head[u]=cnt_edge;</span><br><span class=\"line\">    <span class=\"comment\">//下一条边</span></span><br><span class=\"line\">    edges[cnt_edge].weight=w;<span class=\"comment\">//由出发节点伸出的边的权值</span></span><br><span class=\"line\">    cnt_edge++;<span class=\"comment\">//存完一个啦！提前准备好下一个！</span></span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;添加边：( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot; ) 成功！且权值为 &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//由于下面就是示例了，所以就用局部变量了</span></span><br><span class=\"line\">    <span class=\"type\">int</span> n;<span class=\"comment\">//共计 n 个节点</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)<span class=\"comment\">//读入节点</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> u,v,w;<span class=\"comment\">//出发节点和目标节点</span></span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class=\"line\">        <span class=\"built_in\">add_edge</span>(u,v,w);</span><br><span class=\"line\">        <span class=\"comment\">//add_edge(v,u,w);</span></span><br><span class=\"line\">        <span class=\"comment\">//请注意：如果这张图是一张 **无向图** ，你还要把从目标节点到出发节点的边也建立起来！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  <span class=\"built_in\">traverse_nodes</span>(i);<span class=\"comment\">//遍历节点 i</span></span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>提示：学到这里已经足够应对大部分算法了，链式前向星 <strong>非常不适合删除操作</strong></p>\n<hr />\n<h2 id=\"断边\"><a class=\"markdownIt-Anchor\" href=\"#断边\"></a> 断边</h2>\n<p>下面介绍如何在链式前向星数据结构上增加删除边的功能。</p>\n<p>需要注意的是，链式前向星本质上是一种一边 <strong>只增不减</strong> 的“静态”存储方式<br />\n删除边的操作我们只能通过修改指针来“跳过”被删除的边，而不是真正将数组中的元素清除或移位。<br />\n下面提供一种物理删除的方法，即在遍历该结点的链表时找到要删除的边，然后更新前后边的指针，使该边不再被遍历到。</p>\n<div class=\"tag-plugin colorful note\" color=\"red\"><div class=\"title\">注意：</div><div class=\"body\"><ol><li>如果你的图中 <strong>经常需要删除边</strong> ，链式前向星可能不是最适合的选择；<br>2. 如果你不要求立刻释放边的存储，也可以采用“懒删除”，在每条边中增加一个标志位表示是否有效，在遍历时跳过删除的边。</li></ol></div></div>\n<h3 id=\"1-增加删除边所需要的代码\"><a class=\"markdownIt-Anchor\" href=\"#1-增加删除边所需要的代码\"></a> 1. 增加删除边所需要的代码</h3>\n<p>假设我们在前面的加权图结构基础上（包括 <code>to</code>、<code>weight</code> 和 <code>nxt</code> 字段）进行扩展。我们给出一个 <code>delete_edge</code> 函数，函数参数为起点 <code>u</code> 和目标 <code>v</code> ，表示删除一条从 <code>u</code> 到 <code>v</code> 的边（如果存在多条，则只删除第一个碰到的）。</p>\n<p>我们来逐步说明删除边的思路，再给出代码：</p>\n<ol>\n<li><strong>找到目标边所在的链表位置</strong><br />\n对于某个起点 <code>u</code> ，其边链表保存在从 <code>head[u]</code> 开始的一条单链表中。我们用两个变量：\n<ul>\n<li><code>cur</code> 用于遍历链表，初始设为 <code>head[u]</code> 。</li>\n<li><code>pre</code> 记录前驱节点的索引，初始为 <code>-1</code>（表示当前边是链表的第一个）。</li>\n</ul>\n</li>\n<li><strong>遍历链表，搜索符合条件的边</strong><br />\n从 <code>cur</code> 开始，遍历链表：如果发现 <code>edges[cur].to==v</code>（满足目标条件），则说明找到了要删除的边。</li>\n<li><strong>更新指针实现删除</strong>\n<ul>\n<li>如果 <code>pre</code> 为 <code>-1</code>，说明要删除的边正好位于链表头部，此时更新 <code>head[u]=edges[cur].nxt</code>；</li>\n<li>否则，将前驱边的 <code>nxt</code> 指针更新为 <code>edges[cur].nxt</code>，这样跳过了当前边。</li>\n</ul>\n</li>\n<li><strong>结束遍历</strong><br />\n找到并删除后可以直接退出函数；若遍历完链表还未找到，则说明该边不存在。</li>\n</ol>\n<p>下面是完整的删除边函数代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-遍历节点验证删除功能\"><a class=\"markdownIt-Anchor\" href=\"#2-遍历节点验证删除功能\"></a> 2. 遍历节点，验证删除功能</h3>\n<p>为了完整展示删除操作，我们增加一个遍历函数，输出某结点所有出边的信息。这样你可以在删除前后进行对比。<br />\n（其实这已经在 添加与遍历 演示了）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 遍历并输出结点 u 的所有出边（包括边的终点和权值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse_nodes</span><span class=\"params\">(<span class=\"type\">int</span> u)</span><span class=\"comment\">//遍历出发节点 u 的所有目标节点</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 的所有出边信息：&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;( &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;edges[i].to&lt;&lt;<span class=\"string\">&quot; )，权值为 &quot;</span>&lt;&lt;edges[i].weight&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    初始化循环变量：首先令当前的边为第一个出发节点 u 伸出的边的索引</span></span><br><span class=\"line\"><span class=\"comment\">    循环条件：如果 i（其实就是 head[u] ）还存在边，那就继续！</span></span><br><span class=\"line\"><span class=\"comment\">    处理当前边：edges[i].to 指出发节点 u 目前使用 head[u] 边连接到的目标节点，也就是出发节点 u 的邻居</span></span><br><span class=\"line\"><span class=\"comment\">    循环终止操作：找下一条边</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-示例\"><a class=\"markdownIt-Anchor\" href=\"#3-示例\"></a> 3. 示例</h3>\n<p>下面是一个完整的示例程序，展示如何添加边、删除边以及遍历输出：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">省略，真的太长了...</span></span><br><span class=\"line\"><span class=\"comment\">可以翻到上面看看 添加与遍历</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从 u 指向 v 的边（仅删除第一次匹配的边）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_edge</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur=head[u];</span><br><span class=\"line\">    <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(edges[cur].to==v)<span class=\"comment\">//找到目标边</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre==<span class=\"number\">-1</span>)  head[u]=edges[cur].nxt;<span class=\"comment\">//目标边位于链表头部，更新 head[u]</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>  edges[pre].nxt=edges[cur].nxt;<span class=\"comment\">//将前驱边的 nxt 指向当前边的下一条边，从而跳过 cur</span></span><br><span class=\"line\">            <span class=\"comment\">//删除成功：这里可以选择将 edges[cur].nxt 置为 -1，帮助调试（非必须）</span></span><br><span class=\"line\">            edges[cur].nxt=<span class=\"number\">-1</span>;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;删除边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 成功。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre=cur;</span><br><span class=\"line\">        cur=edges[cur].nxt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;边 (&quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; -&gt; &quot;</span>&lt;&lt;v&lt;&lt;<span class=\"string\">&quot;) 不存在，删除失败。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(head,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(head));<span class=\"comment\">//请注意：这里需要初始化为 -1 ，表示目前每个节点都没被连接</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//这是张 **无向图** </span></span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">10</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">add_edge</span>(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>);<span class=\"built_in\">add_edge</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;建边后的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">delete_edge</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;现在的图&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">4</span>;i++)  <span class=\"built_in\">traverse_nodes</span>(i);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例中的初始图长这样：<br />\n<img src=\"https://imghub.ed-builder.top/file/1746946383810_graph.png\" alt=\"graph\" /></p>\n<h4 id=\"程序执行过程说明\"><a class=\"markdownIt-Anchor\" href=\"#程序执行过程说明\"></a> 程序执行过程说明</h4>\n<ol>\n<li>\n<p><strong>添加边阶段：</strong></p>\n<ul>\n<li>对于结点 1，经过多次调用 <code>add_edge(1, ...)</code>，其边链表可能为（头插法的结果是最新添加的边在链表头）：\n<ul>\n<li>头部指向边：1 -&gt; 4</li>\n<li>通过 <code>nxt</code> 链到边：1 -&gt; 3</li>\n<li>再通过 <code>nxt</code> 链到边：1 -&gt; 2</li>\n</ul>\n</li>\n<li>结点 2 拥有边：2 -&gt; 3。</li>\n</ul>\n</li>\n<li>\n<p><strong>删除操作：</strong></p>\n<ul>\n<li>调用 <code>delete_edge(1,3)</code> 后，会遍历结点 1 的边链。</li>\n<li>当遍历到边记录 <code>edges[i].to==3</code> 时，将其从链表中“删除”：\n<ul>\n<li>如果该边不是头部，就把前一个边的 <code>nxt</code> 指向当前边的 <code>nxt</code>。</li>\n</ul>\n</li>\n<li>此后，遍历结点 1 时，1 -&gt; 3 就不会再被输出。</li>\n</ul>\n</li>\n<li>\n<p><strong>遍历验证：</strong></p>\n<ul>\n<li>调用 <code>traverse_node</code> 验证删除后，结点 1 的链表中只剩下 1 -&gt; 4 和 1 -&gt; 2。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-ascii-图示辅助理解删除操作\"><a class=\"markdownIt-Anchor\" href=\"#4-ascii-图示辅助理解删除操作\"></a> 4. ASCII 图示辅助理解删除操作</h3>\n<p>假设初始结点 1 的边链如下（头插法结果，从 head[1] 开始）：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">1</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 1: (1 -&gt;</span> <span class=\"number\">3</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除 1-&gt;3 的过程：</p>\n<ul>\n<li>遍历时，<code>cur</code> 先指向 index 2 (边 1-&gt;4)，不匹配；</li>\n<li>然后 <code>cur</code> 指向 index 1 (边 1-&gt;3)，匹配目标。此时 <code>pre</code> 指向 index 2。</li>\n<li>更新 <code>edges[pre].nxt</code>，即 <code>edges[2].nxt = edges[1].nxt</code>（即 index 0）。</li>\n<li>结果链表变为：</li>\n</ul>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">head</span>[1] --&gt;</span> [<span class=\"function\"><span class=\"title\">index</span> 2: (1 -&gt;</span> <span class=\"number\">4</span>), nxt = index <span class=\"number\">0</span>]</span><br><span class=\"line\">           [<span class=\"function\"><span class=\"title\">index</span> 0: (1 -&gt;</span> <span class=\"number\">2</span>), nxt = -<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n<p>删除后的遍历顺序即输出 1-&gt;4 和 1-&gt;2。</p>\n<hr />\n<h3 id=\"5-小结\"><a class=\"markdownIt-Anchor\" href=\"#5-小结\"></a> 5. 小结</h3>\n<ul>\n<li>\n<p><strong>删除边的思路：</strong></p>\n<ul>\n<li>在链表中找到目标边的位置。</li>\n<li>通过修改上一节点的 <code>nxt</code> 指针或更新 <code>head[u]</code>，跳过目标边，令其不参与后续遍历。</li>\n</ul>\n</li>\n<li>\n<p><strong>局限性：</strong></p>\n<ul>\n<li>这种删除操作只更新了指针，并没有真正回收数组中的空间。</li>\n<li>如果后续还需要添加边，可以继续使用 <code>add_edge</code>，但是删除的空间不会被重用（除非重新构造数据结构）。</li>\n</ul>\n</li>\n<li>\n<p><strong>扩展思考：</strong></p>\n<ul>\n<li>如果需要频繁删除和添加，可以考虑采用“懒删除”或其他更适合动态变化的容器结构。</li>\n</ul>\n</li>\n</ul>\n<p>通过以上代码和说明，你可以在链式前向星上实现边的删除功能。</p>\n<hr />\n<h2 id=\"删除节点\"><a class=\"markdownIt-Anchor\" href=\"#删除节点\"></a> 删除节点</h2>\n<p>下面讨论如何在链式前向星中实现“删除节点”的功能。<br />\n需要注意的是，与插入和删除边相比，“删除节点”更复杂，因为节点通常涉及到两部分：</p>\n<ol>\n<li><strong>删除该节点的所有出边（从该节点出发的边），</strong> 这部分比较简单；</li>\n<li><strong>删除其他节点中所有指向该节点的入边，</strong> 这部分由于链式前向星只存储出边信息，需要遍历所有链表才能找到指向目标节点的边。</li>\n</ol>\n<p>因此，链式前向星更适合作为静态图的存储结构，在节点（或边）频繁动态更新的场景中并不高效。如果确实需要支持节点删除，你可以考虑下面两种方法：</p>\n<hr />\n<h3 id=\"方法-1物理删除实际修改链表结构\"><a class=\"markdownIt-Anchor\" href=\"#方法-1物理删除实际修改链表结构\"></a> 方法 1：物理删除（实际修改链表结构）</h3>\n<p>在物理删除时，我们需要同时删除：</p>\n<ul>\n<li>节点 <strong>u</strong> 的出边（即把 <code>head[u]</code> 置为 -1 或清空整个链表），</li>\n<li>其他所有节点链表中指向 <strong>u</strong> 的边。</li>\n</ul>\n<p>这种方法的基本思路如下：</p>\n<ol>\n<li>\n<p><strong>删除 u 的出边</strong><br />\n直接将 <code>head[u]</code> 设为 -1，相当于断开了 u 对外的所有边。</p>\n</li>\n<li>\n<p><strong>删除所有指向 u 的入边</strong><br />\n遍历图中所有其他节点 v 的边链表，在每个链表中查找边：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (edges[cur].to == u)</span><br></pre></td></tr></table></figure>\n<p>找到后，用类似删除单链表节点的方法跳过它（更新前驱节点的 <code>nxt</code> 指针或更新 <code>head[v]</code>）。</p>\n</li>\n</ol>\n<p>由于链式前向星没有维护“入边”的直接索引，你必须遍历所有节点的链表来删除指向 u 的边。示例代码如下（假设图中节点编号为 1 ~ n，可以事先记录 n）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 物理删除节点 u：同时删除 u 的所有出边和其他所有节点指向 u 的入边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u,<span class=\"type\">int</span> n)</span><span class=\"comment\">//n 表示图中总的节点数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 1. 删除 u 的所有出边：直接断开该链表</span></span><br><span class=\"line\">    head[u]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 2. 删除其他节点中指向 u 的入边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v=<span class=\"number\">1</span>;v&lt;=n;v++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(v==u)  <span class=\"keyword\">continue</span>;<span class=\"comment\">//已经处理了 u 的出边</span></span><br><span class=\"line\">        <span class=\"type\">int</span> cur=head[v];</span><br><span class=\"line\">        <span class=\"type\">int</span> pre=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(edges[cur].to==u)<span class=\"comment\">//找到边 v-&gt;u，需要删除</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pre==<span class=\"number\">-1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//被删除的边在链表头，更新 head[v]</span></span><br><span class=\"line\">                    head[v]=edges[cur].nxt;</span><br><span class=\"line\">                    <span class=\"comment\">//更新 cur 为新的头节点</span></span><br><span class=\"line\">                    cur=head[v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跳过当前边</span></span><br><span class=\"line\">                    edges[pre].nxt=edges[cur].nxt;</span><br><span class=\"line\">                    cur=edges[cur].nxt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 注意：如果存在多条边指向 u，此处可以继续遍历删除</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                pre=cur;</span><br><span class=\"line\">                cur=edges[cur].nxt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 删除完成 (出边和入边均已移除）。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a class=\"markdownIt-Anchor\" href=\"#注意事项\"></a> 注意事项</h4>\n<ul>\n<li>这种物理删除不会真正回收 <code>edges[]</code> 数组中存储被删除边的内存，因为该数组通常是预先分配好的。如果删除操作不频繁，空间浪费可以忽略；如果操作频繁，就需要设计一个“空闲表”来重用这些“空位”，但这会使结构变得复杂。</li>\n<li>删除节点往往是图结构的动态操作，如果图结构频繁变更，可以考虑使用更适合动态更新的其他数据结构（例如基于链表的邻接表或其他动态容器）。</li>\n</ul>\n<hr />\n<h3 id=\"方法-2懒删除逻辑删除\"><a class=\"markdownIt-Anchor\" href=\"#方法-2懒删除逻辑删除\"></a> 方法 2：懒删除（逻辑删除）</h3>\n<p>在很多实际场景下，动态删除节点（或边）时，我们可以采用 <strong>懒删除</strong> 的策略，而不是立即修改链表结构。方法是：</p>\n<ol>\n<li>为每个节点维护一个“是否存在”的标志，例如定义一个布尔数组 <code>nodeExist[N]</code>。</li>\n<li>当需要删除节点 <strong>u</strong> 时，只需将 <code>nodeExist[u]</code> 标记为 <code>false</code></li>\n<li>在遍历和算法中，每次遇到一个节点（或其边）时，都检查其状态，跳过那些已被标记“删除”的节点及其入边或出边。</li>\n</ol>\n<p>这种方法的优点是实现简单、运行效率高，不需要遍历所有边清除指向 u 的边；缺点是图中可能还保留指向“已删除”节点的边，使用时需要小心处理。</p>\n<p>示例代码（仅思路）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> nodeExist[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化时，将所有节点设为存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)  nodeExist[i]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 懒删除节点 u，标记为不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">lazy_delete_node</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    nodeExist[u]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;节点 &quot;</span>&lt;&lt;u&lt;&lt;<span class=\"string\">&quot; 已被标记为删除。&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在遍历时，检查目标节点是否存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process_edges</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!nodeExist[u])  <span class=\"keyword\">return</span>;<span class=\"comment\">//该节点已经被删除，则不处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=head[u];i!=<span class=\"number\">-1</span>;i=edges[i].nxt)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> v=edges[i].to;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!nodeExist[v])  <span class=\"keyword\">continue</span>;<span class=\"comment\">//如果终点已删除，则跳过该边</span></span><br><span class=\"line\">        <span class=\"comment\">// 此处对边 (u -&gt; v) 做处理</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr />\n<h3 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\"></a> 小结</h3>\n<ul>\n<li>\n<p><strong>物理删除节点：</strong></p>\n<ul>\n<li>将该节点的所有出边置为空（如 <code>head[u]=-1</code>），</li>\n<li>遍历其他所有节点的边链表，删除所有指向该节点的入边。</li>\n<li>需要扫描所有链表，可能比较耗时，且“删除”的边内存未回收。</li>\n</ul>\n</li>\n<li>\n<p><strong>懒删除（逻辑删除）：</strong></p>\n<ul>\n<li>通过维护一个节点存在标志，在删除节点时仅做标记。</li>\n<li>在遍历和处理时跳过被删除的节点及其相关边。</li>\n<li>简化了删除操作，但图中依然可能保留对已删除节点的“脏”边，使用时要特别注意。</li>\n</ul>\n</li>\n</ul>\n<p>根据你的需求选择合适的方案。如果图结构比较稳定且删除操作较少，物理删除可以使得后续算法无需额外判断；如果节点、边的动态更新较频繁，建议采用懒删除方式，并在关键操作前做过滤处理。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cmdohm0np0008zgbob9kgg0ls","category_id":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0ok000mzgbo8ta0ejk5"},{"post_id":"cmdohm0np0008zgbob9kgg0ls","category_id":"cmdohm0oe000fzgbo14prb8ul","_id":"cmdohm0ol000pzgbo8b1ld08p"},{"post_id":"cmdohm0mr0001zgbogrhhg106","category_id":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0on000rzgbo2xnybtqg"},{"post_id":"cmdohm0mr0001zgbogrhhg106","category_id":"cmdohm0oe000fzgbo14prb8ul","_id":"cmdohm0oo000szgbo1urfdm45"},{"post_id":"cmdohm0nv0009zgbobtuk80qh","category_id":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0oq000vzgbo6cnj0hn8"},{"post_id":"cmdohm0nv0009zgbobtuk80qh","category_id":"cmdohm0oe000fzgbo14prb8ul","_id":"cmdohm0oq000wzgbogf2j2y9w"},{"post_id":"cmdohm0n70003zgbo1787346c","category_id":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0os000zzgbo43d64q5y"},{"post_id":"cmdohm0n70003zgbo1787346c","category_id":"cmdohm0oe000fzgbo14prb8ul","_id":"cmdohm0os0011zgbohtki7lv7"},{"post_id":"cmdohm0nm0007zgbohssgf8ju","category_id":"cmdohm0nd0004zgboa1t64orb","_id":"cmdohm0ou0014zgbo0yvgb9sb"},{"post_id":"cmdohm0nm0007zgbohssgf8ju","category_id":"cmdohm0oe000fzgbo14prb8ul","_id":"cmdohm0ou0015zgboagt2960k"}],"PostTag":[{"post_id":"cmdohm0mr0001zgbogrhhg106","tag_id":"cmdohm0ni0005zgbo4wz8au82","_id":"cmdohm0od000ezgboees4fpgu"},{"post_id":"cmdohm0mr0001zgbogrhhg106","tag_id":"cmdohm0o2000bzgbo331588v0","_id":"cmdohm0of000gzgbobitn6rfi"},{"post_id":"cmdohm0n70003zgbo1787346c","tag_id":"cmdohm0ob000dzgbo9usf0shf","_id":"cmdohm0oj000kzgbogvl8g683"},{"post_id":"cmdohm0n70003zgbo1787346c","tag_id":"cmdohm0og000hzgbo1r9nezib","_id":"cmdohm0ok000nzgbo0skzh8p3"},{"post_id":"cmdohm0nm0007zgbohssgf8ju","tag_id":"cmdohm0oi000jzgboh2t4ecmw","_id":"cmdohm0os000yzgbof70v1hdg"},{"post_id":"cmdohm0nm0007zgbohssgf8ju","tag_id":"cmdohm0ol000ozgbo7n7mawje","_id":"cmdohm0os0010zgbo0fktb2en"},{"post_id":"cmdohm0nm0007zgbohssgf8ju","tag_id":"cmdohm0og000hzgbo1r9nezib","_id":"cmdohm0ou0013zgbo95jjalqz"},{"post_id":"cmdohm0np0008zgbob9kgg0ls","tag_id":"cmdohm0oi000jzgboh2t4ecmw","_id":"cmdohm0ox0018zgbohdmgh786"},{"post_id":"cmdohm0np0008zgbob9kgg0ls","tag_id":"cmdohm0os0012zgbo8b8g520l","_id":"cmdohm0ox0019zgbo5jcqfp16"},{"post_id":"cmdohm0np0008zgbob9kgg0ls","tag_id":"cmdohm0og000hzgbo1r9nezib","_id":"cmdohm0oz001bzgboggbxbaww"},{"post_id":"cmdohm0nv0009zgbobtuk80qh","tag_id":"cmdohm0oi000jzgboh2t4ecmw","_id":"cmdohm0p0001dzgbo0zkhf4zm"},{"post_id":"cmdohm0nv0009zgbobtuk80qh","tag_id":"cmdohm0oy001azgbo2e66d2b4","_id":"cmdohm0p1001ezgbodqvb3d7e"},{"post_id":"cmdohm0nv0009zgbobtuk80qh","tag_id":"cmdohm0og000hzgbo1r9nezib","_id":"cmdohm0p1001fzgboa8j1covx"}],"Tag":[{"name":"OI","_id":"cmdohm0ni0005zgbo4wz8au82"},{"name":"模板","_id":"cmdohm0o2000bzgbo331588v0"},{"name":"搜索","_id":"cmdohm0ob000dzgbo9usf0shf"},{"name":"算法","_id":"cmdohm0og000hzgbo1r9nezib"},{"name":"图论","_id":"cmdohm0oi000jzgboh2t4ecmw"},{"name":"最小生成树","_id":"cmdohm0ol000ozgbo7n7mawje"},{"name":"最短路","_id":"cmdohm0os0012zgbo8b8g520l"},{"name":"存储","_id":"cmdohm0oy001azgbo2e66d2b4"}]}}